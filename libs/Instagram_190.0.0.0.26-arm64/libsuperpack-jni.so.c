/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 start();
jint JNI_OnLoad_Weak(JavaVM *vm, void *reserved);
__int64 __fastcall write_native(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall read_native(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_483C(__int64 a1, unsigned __int64 a2);
__int64 __fastcall init_superpack_archive(__int64 a1);
unsigned __int64 sub_48DC();
void __fastcall sub_48F8(int a1, int a2, void *ptr);
bool __fastcall sub_4900(__int64 a1, __int64 a2, _QWORD *a3);
__int64 __fastcall sub_491C(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 a4);
unsigned __int64 __fastcall sub_4944(__int64 a1, __int64 a2, __int64 a3);
void **__fastcall sub_4964(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_4AC4(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4, char a5);
__int64 __fastcall sub_4B24(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5);
__int64 __fastcall sub_4BE8(unsigned int a1);
__int64 sub_4BF4();
unsigned __int64 __fastcall sub_4C04(unsigned __int64 a1);
__int64 __fastcall init_superpack_file(__int64 *a1);
void **__fastcall sub_4CB8(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_4D9C(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_4E54(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_4E8C(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_4EA0(__int64 a1, __int64 a2, __int64 a3, int a4, unsigned int a5, __int64 a6, unsigned int a7);
void __fastcall sub_4EF4(__int64 a1, __int64 a2, void **a3);
__int64 __fastcall sub_4EFC(__int64 a1, unsigned __int64 a2);
__int64 sub_4F44();
// __int64 __usercall sub_4F5C@<X0>(__int64 a1@<X8>);
__int64 __fastcall sub_4F68(__int64 a1, __int64 a2, __int64 a3);
__int64 sub_4F88();
__int64 sub_4FA0();
__int64 sub_4FAC();
__int64 __fastcall sub_4FF4(__int64 a1, void *dest);
__int64 __fastcall sub_542C(unsigned int *a1, __int64 **a2, __int64 **a3, __int64 *a4, __int64 a5, unsigned int a6, _QWORD *a7, int a8);
__int64 __fastcall sub_5690(__int64 a1, __int64 *a2, __int64 a3, int a4);
void __fastcall sub_57F4(__int64 a1, char *a2, int a3, void *a4, int a5, __int64 a6);
_DWORD *__fastcall sub_5BCC(__int64 **a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5, unsigned int a6, __int64 a7, unsigned int *a8);
__int64 __fastcall sub_5DC0(__int64 a1, __int64 a2, __int64 **a3, unsigned __int64 a4, unsigned int a5);
__int64 __fastcall sub_5ED8(__int64 a1, __int64 a2, __int64 a3, void *dest);
__int64 __fastcall sub_5FFC(__int64 **a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, int *a5, char a6, int a7, int a8);
__int64 __fastcall sub_61BC(__int64 result, __int64 a2, __int64 a3, __int64 a4, unsigned int *a5, void *a6, unsigned int a7, int a8, int a9);
unsigned __int64 __fastcall sub_6624(unsigned int *a1, void *dest, size_t a3, __int64 a4, __int64 a5, unsigned __int8 a6);
unsigned __int64 __fastcall sub_6818(__int64 a1, __int64 a2, __int64 a3, __int64 **a4, __int64 **a5, unsigned int *a6, __int64 **a7, unsigned __int64 a8, unsigned int a9, __int64 a10, __int64 a11);
unsigned __int64 __fastcall sub_6A30(__int64 a1, __int64 a2, __int64 a3, __int64 **a4, __int64 **a5, unsigned int *a6, __int64 **a7, unsigned __int64 a8, unsigned int a9, __int64 a10, __int64 a11);
__int64 __fastcall sub_6C50(__int64 a1, __int64 **a2, __int64 a3, int a4);
__int64 __fastcall sub_6D4C(__int64 a1, int a2, unsigned __int8 a3, unsigned __int8 *a4);
void __fastcall sub_6ED4(__int64 a1, int8x8_t *a2, unsigned int a3, unsigned int a4, _DWORD *a5, int a6, int a7);
__int64 __fastcall sub_71D4(__int64 a1, void *dest, size_t a3, __int64 a4, __int64 a5, int a6);
void __fastcall sub_74F4(__int64 a1, int8x8_t *a2, unsigned int a3, unsigned int a4, unsigned int *a5);
void __fastcall sub_7824(__int64 a1);
__int64 __fastcall sub_7C24(__int64 result, void *dest, int a3, unsigned __int8 *a4);
void __fastcall sub_BCF4(__int64 a1, __int64 a2, void *dest, unsigned int a4);
void __fastcall sub_BE60(__int64 a1, __int64 a2, void *dest, unsigned int a4);
__int64 __fastcall sub_C020(__int64 a1, __int64 a2, void *dest, int a4);
void __fastcall sub_C1F8(__int64 a1, __int64 a2, void *dest, unsigned int a4, int a5);
char *__fastcall sub_C204(unsigned __int64 a1);
void **__fastcall sub_C2A0(void **result, __int64 a2);
__int64 __fastcall sub_C3F8(__int64 *a1, int a2, int a3, unsigned int *a4);
_BYTE **__fastcall sub_C49C(_BYTE **result, int *a2);
__int64 __fastcall sub_C50C(int a1, char *a2, int a3);
__int64 __fastcall sub_C56C(int a1, unsigned int a2, int a3);
__int64 __fastcall nullsub_2(_QWORD); // weak
__int64 __fastcall sub_C624(__int64 result, __int64 *a2, int a3, int a4);
__int64 __fastcall sub_C740(__int64 result, unsigned int a2);
__int64 __fastcall sub_C958(__int64 result, unsigned int a2);
__int64 __fastcall sub_CA14(__int64 result, unsigned int a2);
__int64 __fastcall sub_CB84(__int64 a1, __int64 a2);
__int64 __fastcall sub_CB94(int *a1, _DWORD *a2);
__int64 __fastcall sub_CBB8(_DWORD *a1, _DWORD *a2);
__int64 __fastcall sub_CBC8(__int64 a1, __int64 *a2, int a3);
__int64 __fastcall sub_CD84(__int64 a1, __int64 *a2, int a3);
__int64 sub_CEA0();
__int64 sub_CEE8();
__int64 __fastcall sub_CEF0(__int64 *a1);
__int64 __fastcall sub_CF6C(__int64 a1, void *dest, unsigned int *a3, unsigned int *a4, int a5);
__int64 __fastcall sub_D154(__int64 result);
__int64 __fastcall sub_D5AC(__int64 *a1);
void *__fastcall sub_D788(_QWORD *a1);
__int64 __fastcall sub_D7FC(__int64 result);
__int64 __fastcall sub_D900(__int64 a1, int a2);
void __fastcall sub_DA68(_QWORD *a1);
void *__fastcall sub_E068(_QWORD *a1);
void *__fastcall sub_E0E0(__int64 ****a1);
void *__fastcall sub_E158(__int64 ****a1);
void *__fastcall sub_E1CC(__int64 ****a1);
void *__fastcall sub_E240(__int64 ****a1);
void *__fastcall sub_E2B4(__int64 ****a1);
void *__fastcall sub_E328(_QWORD *a1);
__int64 __fastcall sub_E5B4(__int64 result, int a2, __int64 a3, _DWORD *a4);
// long double __usercall sub_E5D8@<Q0>(int a1@<W0>, _DWORD *a2@<X1>, unsigned int *a3@<X2>, __int64 a4@<X8>);
__int64 __fastcall sub_E64C(__int64 result, int a2, int a3, __int64 a4, unsigned int a5);
__int64 __fastcall sub_E680(__int64 a1, unsigned int a2);
__int64 __fastcall sub_E6AC(__int64 a1, unsigned int a2);
__int64 __fastcall sub_E6D8(unsigned __int8 *a1, int a2);
__int64 __fastcall sub_E704(unsigned __int16 *a1, int a2);
__int64 __fastcall sub_E730(__int64 a1, void *dest, int a3, unsigned __int8 *a4);
__int64 __fastcall sub_10934(int a1, __int64 a2, void *dest, int a4);
__int64 __fastcall sub_10C38(unsigned __int16 a1, __int64 a2, _DWORD *a3);
__int64 __fastcall sub_10C8C(__int64 a1);
__int64 sub_10D54();
void *__fastcall sub_10D9C(__int64 a1);
_QWORD *sub_10E2C();
__int64 __fastcall sub_10ECC(FILE *a1, __int64 a2);
void __fastcall sub_111F0(void *ptr);
__int64 __fastcall sub_11250(__int64 a1, int a2, const void *a3, __int64 a4);
__int64 __fastcall sub_112F4(__int64 a1, int a2, int a3);
_QWORD *__fastcall sub_11328(__int64 a1);
void **__fastcall sub_113B4(__int64 a1, __int64 *a2, int a3);
__int64 __fastcall sub_1151C(__int64 a1, char *a2);
__int64 __fastcall sub_1161C(unsigned __int64 *a1, __int64 a2, char *a3);
bool __fastcall sub_11698(_QWORD *a1);
__int64 __fastcall sub_116A8(__int64 a1, __int64 a2, char *s2);
__int64 __fastcall sub_11898(_QWORD *a1);
__int64 __fastcall sub_118BC(__int64 result, __int64 a2);
__int64 __fastcall sub_118C8(_QWORD *a1, int a2);
__int64 __fastcall sub_118DC(__int64 a1);
char *__fastcall sub_11920(__int64 a1, const char *a2, const char *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_11988(__int64 a1, __int64 a2, const char *a3, int a4, __int64 a5);
__int64 __fastcall sub_11AB8(__int64 a1, __int64 a2, char *a3, __int64 a4);
__int64 __fastcall sub_11AD4(const char *a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5);
__int64 __fastcall sub_11BE4(const char *a1, __int64 a2, _QWORD *a3);
__int64 __fastcall sub_11CBC(__int64 a1, int a2);
__int64 __fastcall sub_11D5C(__int64 result);
void __fastcall sub_11D68(__int64 a1);
__int64 __fastcall sub_11E4C(__int64 a1);
void __fastcall sub_11FB4(__int64 a1);
_QWORD *__fastcall sub_120AC(__int64 a1);
__int64 __fastcall sub_12174(__int64 a1, __int64 *a2);
__int64 sub_12348();
__int64 __fastcall sub_12350(__int64 a1);
void __fastcall sub_12364(__int64 a1, unsigned __int8 *a2);
__int64 __fastcall sub_13E44(unsigned __int8 *a1, unsigned __int8 *a2);
__int64 __fastcall sub_13E74(unsigned __int8 *a1, __int64 a2);
__int64 __fastcall sub_148B0(FILE *stream, void *ptr, size_t a3);
__int64 __fastcall sub_148D4(FILE *s, void *ptr, size_t a3);
__int64 sub_148F8();
_QWORD *__fastcall sub_14900(int a1);
void __fastcall sub_14954(_QWORD *a1);
__int64 __fastcall sub_14978(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_14A5C(unsigned __int64 a1);
void __fastcall sub_14B2C(__int64 a1);
__int64 __fastcall sub_14BB4(__int64 a1, void *dest, int a3, int a4);
__int64 __fastcall sub_14CB0(__int64 **a1, void *dest, int a3);
__int64 __fastcall sub_14D88(__int64 a1);
__int64 __fastcall sub_14DB4(FILE *stream); // idb
__int64 __fastcall sub_14DE4(FILE *a1);
__int64 __fastcall sub_14FB8(__int64 **a1);
__int64 __fastcall sub_150D0(__int64 **a1);
__int64 __fastcall sub_15208(__int64 a1, FILE *s);
__int64 __fastcall sub_1533C(__int64 a1, unsigned __int64 a2, int a3);
void __fastcall sub_153D8(__int64 a1);
__int64 sub_15408();
unsigned __int64 __fastcall sub_15410(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_158F0(__int64 a1, __int64 *a2);
char *__fastcall sub_16154(int a1, unsigned int a2);
void __fastcall sub_161E8(void **a1);
__int64 __fastcall sub_1620C(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_16988(int a1, unsigned int a2);
__int64 __fastcall sub_16A14(__int64 a1, unsigned __int8 a2);
void __fastcall sub_16AD4(void *ptr);
__int64 __fastcall sub_16AF8(__int64 a1);
unsigned int *__fastcall sub_17728(unsigned int *result, unsigned __int16 *a2, int a3);
_QWORD *__fastcall sub_17908(__int64 a1, __int64 a2);
unsigned __int64 __fastcall sub_17984(__int64 a1, __int64 a2, int a3);
__int64 sub_17A58();
__int64 __fastcall sub_17A60(__int64 a1);
__int64 __fastcall sub_17A8C(__int64 *a1);
__int64 __fastcall sub_17B18(__int64 *a1);
__int64 __fastcall sub_17CBC(__int64 *a1, __int64 a2);
__int64 __fastcall sub_17D8C(_QWORD *a1, const void *a2, int a3);
__int64 __fastcall sub_17DFC(__int64 a1);
void __fastcall sub_17E3C(void **a1);
__int64 __fastcall sub_17E58(__int64 *a1);
__int64 __fastcall sub_17EDC(_QWORD *a1, void *dest, signed int a3);
__int64 __fastcall sub_17FEC(_QWORD *a1);
// __int64 __usercall sub_180B4@<X0>(__int64 a1@<X8>);
__int64 __fastcall sub_180BC(__int64 a1, __int64 a2, const char *a3);
// __int64 __usercall sub_180C4@<X0>(__int64 (__fastcall *a1)(__int64, __int64)@<X8>);
__int64 sub_180D0();
// __int64 __usercall sub_180DC@<X0>(__int64 a1@<X8>);
__int64 __fastcall sub_180E8(__int64 *a1);
void *__fastcall sub_180F4(size_t a1, size_t a2);
__int64 __fastcall sub_1810C(__int64 a1);
void *__fastcall sub_18124(void *a1, size_t a2);
void j__free(void *ptr); // idb
char *__fastcall sub_18140(const char *a1);
void __fastcall sub_18158(__int64 a1);
_QWORD *__fastcall sub_18178(_QWORD *result, const void *a2, __int64 a3);
char *__fastcall sub_181E0(unsigned int a1);
void __fastcall sub_18204(__int64 a1);
void __fastcall sub_1820C(void **a1);
_QWORD *__fastcall sub_18234(const char *a1, __int64 a2);
__int64 __fastcall sub_182B8(const char *a1, FILE *a2);
__int64 __fastcall sub_18398(__int64 a1);
__int64 __fastcall sub_183A0(__int64 a1);
__int64 __fastcall sub_183A8(__int64 a1);
__int64 __fastcall sub_183B0(unsigned __int8 *a1);
bool __fastcall sub_183D8(const char *a1, const char *a2);
_QWORD *__fastcall sub_183F0(__int64 a1);
void __fastcall sub_18438(void *a1);
_QWORD *__fastcall sub_184E4(_QWORD *a1, __int64 a2);
_QWORD *__fastcall sub_18560(__int64 a1, __int64 a2, char *a3);
char *__fastcall sub_18710(const char *a1);
__int64 sub_1872C(__int64 a1, __int64 a2, const char *a3, ...);
// int __fastcall __cxa_finalize(void *);
// int fclose(FILE *stream);
// void *memcpy(void *dest, const void *src, size_t n);
// __int64 __fastcall __wrap_malloc(_QWORD); weak
// void *memset(void *s, int c, size_t n);
// void free(void *ptr);
// int strcmp(const char *s1, const char *s2);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// size_t strlen(const char *s);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// size_t strnlen(const char *string, size_t maxlen);
// char *strcpy(char *dest, const char *src);
// char *strncpy(char *dest, const char *src, size_t n);
// int strncmp(const char *s1, const char *s2, size_t n);
// void setbuffer(FILE *stream, char *buf, size_t size);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
// int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
// int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
// __int64 __fastcall funopen(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int __android_log_print(int prio, const char *tag, const char *fmt, ...);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
// int pthread_cond_signal(pthread_cond_t *cond);
// int pthread_cond_broadcast(pthread_cond_t *cond);
// int pthread_mutex_destroy(pthread_mutex_t *mutex);
// int pthread_cond_destroy(pthread_cond_t *cond);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *cond_attr);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int pthread_detach(pthread_t th);
// void *calloc(size_t nmemb, size_t size);
// int feof(FILE *stream);
// int ferror(FILE *stream);
// void *memmove(void *dest, const void *src, size_t n);
// void __noreturn abort(void);
// void *realloc(void *ptr, size_t size);
// char *strdup(const char *s);
// char *strrchr(const char *s, int c);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
char byte_5 = '\x01'; // weak
_UNKNOWN unk_1DB7; // weak
_UNKNOWN unk_1DDB; // weak
_UNKNOWN unk_1F35; // weak
_UNKNOWN unk_2070; // weak
const char aCouldNotCreate_0[] = "could not create FILE*"; // idb
char byte_2231 = '\0'; // weak
unsigned __int8 byte_22C1[3] = { 0u, 1u, 0u }; // idb
__int128 xmmword_24D0 = 0x3000000020000000100000000LL; // weak
_DWORD dword_24E0[8] = { 0, 1, 2, 2, 3, 3, 3, 3 }; // idb
char *off_19B08[2] = { "createNative", "()J" }; // weak
char *off_19BF8[2] = { "createSuperpackFileNative", "(Ljava/lang/String;[B)J" }; // weak
__int64 (__fastcall *off_19C88[2])() = { &sub_183B0, &sub_183D8 }; // weak
_UNKNOWN unk_19C98; // weak
char *off_19CA8[5] = { "spk", "xz", "zstd", "br", "lz4" }; // weak
__int64 (__fastcall *off_19CD0)() = &off_19D30; // weak
__int64 (__fastcall *off_19D60)() = &sub_14B2C; // weak
__int64 (__fastcall *off_19D70[6])() = { &sub_153D8, &sub_15408, &sub_17908, &sub_17984, &sub_17A58, &sub_17A60 }; // weak
char *off_19DB0 = "success"; // weak
void *off_1B168 = &off_1B168; // weak
_UNKNOWN unk_1B170; // weak
unsigned __int8 byte_1B180[255] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  2u,
  2u,
  2u,
  1u,
  1u,
  2u,
  1u,
  2u,
  0u,
  0u,
  1u,
  1u,
  2u,
  2u,
  2u,
  2u,
  1u,
  1u,
  2u,
  2u,
  2u,
  2u,
  1u,
  2u,
  0u,
  1u,
  2u,
  2u,
  2u,
  1u,
  2u,
  1u,
  2u,
  2u,
  2u,
  1u,
  2u,
  2u,
  2u,
  1u,
  2u,
  2u,
  2u,
  1u,
  2u,
  2u,
  2u,
  2u,
  1u,
  2u,
  2u,
  1u,
  1u,
  1u,
  0u,
  2u,
  1u,
  2u,
  0u,
  2u,
  2u,
  2u,
  2u,
  2u,
  1u,
  2u,
  2u,
  1u,
  2u,
  2u,
  2u,
  2u,
  1u,
  1u,
  2u,
  2u,
  2u,
  1u,
  1u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  1u,
  1u,
  1u,
  2u,
  2u,
  2u,
  1u,
  1u,
  2u,
  2u,
  1u,
  1u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  0u,
  2u,
  2u,
  0u,
  2u,
  2u,
  2u,
  1u,
  2u,
  2u,
  1u,
  2u,
  2u,
  2u,
  2u,
  1u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  2u,
  3u,
  0u,
  3u,
  1u,
  3u,
  3u,
  3u,
  2u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  1u,
  2u,
  3u,
  2u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  1u,
  3u,
  3u,
  2u,
  2u,
  3u,
  2u,
  3u,
  3u,
  3u,
  0u,
  2u,
  3u,
  3u,
  2u,
  1u,
  2u,
  2u,
  2u,
  3u,
  3u,
  3u,
  2u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u
}; // idb
_QWORD qword_1B27F[255] =
{
  0LL,
  2483027968LL,
  335544320LL,
  3573751839LL,
  3596551104LL,
  1409286144LL,
  1409286145LL,
  1409286146LL,
  1409286155LL,
  1409286152LL,
  1409286154LL,
  1409286147LL,
  1409286156LL,
  1409286153LL,
  1409286157LL,
  2415919104LL,
  310378496LL,
  3019898880LL,
  872415232LL,
  310378496LL,
  1384120320LL,
  3594452992LL,
  905969664LL,
  889192448LL,
  4068474880LL,
  4043309087LL,
  922746880LL,
  3036676096LL,
  1895825439LL,
  446629856LL,
  3592355840LL,
  310378496LL,
  1862329344LL,
  2457862144LL,
  1923088384LL,
  1912602655LL,
  3531603976LL,
  301989896LL,
  268435456LL,
  822083615LL,
  2449473536LL,
  251659264LL,
  509612032LL,
  310382600LL,
  2051016704LL,
  505417728LL,
  2852127712LL,
  2432697312LL,
  2432696320LL,
  4181721088LL,
  4181721088LL,
  4181722080LL,
  4177527776LL,
  704644064LL,
  2432697312LL,
  3942645791LL,
  3506439167LL,
  2432697343LL,
  4164945904LL,
  4162326496LL,
  1895825408LL,
  4177526784LL,
  4177526784LL,
  3107979264LL,
  2854159328LL,
  706675680LL,
  960495616LL,
  3506438144LL,
  1795162143LL,
  3103784960LL,
  3103785952LL,
  3107979264LL,
  4177527807LL,
  3107980256LL,
  1358954496LL,
  285212672LL,
  956301312LL,
  4177526815LL,
  960495616LL,
  4177526815LL,
  4165992448LL,
  2470476800LL,
  3544186880LL,
  956301343LL,
  148896768LL,
  301989888LL,
  3103784960LL,
  3577466944LL,
  3544251392LL,
  1035993088LL,
  2453667840LL,
  956302304LL,
  4160750592LL,
  4248829952LL,
  1015021568LL,
  1031798784LL,
  960496608LL,
  2470509568LL,
  1035993088LL,
  1031799776LL,
  4181722080LL,
  4177527776LL,
  956302335LL,
  3112173568LL,
  3103784991LL,
  1031798784LL,
  3103785983LL,
  4244635648LL,
  4043309056LL,
  3175088128LL,
  956301312LL,
  2034237440LL,
  4244636640LL,
  2657550336LL,
  4164946944LL,
  1031799776LL,
  2030043136LL,
  1309154304LL,
  1392508928LL,
  4161798144LL,
  1015022560LL,
  4160752671LL,
  2990538752LL,
  706741216LL,
  1392540672LL,
  1319115776LL,
  1035994080LL,
  2287991808LL,
  2991325440LL,
  1019215872LL,
  3007315968LL,
  2969567232LL,
  2034237440LL,
  4164944896LL,
  301990144LL,
  939525120LL,
  4248830944LL,
  4160750623LL,
  2030044128LL,
  509616128LL,
  3092250624LL,
  318798848LL,
  1035994080LL,
  1019216864LL,
  4248829952LL,
  943719424LL,
  956301343LL,
  2034238432LL,
  2030043136LL,
  3942645791LL,
  1392517128LL,
  301990912LL,
  855638016LL,
  2453667840LL,
  505593856LL,
  944766976LL,
  1319640320LL,
  3091203072LL,
  3112173568LL,
  4177527807LL,
  2453668864LL,
  505872640LL,
  1258292192LL,
  3103785952LL,
  1778384927LL,
  3544190976LL,
  2657551328LL,
  2470470656LL,
  505421824LL,
  2453693440LL,
  943721472LL,
  3103784991LL,
  1392509184LL,
  2042626056LL,
  1375731712LL,
  3087008768LL,
  2835350496LL,
  2839544800LL,
  2831172592LL,
  2847425520LL,
  2332033024LL,
  2332033024LL,
  3405774848LL,
  184549376LL,
  2839543808LL,
  2839543808LL,
  2592079872LL,
  444596224LL,
  945842176LL,
  1258291200LL,
  2835349504LL,
  2600500224LL,
  2835350496LL,
  2835349504LL,
  2835382271LL,
  4167071744LL,
  2835381279LL,
  2596276224LL,
  453016576LL,
  704643072LL,
  2902459360LL,
  509609984LL,
  2334130176LL,
  2596277248LL,
  2902458368LL,
  4167067648LL,
  509618176LL,
  505415680LL,
  2835381279LL,
  2835381248LL,
  4162877440LL,
  2592080864LL,
  184549376LL,
  167772160LL,
  2282290176LL,
  2902458368LL,
  3942645760LL,
  692060160LL,
  1241513984LL,
  2852126720LL,
  941647872LL,
  2906652672LL,
  3093329920LL,
  3093325824LL,
  2835382240LL,
  2596283392LL,
  3405774848LL,
  1832920041LL,
  1828725737LL,
  448798720LL,
  2839544800LL,
  3093321728LL,
  687865856LL,
  2596282368LL,
  2835382271LL,
  446627840LL,
  1241513984LL,
  3089135616LL,
  2902459360LL,
  2835350527LL,
  2906653664LL,
  687866848LL,
  692061152LL,
  692060160LL,
  4162873344LL,
  509614080LL,
  2594111488LL,
  2906652672LL,
  2019588096LL,
  2868903936LL,
  2600468480LL,
  2600501248LL,
  452984832LL,
  2334179328LL,
  2334146560LL
}; // idb
_UNKNOWN unk_1BA78; // weak
unsigned __int8 byte_1BA88[159] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  0u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  0u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  1u,
  0u,
  2u,
  2u,
  2u,
  0u,
  0u,
  0u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u
}; // idb
_UNKNOWN unk_1BB27; // weak
_DWORD dword_1C658[160] =
{
  1,
  2,
  5,
  1,
  2,
  1,
  10,
  14,
  6,
  4,
  3,
  3,
  4,
  2,
  2,
  3,
  2,
  10,
  6,
  3,
  4,
  3,
  2,
  2,
  2,
  2,
  2,
  8,
  6,
  2,
  14,
  6,
  10,
  2,
  2,
  6,
  2,
  3,
  3,
  6,
  2,
  18,
  4,
  6,
  5,
  4,
  6,
  4,
  5,
  4,
  5,
  3,
  6,
  9,
  4,
  7,
  4,
  7,
  4,
  5,
  4,
  7,
  4,
  4,
  4,
  5,
  7,
  4,
  3,
  4,
  4,
  3,
  3,
  4,
  7,
  5,
  7,
  7,
  3,
  7,
  5,
  3,
  5,
  4,
  3,
  4,
  3,
  4,
  5,
  3,
  7,
  7,
  7,
  4,
  4,
  4,
  4,
  3,
  7,
  7,
  7,
  4,
  4,
  4,
  4,
  7,
  7,
  4,
  7,
  7,
  7,
  7,
  3,
  7,
  7,
  3,
  3,
  7,
  7,
  4,
  4,
  5,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  6,
  6,
  6,
  7,
  0
}; // idb
_UNKNOWN unk_1C8D8; // weak
__int64 (__fastcall *off_1C8E8)() = &sub_18204; // weak
__int64 edata; // weak
__int64 qword_1C8F8; // weak
pthread_rwlock_t stru_1C900; // idb
int dword_1C938; // weak
pthread_mutex_t stru_1C93C; // idb
__int64 qword_1C968; // weak
__int64 qword_1C970; // weak


//----- (000000000000463C) ----------------------------------------------------
__int64 start()
{
  return __cxa_finalize(&off_1B168);
}
// 1B168: using guessed type void *off_1B168;

//----- (0000000000004648) ----------------------------------------------------
jint JNI_OnLoad_Weak(JavaVM *vm, void *reserved)
{
  jint v2; // w19
  __int64 *v4; // [xsp+8h] [xbp-18h] BYREF

  v2 = 65542;
  if ( (*vm)->GetEnv(vm, (void **)&v4, 65542LL)
    || (unsigned int)init_superpack_archive((__int64)v4)
    || (unsigned int)init_superpack_file(v4) )
  {
    return -1;
  }
  sub_4FAC();
  sub_CEA0();
  sub_10D54();
  return v2;
}

//----- (00000000000046B4) ----------------------------------------------------
__int64 __fastcall write_native(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v6; // x0
  FILE *v7; // x20
  unsigned int v8; // w0

  v6 = sub_17A8C((__int64 *)a1);
  if ( !v6 )
    return sub_1872C(a1, (__int64)"java/lang/RuntimeException", "could not adapt output stream");
  v7 = (FILE *)v6;
  v8 = sub_116A8(a3, v6, &byte_2231);
  sub_4BE8(v8);
  return fclose(v7);
}
// 2231: using guessed type char byte_2231;

//----- (0000000000004760) ----------------------------------------------------
__int64 __fastcall read_native(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v6; // x0
  FILE *v7; // x19
  __int64 v8; // x0
  __int64 v9; // x22
  __int64 v10; // x23

  v6 = sub_17E58((__int64 *)a1);
  if ( v6 )
  {
    v7 = (FILE *)v6;
    v8 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, a4, 0LL);
    if ( v8 )
    {
      v9 = v8;
      v10 = sub_10ECC(v7, v8);
      if ( (unsigned int)sub_483C(a1, v10) )
        v10 = 0LL;
      (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 1360LL))(a1, a4, v9);
    }
    else
    {
      sub_1872C(a1, (__int64)"java/lang/RuntimeException", "could not extract storage type");
      v10 = 0LL;
    }
    fclose(v7);
  }
  else
  {
    sub_1872C(a1, (__int64)"java/lang/RuntimeException", "could not adapt input stream");
    v10 = 0LL;
  }
  return v10;
}

//----- (000000000000483C) ----------------------------------------------------
__int64 __fastcall sub_483C(__int64 a1, unsigned __int64 a2)
{
  char *v3; // x0

  if ( a2 >= 0x14 )
    LODWORD(a2) = 0;
  if ( !(_DWORD)a2 )
    return 0LL;
  v3 = sub_181E0(a2);
  sub_1872C(a1, (__int64)"java/lang/RuntimeException", "superpack error: %s", v3);
  return 0xFFFFFFFFLL;
}

//----- (0000000000004848) ----------------------------------------------------
__int64 __fastcall init_superpack_archive(__int64 a1)
{
  __int64 v2; // x0
  __int64 v3; // x20
  __int64 result; // x0
  _BYTE v5[240]; // [xsp+0h] [xbp-110h] BYREF

  v2 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(
         a1,
         "com/facebook/superpack/SuperpackArchive");
  if ( !v2 )
    return 0xFFFFFFFFLL;
  v3 = v2;
  if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)a1 + 1824LL))(a1) )
    return 0xFFFFFFFFLL;
  memcpy(v5, off_19B08, sizeof(v5));
  if ( (*(unsigned int (__fastcall **)(__int64, __int64, _BYTE *, __int64))(*(_QWORD *)a1 + 1720LL))(a1, v3, v5, 10LL) )
    result = 0xFFFFFFFFLL;
  else
    result = 0LL;
  return result;
}
// 19B08: using guessed type char *off_19B08[2];

//----- (00000000000048DC) ----------------------------------------------------
unsigned __int64 sub_48DC()
{
  _QWORD *v0; // x0

  v0 = sub_10E2C();
  return sub_4C04((unsigned __int64)v0);
}

//----- (00000000000048F8) ----------------------------------------------------
void __fastcall sub_48F8(int a1, int a2, void *ptr)
{
  sub_111F0(ptr);
}

//----- (0000000000004900) ----------------------------------------------------
bool __fastcall sub_4900(__int64 a1, __int64 a2, _QWORD *a3)
{
  return sub_11698(a3);
}

//----- (000000000000491C) ----------------------------------------------------
__int64 __fastcall sub_491C(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 a4)
{
  char *v4; // x0
  unsigned int v7; // w1

  v7 = sub_1161C(a3, a4, 0LL);
  if ( !v7 )
    return 0LL;
  v4 = sub_181E0(v7);
  sub_1872C(a1, (__int64)"java/lang/RuntimeException", "superpack error: %s", v4);
  return 0xFFFFFFFFLL;
}

//----- (0000000000004944) ----------------------------------------------------
unsigned __int64 __fastcall sub_4944(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v3; // x0

  v3 = sub_11328(a3);
  return sub_4C04((unsigned __int64)v3);
}

//----- (0000000000004964) ----------------------------------------------------
void **__fastcall sub_4964(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  int v6; // w23
  __int64 v7; // x24
  __int64 *v8; // x0
  __int64 *v9; // x21
  __int64 v10; // x24
  __int64 v11; // x25
  __int64 v12; // x0
  __int64 v13; // x8
  __int64 v14; // x0
  __int64 v15; // x0
  void **v16; // x22
  __int64 i; // x23
  __int64 v18; // x0
  __int64 v19; // x8
  __int64 v20; // x0

  v6 = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1368LL))(a1, a4);
  v7 = (__int64)((unsigned __int64)(unsigned int)v6 << 32) >> 29;
  v8 = (__int64 *)__wrap_malloc(v7);
  if ( v8 )
  {
    v9 = v8;
    memset(v8, 0, v7);
    v10 = 0LL;
    v11 = v6 & (unsigned int)~(v6 >> 31);
    while ( v11 != v10 )
    {
      v12 = sub_4BF4();
      v14 = (*(__int64 (__fastcall **)(__int64))(v13 + 1384))(v12);
      v15 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, v14, 0LL);
      v9[v10++] = v15;
      if ( !v15 )
      {
        sub_1872C(a1, (__int64)"java/lang/RuntimeException", "could not extract jstring lib file name");
        v16 = 0LL;
        goto LABEL_9;
      }
    }
    v16 = sub_113B4(a3, v9, v6);
    if ( (unsigned int)sub_483C(a1, (unsigned __int64)v16) )
      v16 = 0LL;
LABEL_9:
    for ( i = 0LL; v11 != i; ++i )
    {
      if ( v9[i] )
      {
        v18 = sub_4BF4();
        v20 = (*(__int64 (__fastcall **)(__int64))(v19 + 1384))(v18);
        (*(void (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)a1 + 1360LL))(a1, v20, v9[i]);
      }
    }
    free(v9);
  }
  else
  {
    sub_1872C(a1, (__int64)"java/lang/RuntimeException", "failed to allocate memory for lib file names");
    v16 = 0LL;
  }
  return v16;
}
// 49CC: variable 'v13' is possibly undefined
// 4A7C: variable 'v19' is possibly undefined
// 18890: using guessed type __int64 __fastcall __wrap_malloc(_QWORD);

//----- (0000000000004AC4) ----------------------------------------------------
__int64 __fastcall sub_4AC4(__int64 a1, __int64 a2, __int64 a3, unsigned __int8 a4, char a5)
{
  char *v5; // x0
  unsigned int v9; // w0
  __int64 result; // x0
  unsigned int v11; // w1

  v9 = sub_112F4(a3, 1, a4);
  result = sub_4BE8(v9);
  if ( !(_DWORD)result )
  {
    v11 = sub_112F4(a3, 0, a5 == 0);
    if ( v11 )
    {
      v5 = sub_181E0(v11);
      sub_1872C(a1, (__int64)"java/lang/RuntimeException", "superpack error: %s", v5);
      result = 0xFFFFFFFFLL;
    }
    else
    {
      result = 0LL;
    }
  }
  return result;
}

//----- (0000000000004B24) ----------------------------------------------------
__int64 __fastcall sub_4B24(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5)
{
  const char *v8; // x0
  char *v9; // x2
  __int64 v10; // x3
  int v11; // w1
  unsigned int v13; // w0
  __int64 v14; // x0
  __int64 v15; // x8
  char v16; // [xsp+8h] [xbp-38h] BYREF

  v8 = (const char *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, a4, 0LL);
  if ( !v8 )
    return sub_1872C(a1, (__int64)"java/lang/RuntimeException", "could not extract storage type");
  if ( !strcmp(v8, "lz4") )
  {
    v9 = &v16;
    v11 = 4;
    v10 = 1LL;
    v16 = a5;
  }
  else
  {
    v9 = 0LL;
    v10 = 0LL;
    v11 = 0;
  }
  v13 = sub_11250(a3, v11, v9, v10);
  sub_4BE8(v13);
  v14 = sub_4BF4();
  return (*(__int64 (__fastcall **)(__int64))(v15 + 1360))(v14);
}
// 4BCC: variable 'v15' is possibly undefined

//----- (0000000000004BE8) ----------------------------------------------------
__int64 __fastcall sub_4BE8(unsigned int a1)
{
  const char *v1; // x0
  __int64 v3; // x19

  if ( !a1 )
    return 0LL;
  v1 = (const char *)sub_181E0(a1);
  sub_1872C(v3, "java/lang/RuntimeException", "superpack error: %s", v1);
  return 0xFFFFFFFFLL;
}
// 4748: variable 'v3' is possibly undefined
// 181E0: using guessed type __int64 __fastcall sub_181E0(_QWORD);
// 1872C: using guessed type __int64 sub_1872C(_QWORD, _QWORD, const char *, ...);

//----- (0000000000004BF4) ----------------------------------------------------
__int64 sub_4BF4()
{
  __int64 v0; // x19

  return v0;
}
// 4BF8: variable 'v0' is possibly undefined

//----- (0000000000004C04) ----------------------------------------------------
unsigned __int64 __fastcall sub_4C04(unsigned __int64 a1)
{
  __int64 v1; // x19
  unsigned __int64 result; // x0

  if ( (unsigned int)sub_483C(v1, a1) )
    result = 0LL;
  else
    result = a1;
  return result;
}
// 4C14: variable 'v1' is possibly undefined

//----- (0000000000004C2C) ----------------------------------------------------
__int64 __fastcall init_superpack_file(__int64 *a1)
{
  __int64 v2; // x0
  __int64 v3; // x20
  __int64 result; // x0
  _BYTE v5[144]; // [xsp+0h] [xbp-B0h] BYREF

  v2 = (*(__int64 (__fastcall **)(__int64 *, const char *))(*a1 + 48))(a1, "com/facebook/superpack/SuperpackFile");
  if ( !v2 )
    return 0xFFFFFFFFLL;
  v3 = v2;
  if ( (unsigned __int8)sub_4F5C(*a1) )
    return 0xFFFFFFFFLL;
  memcpy(v5, off_19BF8, sizeof(v5));
  if ( (*(unsigned int (__fastcall **)(__int64 *, __int64, _BYTE *, __int64))(*a1 + 1720))(a1, v3, v5, 6LL) )
    result = 0xFFFFFFFFLL;
  else
    result = 0LL;
  return result;
}
// 19BF8: using guessed type char *off_19BF8[2];

//----- (0000000000004CB8) ----------------------------------------------------
void **__fastcall sub_4CB8(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 *v3; // x19
  __int64 v4; // x0
  const char *v5; // x21
  void **v6; // x23
  __int64 v7; // x0
  __int64 v8; // x8
  unsigned int v9; // w24
  void (__fastcall *v10)(__int64, __int64, _QWORD, _QWORD); // x25
  __int64 v11; // x0
  __int64 v12; // x1

  v4 = sub_4F68(a1, a2, a3);
  if ( v4 )
  {
    v5 = (const char *)v4;
    if ( (unsigned __int8)sub_4F5C(*v3) )
    {
      sub_4F44();
    }
    else
    {
      v7 = sub_4FA0();
      v9 = (*(__int64 (__fastcall **)(__int64))(v8 + 1368))(v7);
      if ( !(unsigned __int8)sub_4F5C(*v3) )
      {
        v6 = (void **)sub_18234(v5, (int)v9);
        if ( !(unsigned int)sub_4EFC((__int64)v3, (unsigned __int64)v6) )
        {
          v10 = *(void (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(*v3 + 1600);
          sub_183A8((__int64)v6);
          v11 = sub_4FA0();
          v10(v11, v12, 0LL, v9);
          if ( !(unsigned __int8)sub_4F5C(*v3) || !v6 )
            goto LABEL_11;
          sub_1820C(v6);
        }
      }
    }
    v6 = 0LL;
LABEL_11:
    sub_4F88();
    return v6;
  }
  sub_4F44();
  return 0LL;
}
// 4CD0: variable 'v3' is possibly undefined
// 4D00: variable 'v8' is possibly undefined
// 4D5C: variable 'v12' is possibly undefined

//----- (0000000000004D9C) ----------------------------------------------------
__int64 __fastcall sub_4D9C(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 *v3; // x19
  __int64 v4; // x0
  const char *v5; // x21
  __int64 v6; // x22
  __int64 *v7; // x0
  FILE *v8; // x0
  FILE *v9; // x23
  __int64 v10; // x0
  unsigned __int64 v11; // x1

  v4 = sub_4F68(a1, a2, a3);
  if ( v4 )
  {
    v5 = (const char *)v4;
    if ( (unsigned __int8)sub_4F5C(*v3) )
    {
      sub_1872C((__int64)v3, (__int64)"java/lang/RuntimeException", "could not acquire file bytes");
    }
    else
    {
      v7 = (__int64 *)sub_4FA0();
      v8 = (FILE *)sub_17E58(v7);
      if ( v8 )
      {
        v9 = v8;
        v6 = sub_182B8(v5, v8);
        v10 = sub_4FA0();
        if ( (unsigned int)sub_4EFC(v10, v11) )
          v6 = 0LL;
        fclose(v9);
        goto LABEL_10;
      }
      sub_1872C((__int64)v3, (__int64)"java/lang/RuntimeException", "could not adapt input stream");
    }
    v6 = 0LL;
LABEL_10:
    sub_4F88();
    return v6;
  }
  sub_4F44();
  return 0LL;
}
// 4DB0: variable 'v3' is possibly undefined
// 4E14: variable 'v11' is possibly undefined

//----- (0000000000004E54) ----------------------------------------------------
__int64 __fastcall sub_4E54(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // x1
  __int64 (__fastcall *v6)(__int64, __int64); // [xsp+8h] [xbp-18h]

  v6 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 1336LL);
  v4 = sub_18398(a3);
  return v6(a1, v4);
}

//----- (0000000000004E8C) ----------------------------------------------------
__int64 __fastcall sub_4E8C(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_183A0(a3);
}

//----- (0000000000004EA0) ----------------------------------------------------
__int64 __fastcall sub_4EA0(__int64 a1, __int64 a2, __int64 a3, int a4, unsigned int a5, __int64 a6, unsigned int a7)
{
  __int64 v11; // x4

  v11 = sub_183A8(a3) + a4;
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD, __int64))(*(_QWORD *)a1 + 1664LL))(
           a1,
           a6,
           a7,
           a5,
           v11);
}

//----- (0000000000004EF4) ----------------------------------------------------
void __fastcall sub_4EF4(__int64 a1, __int64 a2, void **a3)
{
  sub_1820C(a3);
}

//----- (0000000000004EFC) ----------------------------------------------------
__int64 __fastcall sub_4EFC(__int64 a1, unsigned __int64 a2)
{
  __int64 result; // x0
  char *v4; // x0

  result = 0LL;
  if ( a2 <= 0x13 )
  {
    if ( (_DWORD)a2 )
    {
      v4 = sub_181E0(a2);
      sub_1872C(a1, (__int64)"java/lang/RuntimeException", "superpack error: %s", v4);
      result = 0xFFFFFFFFLL;
    }
  }
  return result;
}

//----- (0000000000004F44) ----------------------------------------------------
__int64 sub_4F44()
{
  __int64 v0; // x19

  return sub_1872C(v0, (__int64)"java/lang/RuntimeException", "could not acquire file bytes");
}
// 4F58: variable 'v0' is possibly undefined

//----- (0000000000004F5C) ----------------------------------------------------
__int64 __usercall sub_4F5C@<X0>(__int64 a1@<X8>)
{
  __int64 v1; // x19

  return (*(__int64 (__fastcall **)(__int64))(a1 + 1824))(v1);
}
// 4F64: variable 'v1' is possibly undefined

//----- (0000000000004F68) ----------------------------------------------------
__int64 __fastcall sub_4F68(__int64 a1, __int64 a2, __int64 a3)
{
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a1 + 1352LL))(a1, a3, 0LL);
}

//----- (0000000000004F88) ----------------------------------------------------
__int64 sub_4F88()
{
  __int64 v0; // x19
  __int64 v1; // x20
  __int64 v2; // x21

  return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v0 + 1360LL))(v0, v1, v2);
}
// 4F88: variable 'v0' is possibly undefined
// 4F9C: variable 'v1' is possibly undefined
// 4F9C: variable 'v2' is possibly undefined

//----- (0000000000004FA0) ----------------------------------------------------
__int64 sub_4FA0()
{
  __int64 v0; // x19

  return v0;
}
// 4FA0: variable 'v0' is possibly undefined

//----- (0000000000004FAC) ----------------------------------------------------
__int64 sub_4FAC()
{
  __int64 v0; // x19

  v0 = sub_1810C(34912LL);
  sub_11920(v0, "native_driver", "so", 0LL, 4LL, (__int64)&unk_1B170);
  sub_118DC(v0);
  return v0;
}

//----- (0000000000004FF4) ----------------------------------------------------
__int64 __fastcall sub_4FF4(__int64 a1, void *dest)
{
  __int64 v2; // x8
  int v5; // w9
  unsigned int v6; // w8
  __int64 v7; // x8
  __int64 v8; // x8
  _BYTE *v9; // x1
  int v10; // w8
  __int64 v11; // x9
  int v12; // w25
  _BYTE *v13; // x1
  __int64 v14; // x8
  _DWORD *v15; // x1
  unsigned int v16; // w8
  _DWORD *v17; // x1
  unsigned int v18; // w8
  _BYTE *v19; // x1
  __int64 v20; // x8
  _DWORD *v21; // x1
  unsigned __int8 *v22; // x26
  __int64 i; // x25
  __int64 v24; // x8
  int v25; // w8
  int v26; // w8
  __int64 v27; // x8
  __int64 v28; // x8
  unsigned int v29; // w9
  unsigned int v30; // w8
  bool v31; // zf
  __int64 v32; // x8
  unsigned int *v33; // x20
  unsigned int desta; // [xsp+Ch] [xbp-44h] BYREF

  v2 = *(unsigned int *)(a1 + 36);
  v5 = v2 + 4;
  if ( (unsigned int)(v2 + 4) >= *(_DWORD *)(a1 + 40) )
  {
    sub_14CB0((__int64 **)a1, &desta, 4);
    v31 = desta == -1;
    *(_QWORD *)dest = desta;
    if ( !v31 )
      goto LABEL_5;
  }
  else
  {
    v6 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v2);
    desta = v6;
    *(_DWORD *)(a1 + 36) = v5;
    *(_QWORD *)dest = v6;
    if ( v6 != -1 )
      goto LABEL_5;
  }
  v7 = *(unsigned int *)(a1 + 36);
  if ( (unsigned int)(v7 + 8) >= *(_DWORD *)(a1 + 40) )
  {
    sub_14CB0((__int64 **)a1, dest, 8);
  }
  else
  {
    *(_QWORD *)dest = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v7);
    *(_DWORD *)(a1 + 36) += 8;
  }
LABEL_5:
  v8 = *(unsigned int *)(a1 + 36);
  v9 = (char *)dest + 16;
  if ( (unsigned int)(v8 + 1) >= *(_DWORD *)(a1 + 40) )
  {
    sub_14CB0((__int64 **)a1, v9, 1);
  }
  else
  {
    *v9 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v8);
    ++*(_DWORD *)(a1 + 36);
  }
  v10 = 0;
  do
  {
    while ( 1 )
    {
      v11 = *(unsigned int *)(a1 + 36);
      v12 = v10;
      v13 = (char *)dest + (unsigned __int8)v10 + 17;
      if ( (unsigned int)(v11 + 1) >= *(_DWORD *)(a1 + 40) )
        break;
      *v13 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v11);
      ++*(_DWORD *)(a1 + 36);
      ++v10;
      if ( !*((_BYTE *)dest + (unsigned __int8)(v12 + 1) + 16) )
        goto LABEL_12;
    }
    sub_14CB0((__int64 **)a1, v13, 1);
    v10 = v12 + 1;
  }
  while ( *((_BYTE *)dest + (unsigned __int8)(v12 + 1) + 16) );
LABEL_12:
  v14 = *(unsigned int *)(a1 + 36);
  v15 = (char *)dest + 24;
  if ( (unsigned int)(v14 + 4) >= *(_DWORD *)(a1 + 40) )
  {
    sub_14CB0((__int64 **)a1, v15, 4);
    v16 = *(_DWORD *)(a1 + 36);
  }
  else
  {
    *v15 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v14);
    v16 = *(_DWORD *)(a1 + 36) + 4;
    *(_DWORD *)(a1 + 36) = v16;
  }
  v17 = (char *)dest + 28;
  if ( v16 + 4 >= *(_DWORD *)(a1 + 40) )
  {
    sub_14CB0((__int64 **)a1, v17, 4);
    v18 = *(_DWORD *)(a1 + 36);
  }
  else
  {
    *v17 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v16);
    v18 = *(_DWORD *)(a1 + 36) + 4;
    *(_DWORD *)(a1 + 36) = v18;
  }
  v19 = (char *)dest + 32;
  if ( v18 + 1 >= *(_DWORD *)(a1 + 40) )
  {
    sub_14CB0((__int64 **)a1, v19, 1);
    if ( !(_BYTE)v12 )
      goto LABEL_47;
  }
  else
  {
    *v19 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v18);
    ++*(_DWORD *)(a1 + 36);
    if ( !(_BYTE)v12 )
      goto LABEL_47;
  }
  v20 = *(unsigned int *)(a1 + 36);
  v21 = (char *)dest + 36;
  if ( (unsigned int)(v20 + 4) >= *(_DWORD *)(a1 + 40) )
  {
    sub_14CB0((__int64 **)a1, v21, 4);
    if ( (unsigned __int8)v12 >= 2u )
      goto LABEL_20;
  }
  else
  {
    *v21 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v20);
    *(_DWORD *)(a1 + 36) += 4;
    if ( (unsigned __int8)v12 >= 2u )
    {
LABEL_20:
      v22 = (unsigned __int8 *)dest + 18;
      for ( i = (unsigned __int8)v12 - 1LL; i; --i )
      {
        v26 = *v22;
        switch ( v26 )
        {
          case 'R':
            v24 = *(unsigned int *)(a1 + 36);
            if ( (unsigned int)(v24 + 1) >= *(_DWORD *)(a1 + 40) )
            {
              sub_14CB0((__int64 **)a1, (char *)dest + 56, 1);
              goto LABEL_25;
            }
            *((_BYTE *)dest + 56) = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v24);
            break;
          case 'P':
            v28 = *(unsigned int *)(a1 + 36);
            if ( (unsigned int)(v28 + 1) >= *(_DWORD *)(a1 + 40) )
            {
              sub_14CB0((__int64 **)a1, (char *)dest + 41, 1);
              v30 = *(_DWORD *)(a1 + 36);
              if ( v30 + 8 >= *(_DWORD *)(a1 + 40) )
              {
LABEL_37:
                sub_14CB0((__int64 **)a1, (char *)dest + 48, 8);
                goto LABEL_25;
              }
            }
            else
            {
              *((_BYTE *)dest + 41) = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v28);
              v29 = *(_DWORD *)(a1 + 40);
              v30 = *(_DWORD *)(a1 + 36) + 1;
              *(_DWORD *)(a1 + 36) = v30;
              if ( v30 + 8 >= v29 )
                goto LABEL_37;
            }
            *((_QWORD *)dest + 6) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v30);
            v25 = *(_DWORD *)(a1 + 36) + 8;
            goto LABEL_24;
          case 'L':
            v27 = *(unsigned int *)(a1 + 36);
            if ( (unsigned int)(v27 + 1) >= *(_DWORD *)(a1 + 40) )
            {
              sub_14CB0((__int64 **)a1, (char *)dest + 40, 1);
              goto LABEL_25;
            }
            *((_BYTE *)dest + 40) = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v27);
            break;
          default:
            goto LABEL_25;
        }
        v25 = *(_DWORD *)(a1 + 36) + 1;
LABEL_24:
        *(_DWORD *)(a1 + 36) = v25;
LABEL_25:
        ++v22;
      }
    }
  }
LABEL_47:
  v32 = *(unsigned int *)(a1 + 36);
  v33 = (unsigned int *)((char *)dest + 72);
  if ( (unsigned int)(v32 + 4) >= *(_DWORD *)(a1 + 40) )
  {
    sub_14CB0((__int64 **)a1, v33, 4);
  }
  else
  {
    *v33 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v32);
    *(_DWORD *)(a1 + 36) += 4;
  }
  return *v33;
}

//----- (000000000000542C) ----------------------------------------------------
__int64 __fastcall sub_542C(unsigned int *a1, __int64 **a2, __int64 **a3, __int64 *a4, __int64 a5, unsigned int a6, _QWORD *a7, int a8)
{
  unsigned int v9; // w8
  bool v17; // cf
  _BYTE *v18; // x1
  __int64 v19; // x8
  _BYTE *v20; // x24
  char v21; // w9
  __int64 v22; // x8
  unsigned int v23; // w1
  __int64 v24; // x8
  __int64 v25; // x8
  _BYTE *v26; // x1
  __int64 v27; // x8
  int v28; // w0
  __int64 v29; // x1
  unsigned __int8 v30; // w0
  char v31; // w9
  int v32; // w0
  signed int v33; // w9
  unsigned int v34; // w9
  signed int v35; // w11
  __int64 v36; // x8
  int v37; // w9
  int v38; // w10
  __int64 result; // x0
  __int64 v40; // x8

  v9 = a6 - *((_DWORD *)a4 + 2);
  v17 = (unsigned __int64)*a4 >= 0xFFFFFFFF;
  *((_DWORD *)a4 + 2) = v9 + 5;
  if ( v17 )
    *((_DWORD *)a4 + 2) = v9 + 13;
  *a4 = 4LL;
  v18 = a4 + 2;
  v19 = a1[9];
  if ( (int)v19 + 1 < a1[10] )
  {
    *v18 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v19);
    ++a1[9];
    v20 = (char *)a4 + 17;
    if ( (a4[2] & 4) == 0 )
      goto LABEL_6;
LABEL_9:
    v22 = a1[9];
    if ( (int)v22 + 1 >= a1[10] )
    {
      sub_14CB0((__int64 **)a1, v20, 1);
      v21 = *((_BYTE *)a4 + 16);
      *((_DWORD *)a4 + 9) = 0;
      if ( (v21 & 2) != 0 )
        goto LABEL_14;
    }
    else
    {
      *v20 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v22);
      ++a1[9];
      v21 = *((_BYTE *)a4 + 16);
      *((_DWORD *)a4 + 9) = 0;
      if ( (v21 & 2) != 0 )
        goto LABEL_14;
    }
LABEL_11:
    v23 = 0;
    v24 = *a4;
    *a4 = *a4;
    if ( (v21 & 1) == 0 )
      goto LABEL_18;
    goto LABEL_17;
  }
  sub_14CB0((__int64 **)a1, v18, 1);
  v20 = (char *)a4 + 17;
  if ( (a4[2] & 4) != 0 )
    goto LABEL_9;
LABEL_6:
  *v20 = 0;
  v21 = *((_BYTE *)a4 + 16);
  *((_DWORD *)a4 + 9) = 0;
  if ( (v21 & 2) == 0 )
    goto LABEL_11;
LABEL_14:
  v25 = a1[9];
  v26 = a4 + 5;
  if ( (int)v25 + 1 >= a1[10] )
  {
    sub_14CB0((__int64 **)a1, v26, 1);
  }
  else
  {
    *v26 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v25);
    ++a1[9];
  }
  v27 = *a7 + (int)sub_150D0(a2);
  *a7 = v27;
  v28 = *((unsigned __int8 *)a4 + 40);
  v29 = v27 - a6;
  a4[6] = v29;
  v30 = sub_C56C(v28, v29, a8);
  v31 = *((_BYTE *)a4 + 16);
  v23 = v30;
  *((_DWORD *)a4 + 9) = v30;
  v24 = *a4 + v30;
  *a4 = v24;
  if ( (v31 & 1) == 0 )
    goto LABEL_18;
LABEL_17:
  v24 = *a4 + (unsigned __int8)sub_C56C(1, v23, a8);
  *a4 = v24;
LABEL_18:
  v32 = (unsigned __int8)*v20;
  v33 = *(_DWORD *)(a5 + 4);
  if ( (v32 & 0xF0) == 16 )
  {
    v34 = v33 - a6;
    v35 = v34 - 8;
    v33 = v34 - 12;
    if ( v24 != 0xFFFFFFFFLL )
      v33 = v35;
  }
  a4[3] = v33;
  v36 = *a4 + (unsigned __int8)sub_C56C(v32, v33, a8);
  *a4 = v36;
  v38 = *(_DWORD *)(a5 + 4);
  v37 = *(_DWORD *)(a5 + 8);
  *a4 = v36 + 4;
  *((_DWORD *)a4 + 8) = v37 - v38;
  result = sub_14FB8(a3);
  v40 = *a4;
  *((_DWORD *)a4 + 16) = result;
  *a4 = v40 + (unsigned int)result;
  return result;
}

//----- (0000000000005690) ----------------------------------------------------
__int64 __fastcall sub_5690(__int64 a1, __int64 *a2, __int64 a3, int a4)
{
  __int64 v4; // x8
  int v8; // w9
  int v9; // w8
  int v10; // w2
  __int64 v11; // x8
  __int64 v12; // x0
  int v13; // w2
  __int64 v14; // x8
  __int64 v15; // x0
  __int64 result; // x0
  int dest; // [xsp+8h] [xbp-38h] BYREF
  __int64 v18; // [xsp+10h] [xbp-30h] BYREF
  __int64 v19; // [xsp+18h] [xbp-28h] BYREF

  v4 = *(unsigned int *)(a1 + 36);
  v8 = v4 + 4;
  if ( (unsigned int)(v4 + 4) >= *(_DWORD *)(a1 + 40) )
  {
    sub_14CB0((__int64 **)a1, &dest, 4);
    v9 = dest;
  }
  else
  {
    v9 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v4);
    dest = v9;
    *(_DWORD *)(a1 + 36) = v8;
  }
  *(_DWORD *)*a2 = v9;
  *a2 += 4LL;
  v10 = BYTE1(dest);
  if ( BYTE1(dest) != 255 )
  {
    v11 = *(unsigned int *)(a1 + 36);
    if ( (unsigned int)(v11 + 8) >= *(_DWORD *)(a1 + 40) )
    {
      sub_14CB0((__int64 **)a1, &v18, 8);
      v10 = BYTE1(dest);
      v12 = v18;
    }
    else
    {
      v12 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v11);
      v18 = v12;
      *(_DWORD *)(a1 + 36) = v11 + 8;
    }
    sub_C624(v12, a2, v10, a4);
  }
  v13 = BYTE2(dest);
  if ( BYTE2(dest) == 255
    || ((v14 = *(unsigned int *)(a1 + 36), (unsigned int)(v14 + 8) >= *(_DWORD *)(a1 + 40)) ? (sub_14CB0(
                                                                                                 (__int64 **)a1,
                                                                                                 &v19,
                                                                                                 8),
                                                                                               v13 = BYTE2(dest),
                                                                                               v15 = v19) : (v15 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v14), v19 = v15, *(_DWORD *)(a1 + 36) = v14 + 8),
        (sub_C624(v15, a2, v13, a4), BYTE2(dest) == 255) || HIBYTE(dest) == 255) )
  {
    result = 0LL;
  }
  else
  {
    result = nullsub_2(v19);
  }
  return result;
}
// C620: using guessed type __int64 __fastcall nullsub_2(_QWORD);

//----- (00000000000057F4) ----------------------------------------------------
void __fastcall sub_57F4(__int64 a1, char *a2, int a3, void *a4, int a5, __int64 a6)
{
  _QWORD *v6; // x8
  __int64 **v8; // x23
  __int64 **v9; // x26
  unsigned int *v13; // x27
  __int64 v14; // x20
  char *v16; // x21
  __int64 v17; // x2
  unsigned int v18; // w9
  __int64 v19; // x10
  unsigned int v20; // w8
  unsigned int v21; // w10
  _DWORD *v22; // x29
  char *v23; // x19
  int v24; // w25
  int v25; // w0
  size_t v26; // w28
  __int64 *v27; // x29
  unsigned int v28; // w29
  __int64 v29; // x8
  int v30; // w23
  char *v31; // x22
  __int64 v32; // x19
  char *v33; // x20
  unsigned int *v34; // x21
  __int64 **v35; // x27
  void *v36; // x26
  int v37; // w24
  int v38; // w0
  char *v39; // x8
  __int64 **v40; // x29
  __int64 v41; // x9
  size_t v42; // w19
  char *v43; // x8
  size_t v44; // w22
  __int64 v45; // x9
  int v46; // [xsp+8h] [xbp-128h]
  __int64 **v47; // [xsp+10h] [xbp-120h]
  __int64 v48; // [xsp+18h] [xbp-118h]
  char *base; // [xsp+20h] [xbp-110h]
  size_t v50; // [xsp+28h] [xbp-108h]
  __int64 **v51; // [xsp+30h] [xbp-100h]
  __int64 v52; // [xsp+38h] [xbp-F8h] BYREF
  int v53; // [xsp+40h] [xbp-F0h]
  char v54; // [xsp+49h] [xbp-E7h]
  __int64 v55; // [xsp+50h] [xbp-E0h]
  int v56; // [xsp+88h] [xbp-A8h] BYREF
  unsigned int v57; // [xsp+8Ch] [xbp-A4h] BYREF
  void *dest; // [xsp+90h] [xbp-A0h] BYREF
  char *v59; // [xsp+98h] [xbp-98h] BYREF
  _QWORD v60[2]; // [xsp+A0h] [xbp-90h] BYREF
  _QWORD v61[2]; // [xsp+B0h] [xbp-80h] BYREF
  __int64 **v62; // [xsp+C0h] [xbp-70h] BYREF
  __int64 **v63; // [xsp+C8h] [xbp-68h] BYREF

  v6 = *(_QWORD **)(a1 + 16);
  v8 = (__int64 **)v6[2074];
  v9 = (__int64 **)v6[2076];
  v62 = v9;
  v63 = v8;
  v13 = (unsigned int *)v6[2077];
  v14 = v6[2079];
  v51 = (__int64 **)v6[2078];
  sub_118BC(4LL, (__int64)v61);
  sub_118BC(4LL, (__int64)v60);
  v48 = *(_QWORD *)(a6 + 64) - *(_QWORD *)(a6 + 80);
  v16 = a2;
  v59 = &a2[v48];
  sub_5690(v14, (__int64 *)&v59, v17, a5);
  dest = a2;
  v19 = *(unsigned int *)(v14 + 36);
  v18 = *(_DWORD *)(v14 + 40);
  base = v59;
  v20 = v19 + 4;
  if ( (int)v19 + 4 >= v18 )
  {
    sub_14CB0((__int64 **)v14, &v57, 4);
    v20 = *(_DWORD *)(v14 + 36);
    v21 = v20 + 4;
    if ( v20 + 4 < *(_DWORD *)(v14 + 40) )
      goto LABEL_3;
  }
  else
  {
    v57 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v14 + 8LL) + v19);
    *(_DWORD *)(v14 + 36) = v20;
    v21 = v19 + 8;
    if ( v20 + 4 < v18 )
    {
LABEL_3:
      v56 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v14 + 8LL) + v20);
      *(_DWORD *)(v14 + 36) = v21;
      goto LABEL_4;
    }
  }
  sub_14CB0((__int64 **)v14, &v56, 4);
LABEL_4:
  v22 = dest;
  v23 = &a2[a3];
  if ( (char *)dest + v57 >= v23 )
  {
    v42 = 0;
    if ( !v57 )
      goto LABEL_30;
    goto LABEL_27;
  }
  v24 = 0;
  v50 = 0;
  v46 = 8 - v48;
  v47 = v8;
  do
  {
    v25 = sub_150D0(v8);
    if ( v25 == 0x7FFFFFFF )
    {
      v53 = 0;
      v26 = sub_4FF4((__int64)v8, &v52);
      v27 = (__int64 *)&v63;
    }
    else
    {
      v28 = (_DWORD)v22 - (_DWORD)v16;
      v53 = sub_118C8(v61, v25);
      v26 = sub_542C(v13, v51, v9, &v52, (__int64)a4 + 12 * v24, v28, v60, a5);
      if ( v24 == v56 )
      {
        v29 = *(unsigned int *)(v14 + 36);
        if ( (unsigned int)(v29 + 4) >= *(_DWORD *)(v14 + 40) )
        {
          sub_14CB0((__int64 **)v14, &v56, 4);
        }
        else
        {
          v56 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v14 + 8LL) + v29);
          *(_DWORD *)(v14 + 36) = v29 + 4;
        }
      }
      else
      {
        v30 = a5;
        v31 = v23;
        v32 = v14;
        v33 = v16;
        v34 = v13;
        v35 = v9;
        v36 = a4;
        v37 = v54 & 0xF0;
        v38 = nullsub_2(v55);
        if ( v37 == 16 )
        {
          if ( v52 == 0xFFFFFFFFLL )
            v38 += v46 + v28 + 4;
          else
            v38 += v46 + v28;
        }
        a4 = v36;
        v9 = v35;
        v39 = &base[8 * v50];
        *(_DWORD *)v39 = v38;
        *((_DWORD *)v39 + 1) = v28 - v48;
        v13 = v34;
        v16 = v33;
        v14 = v32;
        v23 = v31;
        a5 = v30;
        v8 = v47;
        ++v50;
      }
      ++v24;
      v27 = (__int64 *)&v62;
    }
    sub_CD84((__int64)&v52, (__int64 *)&dest, a5);
    v40 = (__int64 **)*v27;
    if ( v26 && (v41 = *((unsigned int *)v40 + 9), (unsigned int)v41 + v26 < *((_DWORD *)v40 + 10)) )
    {
      memcpy(dest, (const void *)((*v40)[1] + v41), v26);
      *((_DWORD *)v40 + 9) += v26;
    }
    else
    {
      sub_14CB0(v40, dest, v26);
    }
    dest = (char *)dest + v26;
    v22 = dest;
  }
  while ( (char *)dest + v57 < v23 );
  v42 = v50;
  if ( v57 )
  {
LABEL_27:
    *v22 = 0;
    v43 = (char *)dest + 4;
    v44 = v57 - 4;
    dest = (char *)dest + 4;
    if ( v57 == 4 || (v45 = *(unsigned int *)(v14 + 36), (unsigned int)v45 + v44 >= *(_DWORD *)(v14 + 40)) )
    {
      sub_14CB0((__int64 **)v14, v43, v44);
    }
    else
    {
      memcpy(v43, (const void *)(*(_QWORD *)(*(_QWORD *)v14 + 8LL) + v45), v44);
      *(_DWORD *)(v14 + 36) += v44;
    }
  }
LABEL_30:
  j__free(a4);
  qsort(base, v42, 8u, (__compar_fn_t)sub_CB94);
}
// 5884: variable 'v17' is possibly undefined
// C620: using guessed type __int64 __fastcall nullsub_2(_QWORD);

//----- (0000000000005BCC) ----------------------------------------------------
_DWORD *__fastcall sub_5BCC(__int64 **a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5, unsigned int a6, __int64 a7, unsigned int *a8)
{
  _DWORD *result; // x0
  size_t v16; // w26
  void *v17; // x22
  __int64 v18; // x8
  unsigned __int64 v19; // x24
  int v20; // w25
  unsigned int *v21; // x23
  __int64 v22; // x8
  int v23; // w9
  int v24; // w8
  _DWORD *v25; // x8
  __int64 v26; // x8
  int v27; // w9
  int v28; // w8
  int v29; // w0
  __int64 v30; // x1
  __int64 v31; // [xsp+0h] [xbp-70h] BYREF
  __int64 v32; // [xsp+10h] [xbp-60h] BYREF
  int v33; // [xsp+28h] [xbp-48h] BYREF
  char dest[4]; // [xsp+2Ch] [xbp-44h] BYREF

  sub_118BC(4LL, (__int64)&v32);
  result = (_DWORD *)sub_118BC(4LL, (__int64)&v31);
  v16 = a8[2];
  v17 = (void *)(a5 - a8[1] + *a8);
  if ( v16 )
  {
    v18 = *(unsigned int *)(a4 + 36);
    if ( (unsigned int)v18 + v16 >= *(_DWORD *)(a4 + 40) )
    {
      result = (_DWORD *)sub_14CB0((__int64 **)a4, v17, v16);
      v19 = a5 + a6;
      if ( v19 > a5 )
        goto LABEL_5;
      return result;
    }
    result = memcpy(v17, (const void *)(*(_QWORD *)(*(_QWORD *)a4 + 8LL) + v18), v16);
    *(_DWORD *)(a4 + 36) += v16;
  }
  v19 = a5 + a6;
  if ( v19 > a5 )
  {
LABEL_5:
    v20 = 0;
    v21 = (unsigned int *)(a5 + 4);
    do
    {
      result = (_DWORD *)sub_150D0(a1);
      v32 += (int)result;
      *(v21 - 1) = v20 + v32;
      v26 = *(unsigned int *)(a2 + 36);
      v27 = v26 + 1;
      if ( (unsigned int)(v26 + 1) >= *(_DWORD *)(a2 + 40) )
      {
        result = (_DWORD *)sub_14CB0((__int64 **)a2, dest, 1);
        v28 = (unsigned __int8)dest[0];
        if ( dest[0] == 2 )
        {
LABEL_16:
          v29 = sub_150D0((__int64 **)a2);
          v30 = (unsigned int)(v31 + v29);
          v31 += v29;
          *v21 = v31;
          result = (_DWORD *)sub_CB84((__int64)v21, v30);
          if ( (*result & 0x80000000) == 0 )
            *result = (_DWORD)v17 + *result - (_DWORD)result;
          goto LABEL_9;
        }
      }
      else
      {
        v28 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)a2 + 8LL) + v26);
        dest[0] = v28;
        *(_DWORD *)(a2 + 36) = v27;
        if ( v28 == 2 )
          goto LABEL_16;
      }
      if ( v28 == 1 )
      {
        v22 = *(unsigned int *)(a3 + 36);
        v23 = v22 + 4;
        if ( (unsigned int)(v22 + 4) >= *(_DWORD *)(a3 + 40) )
        {
          result = (_DWORD *)sub_14CB0((__int64 **)a3, &v33, 4);
          v24 = v33;
        }
        else
        {
          v24 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a3 + 8LL) + v22);
          v33 = v24;
          *(_DWORD *)(a3 + 36) = v23;
        }
        *v21 = v24 | 0x80000000;
      }
      else if ( !v28 )
      {
        *v21 = 1;
      }
LABEL_9:
      v25 = v21 + 1;
      v21 += 2;
      v20 -= 8;
    }
    while ( (unsigned __int64)v25 < v19 );
  }
  return result;
}

//----- (0000000000005DC0) ----------------------------------------------------
__int64 __fastcall sub_5DC0(__int64 a1, __int64 a2, __int64 **a3, unsigned __int64 a4, unsigned int a5)
{
  __int64 result; // x0
  unsigned __int64 v11; // x23
  _QWORD *v12; // x22
  __int64 v13; // x8
  __int64 v14; // x8
  _QWORD *v15; // x8
  _QWORD *v16; // x8
  __int64 v17; // [xsp+0h] [xbp-40h] BYREF

  result = sub_118BC(4LL, (__int64)&v17);
  v11 = a4 + a5;
  if ( v11 > a4 )
  {
    v12 = (_QWORD *)(a4 + 16);
    do
    {
      while ( 1 )
      {
        result = sub_150D0(a3);
        v17 += (int)result;
        *(v12 - 2) = v17;
        v13 = *(unsigned int *)(a2 + 36);
        if ( (unsigned int)(v13 + 8) < *(_DWORD *)(a2 + 40) )
          break;
        result = sub_14CB0((__int64 **)a2, v12 - 1, 8);
        v14 = *(unsigned int *)(a1 + 36);
        if ( (unsigned int)(v14 + 8) < *(_DWORD *)(a1 + 40) )
          goto LABEL_5;
LABEL_8:
        result = sub_14CB0((__int64 **)a1, v12, 8);
        v16 = v12 + 1;
        v12 += 3;
        if ( v11 <= (unsigned __int64)v16 )
          return result;
      }
      *(v12 - 1) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a2 + 8LL) + v13);
      *(_DWORD *)(a2 + 36) += 8;
      v14 = *(unsigned int *)(a1 + 36);
      if ( (unsigned int)(v14 + 8) >= *(_DWORD *)(a1 + 40) )
        goto LABEL_8;
LABEL_5:
      *v12 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v14);
      *(_DWORD *)(a1 + 36) += 8;
      v15 = v12 + 1;
      v12 += 3;
    }
    while ( v11 > (unsigned __int64)v15 );
  }
  return result;
}

//----- (0000000000005ED8) ----------------------------------------------------
__int64 __fastcall sub_5ED8(__int64 a1, __int64 a2, __int64 a3, void *dest)
{
  __int64 v4; // x8
  __int64 v8; // x8
  _BYTE *v9; // x1
  __int64 v10; // x8
  _BYTE *v11; // x21
  int v12; // w21
  __int64 result; // x0

  v4 = *(unsigned int *)(a2 + 36);
  if ( (unsigned int)(v4 + 1) >= *(_DWORD *)(a2 + 40) )
  {
    sub_14CB0((__int64 **)a2, dest, 1);
  }
  else
  {
    *(_BYTE *)dest = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a2 + 8LL) + v4);
    ++*(_DWORD *)(a2 + 36);
  }
  v8 = *(unsigned int *)(a1 + 36);
  v9 = (char *)dest + 16;
  if ( (unsigned int)(v8 + 1) >= *(_DWORD *)(a1 + 40) )
  {
    sub_14CB0((__int64 **)a1, v9, 1);
  }
  else
  {
    *v9 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v8);
    ++*(_DWORD *)(a1 + 36);
  }
  v10 = *(unsigned int *)(a3 + 36);
  v11 = (char *)dest + 1;
  if ( (unsigned int)(v10 + 1) >= *(_DWORD *)(a3 + 40) )
  {
    sub_14CB0((__int64 **)a3, (char *)dest + 1, 1);
    if ( (unsigned __int8)*v11 != 255 )
      goto LABEL_7;
LABEL_11:
    v12 = 0;
    goto LABEL_12;
  }
  *v11 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a3 + 8LL) + v10);
  ++*(_DWORD *)(a3 + 36);
  if ( (unsigned __int8)*v11 == 255 )
    goto LABEL_11;
LABEL_7:
  v12 = sub_14FB8((__int64 **)a3);
LABEL_12:
  result = sub_14FB8((__int64 **)a3);
  *((_DWORD *)dest + 5) = result;
  *((_DWORD *)dest + 1) = result + v12;
  *((_QWORD *)dest + 1) = 0LL;
  return result;
}

//----- (0000000000005FFC) ----------------------------------------------------
__int64 __fastcall sub_5FFC(__int64 **a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, int *a5, char a6, int a7, int a8)
{
  int v8; // w8
  int v15; // w25
  int v16; // w8
  unsigned int v17; // w10
  unsigned int v18; // w26
  __int64 *v19; // x0
  __int64 *v20; // x10
  unsigned int v21; // w8
  _QWORD *v22; // x0
  __int64 *v23; // x9
  int v24; // w8
  __int64 result; // x0
  int v26; // w8
  bool v27; // cc
  int v28; // w8
  int v29; // w10
  int v30; // w8
  __int64 v31; // x8
  int v32; // w9
  int v33; // w8
  char dest[4]; // [xsp+Ch] [xbp-54h] BYREF

  v8 = 4 * (a7 == 1);
  if ( !a7 )
    v8 = 2;
  if ( v8 )
    v15 = v8;
  else
    v15 = 1;
  if ( a8 )
  {
    v16 = *((_DWORD *)a1 + 9);
    v17 = *((_DWORD *)a1 + 10);
    v18 = (v16 + 3) & 0xFFFFFFFC;
    *((_DWORD *)a1 + 4) -= v18 - v16;
    if ( v18 >= v17 )
    {
      v19 = *a1;
      v18 -= v17;
      v20 = (__int64 *)**a1;
      *v19 = 0x100000LL;
      *a1 = v20;
      sub_14954(v19);
      v21 = *((_DWORD *)a1 + 10);
      for ( *((_DWORD *)a1 + 9) = 0; v18 >= v21; *((_DWORD *)a1 + 9) = 0 )
      {
        v22 = *a1;
        v18 -= v21;
        v23 = (__int64 *)**a1;
        *v22 = 0x100000LL;
        *a1 = v23;
        sub_14954(v22);
        v21 = *((_DWORD *)a1 + 10);
      }
    }
    *((_DWORD *)a1 + 9) = v18;
  }
  a2[1] = (sub_14FB8(a1) + 1) * v15;
  v24 = *a4 + sub_150D0(a1) * v15 + *a3;
  *a2 = v24;
  *a4 = v24;
  *a3 = a2[1];
  result = sub_150D0(a1);
  v26 = result * v15;
  if ( (_DWORD)result * v15 )
  {
    v27 = v26 <= 0;
    v28 = v26 - v15;
    if ( v27 )
      v29 = 0;
    else
      v29 = v15;
    v30 = v28 - v29 + *a5;
    a2[2] = v30;
    *a5 = v30;
    if ( a6 )
      goto LABEL_16;
LABEL_19:
    a2[3] = 0;
    return result;
  }
  a2[2] = 0;
  if ( !a6 )
    goto LABEL_19;
LABEL_16:
  v31 = *((unsigned int *)a1 + 9);
  v32 = v31 + 1;
  if ( (unsigned int)(v31 + 1) >= *((_DWORD *)a1 + 10) )
  {
    result = sub_14CB0(a1, dest, 1);
    a2[3] = (unsigned __int8)dest[0];
  }
  else
  {
    v33 = *(unsigned __int8 *)((*a1)[1] + v31);
    dest[0] = v33;
    *((_DWORD *)a1 + 9) = v32;
    a2[3] = v33;
  }
  return result;
}

//----- (00000000000061BC) ----------------------------------------------------
__int64 __fastcall sub_61BC(__int64 result, __int64 a2, __int64 a3, __int64 a4, unsigned int *a5, void *a6, unsigned int a7, int a8, int a9)
{
  unsigned int v9; // w9
  __int64 v10; // x10
  unsigned int v14; // w8
  __int64 v19; // x24
  unsigned int v20; // w10
  unsigned __int64 v21; // x28
  __int64 v22; // x8
  char *v23; // x27
  char *v24; // x29
  unsigned __int64 v25; // x26
  unsigned __int64 v26; // x9
  bool v27; // zf
  int v28; // w29
  unsigned int v29; // w9
  __int64 v30; // x10
  unsigned int v31; // w8
  unsigned int v32; // w10
  char *v33; // x0
  bool v34; // nf
  int v35; // w0
  unsigned __int8 v36; // w0
  __int64 v37; // x26
  int v38; // w9
  __int64 v39; // x27
  unsigned int v40; // w0
  char *v41; // x26
  __int64 v42; // x8
  unsigned int v43; // w9
  int v44; // w8
  char v45; // w9
  __int64 v46; // x8
  __int64 v47; // x10
  size_t v48; // w2
  unsigned __int64 v49; // [xsp+10h] [xbp-B0h]
  int dest; // [xsp+18h] [xbp-A8h] BYREF
  int v51; // [xsp+1Ch] [xbp-A4h] BYREF
  unsigned int v52; // [xsp+24h] [xbp-9Ch]
  __int64 v53; // [xsp+28h] [xbp-98h] BYREF
  int v54; // [xsp+30h] [xbp-90h] BYREF
  char v55[4]; // [xsp+34h] [xbp-8Ch] BYREF
  char v56; // [xsp+38h] [xbp-88h] BYREF
  unsigned __int8 v57; // [xsp+39h] [xbp-87h]
  __int64 v58; // [xsp+40h] [xbp-80h]
  unsigned __int8 v59; // [xsp+48h] [xbp-78h]
  unsigned int v60; // [xsp+4Ch] [xbp-74h]
  void *s; // [xsp+50h] [xbp-70h] BYREF
  char v62[4]; // [xsp+58h] [xbp-68h] BYREF
  char v63[4]; // [xsp+5Ch] [xbp-64h] BYREF

  v10 = a5[9];
  v9 = a5[10];
  v14 = v10 + 1;
  v19 = result;
  if ( (int)v10 + 1 < v9 )
  {
    v63[0] = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a5 + 8LL) + v10);
    a5[9] = v14;
    v20 = v10 + 2;
    if ( v14 + 1 < v9 )
      goto LABEL_3;
LABEL_61:
    result = sub_14CB0((__int64 **)a5, v62, 1);
    v21 = (unsigned __int64)a6 + a7;
    s = a6;
    if ( v21 > (unsigned __int64)a6 )
      goto LABEL_4;
    return result;
  }
  result = sub_14CB0((__int64 **)a5, v63, 1);
  v14 = a5[9];
  v20 = v14 + 1;
  if ( v14 + 1 >= a5[10] )
    goto LABEL_61;
LABEL_3:
  v62[0] = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a5 + 8LL) + v14);
  a5[9] = v20;
  v21 = (unsigned __int64)a6 + a7;
  s = a6;
  if ( v21 > (unsigned __int64)a6 )
  {
LABEL_4:
    v49 = v21;
    do
    {
      sub_5ED8(v19, a4, (__int64)a5, &v56);
      sub_C2A0(&s, (__int64)&v56);
      v22 = a5[9];
      if ( (int)v22 + 1 >= a5[10] )
      {
        sub_14CB0((__int64 **)a5, v55, 1);
      }
      else
      {
        v55[0] = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a5 + 8LL) + v22);
        a5[9] = v22 + 1;
      }
      v23 = (char *)s;
      v54 = 0;
      v53 = 0LL;
      v24 = (char *)s + v60;
      if ( s >= v24 )
      {
        v28 = -1;
LABEL_37:
        v35 = v57;
        if ( v57 != 255 )
          goto LABEL_38;
      }
      else
      {
        v25 = 0LL;
        do
        {
          sub_5FFC((__int64 **)a5, &dest, &v54, (_DWORD *)&v53 + 1, (int *)&v53, v55[0], a8, a9);
          sub_C3F8((__int64 *)&s, v59, a8, (unsigned int *)&dest);
          v23 = (char *)s;
          v26 = (unsigned __int64)&v24[v52 - 1];
          if ( v26 <= v25 )
            v27 = v25 == 0;
          else
            v27 = 1;
          if ( !v27 )
            v26 = v25;
          if ( v52 )
            v25 = v26;
        }
        while ( s < v24 );
        v28 = -1;
        if ( v25 && (unsigned __int64)s <= v25 )
        {
          v21 = v49;
          v28 = -1;
          while ( 1 )
          {
            v30 = *(unsigned int *)(a3 + 36);
            v29 = *(_DWORD *)(a3 + 40);
            v31 = v30 + 4;
            if ( (int)v30 + 4 >= v29 )
            {
              sub_14CB0((__int64 **)a3, &dest, 4);
              v31 = *(_DWORD *)(a3 + 36);
              v32 = v31 + 4;
              if ( v31 + 4 >= *(_DWORD *)(a3 + 40) )
              {
LABEL_35:
                sub_14CB0((__int64 **)a3, &v51, 4);
                goto LABEL_23;
              }
            }
            else
            {
              dest = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a3 + 8LL) + v30);
              *(_DWORD *)(a3 + 36) = v31;
              v32 = v30 + 8;
              if ( v31 + 4 >= v29 )
                goto LABEL_35;
            }
            v51 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a3 + 8LL) + v31);
            *(_DWORD *)(a3 + 36) = v32;
LABEL_23:
            sub_C49C((_BYTE **)&s, &dest);
            v33 = sub_C204((unsigned __int64)v23);
            v23 = (char *)s;
            if ( (unsigned __int64)v33 > v25 )
              v25 = (unsigned __int64)v33;
            if ( v28 < ~dest )
              v34 = dest < 0;
            else
              v34 = 0;
            if ( v34 )
              v28 = ~dest;
            if ( !v25 || (unsigned __int64)s > v25 )
              goto LABEL_37;
          }
        }
        v21 = v49;
        v35 = v57;
        if ( v57 != 255 )
        {
LABEL_38:
          v36 = sub_C50C(v35, 0LL, a8);
          v37 = (v58 - (__int64)s) / v36;
          v38 = v58 - v37 * v36;
          v39 = (unsigned int)(v38 - (_DWORD)s);
          memset(s, 0, v38 - (_DWORD)s);
          v23 = (char *)s + v39;
          s = v23;
          if ( (_DWORD)v37 )
          {
            do
            {
              v40 = sub_14FB8((__int64 **)a2);
              sub_C624(v40, (__int64 *)&s, v57, a8);
              LODWORD(v37) = v37 - 1;
            }
            while ( (_DWORD)v37 );
            v23 = (char *)s;
          }
          goto LABEL_41;
        }
      }
LABEL_41:
      if ( v28 != -1 )
      {
        v41 = &v23[v28];
LABEL_43:
        if ( v23 <= v41 )
        {
          while ( 1 )
          {
            v42 = a5[9];
            v43 = v42 + 4;
            if ( (int)v42 + 4 >= a5[10] )
            {
              sub_14CB0((__int64 **)a5, &dest, 4);
              v44 = dest;
              v23 = (char *)s;
              if ( (unsigned int)(dest + 64) >= 0x80 )
              {
                do
                {
LABEL_48:
                  v45 = v44 | 0x80;
                  v44 >>= 7;
                  *v23++ = v45;
                }
                while ( (unsigned int)(v44 + 64) > 0x7F );
                goto LABEL_45;
              }
            }
            else
            {
              v44 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a5 + 8LL) + v42);
              dest = v44;
              a5[9] = v43;
              if ( (unsigned int)(v44 + 64) >= 0x80 )
                goto LABEL_48;
            }
LABEL_45:
            *v23++ = v44 & 0x7F;
            s = v23;
            if ( !dest )
              goto LABEL_43;
          }
        }
      }
      v46 = *(unsigned int *)(a2 + 36);
      if ( (unsigned int)(v46 + 1) >= *(_DWORD *)(a2 + 40) )
      {
        sub_14CB0((__int64 **)a2, &dest, 1);
        v23 = (char *)s;
        v48 = (unsigned __int8)dest;
      }
      else
      {
        v47 = *(_QWORD *)(*(_QWORD *)a2 + 8LL);
        v48 = *(unsigned __int8 *)(v47 + v46);
        LOBYTE(dest) = *(_BYTE *)(v47 + v46);
        *(_DWORD *)(a2 + 36) = v46 + 1;
      }
      result = (__int64)memset(v23, 0, v48);
      s = (char *)s + (unsigned __int8)dest;
    }
    while ( (unsigned __int64)s < v21 );
  }
  return result;
}

//----- (0000000000006624) ----------------------------------------------------
unsigned __int64 __fastcall sub_6624(unsigned int *a1, void *dest, size_t a3, __int64 a4, __int64 a5, unsigned __int8 a6)
{
  __int64 v6; // x8
  __int64 v7; // x24
  __int64 v8; // x26
  __int64 v9; // x25
  unsigned int v10; // w9
  int v16; // w8
  __int64 v17; // x8
  unsigned int v18; // w23
  char *v19; // x19
  unsigned int v20; // w22
  unsigned __int64 result; // x0
  int v22; // w11
  char *v23; // x10
  signed int v24; // w15
  __int64 v26; // x16
  unsigned __int8 v27; // w17
  unsigned __int8 *v28; // x16
  __int64 v29; // x0
  int v30; // t1
  char *v31; // x16
  int v32; // w17
  int v33; // w16
  __int64 v34; // x8
  unsigned int v35; // [xsp+8h] [xbp-48h] BYREF
  char desta[4]; // [xsp+Ch] [xbp-44h] BYREF

  v6 = a1[9];
  v7 = *(_QWORD *)(a5 + 48);
  v8 = *(_QWORD *)(a5 + 16);
  v9 = *(_QWORD *)(a5 + 32);
  v10 = v6 + 1;
  if ( (int)v6 + 1 < a1[10] )
  {
    v16 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v6);
    desta[0] = v16;
    a1[9] = v10;
    if ( v16 )
      goto LABEL_3;
LABEL_21:
    if ( !a3 )
      return sub_14CB0((__int64 **)a1, dest, a3);
    v34 = a1[9];
    if ( (unsigned int)v34 + a3 >= a1[10] )
      return sub_14CB0((__int64 **)a1, dest, a3);
    result = (unsigned __int64)memcpy(dest, (const void *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v34), a3);
    a1[9] += a3;
    return result;
  }
  sub_14CB0((__int64 **)a1, desta, 1);
  if ( !desta[0] )
    goto LABEL_21;
LABEL_3:
  v17 = a1[9];
  if ( (int)v17 + 4 >= a1[10] )
  {
    sub_14CB0((__int64 **)a1, &v35, 4);
    v18 = v35;
  }
  else
  {
    v18 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v17);
    v35 = v18;
    a1[9] = v17 + 4;
  }
  v19 = (char *)dest + 8;
  v20 = *(_DWORD *)(a5 + 24) / (unsigned int)a6;
  *(_DWORD *)dest = v18;
  *((_DWORD *)dest + 1) = v20;
  result = (unsigned __int64)memset((char *)dest + 8, 0, 4 * (v18 + v20));
  if ( (int)(v20 - 1) >= 0 )
  {
    v22 = (unsigned __int8)desta[0];
    v23 = &v19[4 * v18];
    v24 = v20 - 1;
    do
    {
      if ( v22 == 255 )
        v24 = v20 - 1 - v24;
      v26 = *(unsigned int *)((char *)dest + v8 - v7 + v24 * a6);
      if ( (_DWORD)v26 )
      {
        v27 = *((char *)dest + v9 - v7 + v26);
        if ( v27 )
        {
          result = 0LL;
          v28 = (unsigned __int8 *)dest + v9 - v7 + v26 + 1;
          do
          {
            v29 = 16 * result + v27;
            v30 = *v28++;
            v27 = v30;
            result = (v29 ^ ((unsigned __int64)((unsigned int)v29 & 0xF0000000) >> 24)) & ~(unsigned __int64)((unsigned int)v29 & 0xF0000000);
          }
          while ( v30 );
        }
        else
        {
          result = 0LL;
        }
        v31 = &v19[4 * (result - result / v18 * v18)];
        v32 = *(_DWORD *)v31;
        if ( *(_DWORD *)v31 )
        {
          do
          {
            v33 = v32;
            v32 = *(_DWORD *)&v23[4 * v32];
          }
          while ( v32 );
          v31 = &v23[4 * v33];
        }
        *(_DWORD *)v31 = v24;
      }
    }
    while ( v24-- > 0 );
  }
  return result;
}

//----- (0000000000006818) ----------------------------------------------------
unsigned __int64 __fastcall sub_6818(__int64 a1, __int64 a2, __int64 a3, __int64 **a4, __int64 **a5, unsigned int *a6, __int64 **a7, unsigned __int64 a8, unsigned int a9, __int64 a10, __int64 a11)
{
  _WORD *v18; // x28
  int v19; // w0
  _WORD *v20; // x19
  __int64 v21; // x8
  _BYTE *v22; // x1
  __int64 v23; // x8
  _BYTE *v24; // x1
  __int64 v25; // x8
  int v26; // w23
  void *v27; // x8
  __int64 v28; // x9
  __int64 v29; // x3
  __int64 v32; // [xsp+10h] [xbp-70h] BYREF

  sub_118BC(4LL, (__int64)&v32);
  if ( a8 + a9 > a8 )
  {
    v18 = (_WORD *)(a8 + 14);
    do
    {
      v19 = sub_150D0(a4);
      v32 += v19;
      *(_DWORD *)(v18 - 7) = v32;
      v20 = v18 - 7;
      v21 = *(unsigned int *)(a1 + 36);
      v22 = v18 - 1;
      if ( (unsigned int)(v21 + 1) >= *(_DWORD *)(a1 + 40) )
      {
        sub_14CB0((__int64 **)a1, v22, 1);
      }
      else
      {
        *v22 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v21);
        ++*(_DWORD *)(a1 + 36);
      }
      v23 = *(unsigned int *)(a2 + 36);
      v24 = (char *)v18 - 1;
      if ( (unsigned int)(v23 + 1) >= *(_DWORD *)(a2 + 40) )
      {
        sub_14CB0((__int64 **)a2, v24, 1);
        v25 = *(unsigned int *)(a3 + 36);
        if ( (unsigned int)(v25 + 2) >= *(_DWORD *)(a3 + 40) )
        {
LABEL_12:
          sub_14CB0((__int64 **)a3, v18, 2);
          goto LABEL_8;
        }
      }
      else
      {
        *v24 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a2 + 8LL) + v23);
        ++*(_DWORD *)(a2 + 36);
        v25 = *(unsigned int *)(a3 + 36);
        if ( (unsigned int)(v25 + 2) >= *(_DWORD *)(a3 + 40) )
          goto LABEL_12;
      }
      *v18 = *(_WORD *)(*(_QWORD *)(*(_QWORD *)a3 + 8LL) + v25);
      *(_DWORD *)(a3 + 36) += 2;
LABEL_8:
      *(_DWORD *)(v18 - 5) = sub_14FB8(a5);
      *(_DWORD *)(v18 - 3) = sub_14FB8(a5);
      v18 += 8;
    }
    while ( a8 + a9 > (unsigned __int64)(v20 + 8) );
  }
  v26 = *(_DWORD *)(a11 + 40);
  v27 = (void *)(a8 - *(_QWORD *)(a11 + 16) + *(_QWORD *)(a11 + 32));
  if ( v26 && (v28 = *((unsigned int *)a7 + 9), (unsigned int)(v28 + v26) < *((_DWORD *)a7 + 10)) )
  {
    memcpy(v27, (const void *)((*a7)[1] + v28), *(_DWORD *)(a11 + 40));
    *((_DWORD *)a7 + 9) += v26;
  }
  else
  {
    sub_14CB0(a7, v27, v26);
  }
  return sub_6624(
           a6,
           (void *)(a8 - *(_QWORD *)(a11 + 16) + *(_QWORD *)(a11 + 48)),
           *(_DWORD *)(a11 + 56),
           v29,
           a11,
           0x10u);
}
// 69F8: variable 'v29' is possibly undefined

//----- (0000000000006A30) ----------------------------------------------------
unsigned __int64 __fastcall sub_6A30(__int64 a1, __int64 a2, __int64 a3, __int64 **a4, __int64 **a5, unsigned int *a6, __int64 **a7, unsigned __int64 a8, unsigned int a9, __int64 a10, __int64 a11)
{
  _WORD *v18; // x28
  int v19; // w0
  _WORD *v20; // x19
  __int64 v21; // x8
  _BYTE *v22; // x1
  __int64 v23; // x8
  _BYTE *v24; // x1
  __int64 v25; // x8
  int v26; // w23
  void *v27; // x8
  __int64 v28; // x9
  __int64 v29; // x3
  __int64 v32; // [xsp+10h] [xbp-70h] BYREF

  sub_118BC(4LL, (__int64)&v32);
  if ( a8 + a9 > a8 )
  {
    v18 = (_WORD *)(a8 + 6);
    do
    {
      v19 = sub_150D0(a4);
      v32 += v19;
      *(_DWORD *)(v18 - 3) = v32;
      v20 = v18 - 3;
      v21 = *(unsigned int *)(a1 + 36);
      v22 = v18 - 1;
      if ( (unsigned int)(v21 + 1) >= *(_DWORD *)(a1 + 40) )
      {
        sub_14CB0((__int64 **)a1, v22, 1);
      }
      else
      {
        *v22 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v21);
        ++*(_DWORD *)(a1 + 36);
      }
      v23 = *(unsigned int *)(a2 + 36);
      v24 = (char *)v18 - 1;
      if ( (unsigned int)(v23 + 1) >= *(_DWORD *)(a2 + 40) )
      {
        sub_14CB0((__int64 **)a2, v24, 1);
        v25 = *(unsigned int *)(a3 + 36);
        if ( (unsigned int)(v25 + 2) >= *(_DWORD *)(a3 + 40) )
        {
LABEL_12:
          sub_14CB0((__int64 **)a3, v18, 2);
          goto LABEL_8;
        }
      }
      else
      {
        *v24 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)a2 + 8LL) + v23);
        ++*(_DWORD *)(a2 + 36);
        v25 = *(unsigned int *)(a3 + 36);
        if ( (unsigned int)(v25 + 2) >= *(_DWORD *)(a3 + 40) )
          goto LABEL_12;
      }
      *v18 = *(_WORD *)(*(_QWORD *)(*(_QWORD *)a3 + 8LL) + v25);
      *(_DWORD *)(a3 + 36) += 2;
LABEL_8:
      *(_QWORD *)(v18 + 1) = (unsigned int)sub_14FB8(a5);
      *(_QWORD *)(v18 + 5) = (unsigned int)sub_14FB8(a5);
      v18 += 12;
    }
    while ( a8 + a9 > (unsigned __int64)(v20 + 12) );
  }
  v26 = *(_DWORD *)(a11 + 40);
  v27 = (void *)(a8 - *(_QWORD *)(a11 + 16) + *(_QWORD *)(a11 + 32));
  if ( v26 && (v28 = *((unsigned int *)a7 + 9), (unsigned int)(v28 + v26) < *((_DWORD *)a7 + 10)) )
  {
    memcpy(v27, (const void *)((*a7)[1] + v28), *(_DWORD *)(a11 + 40));
    *((_DWORD *)a7 + 9) += v26;
  }
  else
  {
    sub_14CB0(a7, v27, v26);
  }
  return sub_6624(
           a6,
           (void *)(a8 - *(_QWORD *)(a11 + 16) + *(_QWORD *)(a11 + 48)),
           *(_DWORD *)(a11 + 56),
           v29,
           a11,
           0x18u);
}
// 6C18: variable 'v29' is possibly undefined

//----- (0000000000006C50) ----------------------------------------------------
__int64 __fastcall sub_6C50(__int64 a1, __int64 **a2, __int64 a3, int a4)
{
  __int64 v8; // x8
  int v9; // w9
  int v10; // w8
  int *v11; // x10
  int v12; // w9
  int v13; // w8
  unsigned int v14; // w24
  int v15; // w0
  __int64 v16; // x24
  int v17; // w0
  int dest; // [xsp+Ch] [xbp-54h] BYREF
  __int64 v20; // [xsp+10h] [xbp-50h] BYREF
  __int64 i; // [xsp+28h] [xbp-38h] BYREF

  sub_118BC(4LL, (__int64)&v20);
  for ( i = 0LL; a4; *(_DWORD *)(v16 + 8) = v20 )
  {
    v8 = *(unsigned int *)(a1 + 36);
    v9 = v8 + 4;
    if ( (unsigned int)(v8 + 4) >= *(_DWORD *)(a1 + 40) )
    {
      sub_14CB0((__int64 **)a1, &dest, 4);
      v10 = dest;
    }
    else
    {
      v10 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8LL) + v8);
      dest = v10;
      *(_DWORD *)(a1 + 36) = v9;
    }
    v11 = (int *)((unsigned __int64)&i & 0xFFFFFFFFFFFFFFFBLL | (4LL * (v10 & 1)));
    v12 = *v11;
    if ( (v10 & 2) != 0 )
      v13 = ~(v10 >> 2);
    else
      v13 = v10 >> 2;
    v14 = v13 + v12;
    *v11 = v13 + v12;
    v15 = sub_150D0(a2);
    v16 = a3 + 12LL * v14;
    v20 += v15;
    *(_DWORD *)(v16 + 4) = v20;
    v17 = sub_150D0(a2);
    --a4;
    v20 += v17;
  }
  return a3;
}

//----- (0000000000006D4C) ----------------------------------------------------
__int64 __fastcall sub_6D4C(__int64 a1, int a2, unsigned __int8 a3, unsigned __int8 *a4)
{
  __int64 v7; // x0
  __int64 v8; // x8
  int v9; // w9
  int v10; // w8
  __int64 v11; // x9
  int v12; // w8
  unsigned int v13; // w8
  void *v14; // x0
  __int64 v15; // x9
  size_t v16; // w1
  __int64 v18; // x0
  __int64 v19; // x8
  unsigned int v20; // [xsp+8h] [xbp-28h] BYREF
  int dest; // [xsp+Ch] [xbp-24h] BYREF

  if ( a3 == 1 )
  {
    v20 = 0;
    if ( a4 )
    {
      v20 = *a4;
    }
    else
    {
      v18 = *(_QWORD *)(a1 + 56);
      v19 = *(unsigned int *)(v18 + 36);
      if ( (unsigned int)(v19 + 1) >= *(_DWORD *)(v18 + 40) )
      {
        sub_14CB0((__int64 **)v18, &v20, 1);
      }
      else
      {
        LOBYTE(v20) = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v18 + 8LL) + v19);
        *(_DWORD *)(v18 + 36) = v19 + 1;
      }
    }
    v14 = (void *)(a1 + 8);
    *(_DWORD *)(*(_QWORD *)(a1 + 40) + 12LL * *(unsigned int *)(a1 + 8 + 4LL * v20) + 8) = a2
                                                                                         - *(_DWORD *)(a1 + 32)
                                                                                         - *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 8 + 4LL * v20) = -1;
    v16 = *(_DWORD *)(a1 + 4) - 1;
    *(_DWORD *)(a1 + 4) = v16;
  }
  else
  {
    if ( a3 )
      return 0LL;
    v7 = *(_QWORD *)(a1 + 48);
    v8 = *(unsigned int *)(v7 + 36);
    v9 = v8 + 4;
    if ( (unsigned int)(v8 + 4) >= *(_DWORD *)(v7 + 40) )
    {
      sub_14CB0((__int64 **)v7, &dest, 4);
      v10 = dest;
    }
    else
    {
      v10 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v7 + 8LL) + v8);
      dest = v10;
      *(_DWORD *)(v7 + 36) = v9;
    }
    v11 = a1 + 4LL * (v10 & 1);
    if ( (v10 & 2) != 0 )
      v12 = ~(v10 >> 2);
    else
      v12 = v10 >> 2;
    v13 = v12 + *(_DWORD *)(v11 + 20);
    *(_DWORD *)(v11 + 20) = v13;
    v14 = (void *)(a1 + 8);
    *(_DWORD *)(*(_QWORD *)(a1 + 40) + 12LL * v13 + 4) = a2 - *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 28);
    v15 = *(unsigned int *)(a1 + 4);
    v16 = v15 + 1;
    *(_DWORD *)(a1 + 4) = v15 + 1;
    *(_DWORD *)(a1 + 8 + 4 * v15) = v13;
  }
  qsort(v14, v16, 4u, (__compar_fn_t)sub_CBB8);
  return byte_22C1[a3];
}

//----- (0000000000006ED4) ----------------------------------------------------
void __fastcall sub_6ED4(__int64 a1, int8x8_t *a2, unsigned int a3, unsigned int a4, _DWORD *a5, int a6, int a7)
{
  __int64 *v7; // x8
  __int64 v11; // x28
  __int64 v12; // x25
  __int64 v17; // x8
  int v18; // w9
  unsigned int v19; // w8
  _DWORD *v20; // x24
  int v21; // w8
  unsigned __int64 v22; // x8
  __int64 v23; // x13
  __int64 ***v24; // x8
  __int64 **v25; // x27
  __int64 **v26; // x26
  __int64 v27; // x8
  __int64 v28; // x10
  int8x8_t *v29; // x8
  int8x8_t *v30; // x9
  unsigned int v31; // w12
  unsigned int v32; // w14
  unsigned int v33; // w13
  unsigned int v34; // w16
  unsigned int v35; // w13
  unsigned int v36; // w14
  unsigned int v37; // w15
  unsigned int v38; // w12
  unsigned int v39; // w13
  unsigned __int64 v40; // x10
  unsigned int *v41; // x10
  __int64 v42; // x11
  int8x8_t *v43; // x9
  __int64 v44; // x13
  unsigned __int64 v45; // d1
  int v46; // [xsp+0h] [xbp-A0h] BYREF
  __int64 v47[3]; // [xsp+4h] [xbp-9Ch]
  int v48; // [xsp+1Ch] [xbp-84h]
  int8x8_t *v49; // [xsp+20h] [xbp-80h]
  _DWORD *v50; // [xsp+28h] [xbp-78h]
  __int64 v51; // [xsp+30h] [xbp-70h]
  __int64 v52; // [xsp+38h] [xbp-68h]
  int dest; // [xsp+4Ch] [xbp-54h] BYREF

  v7 = *(__int64 **)(a1 + 16);
  v11 = *v7;
  v12 = v7[2075];
  dest = 0;
  if ( a5[23] )
  {
    v17 = *(unsigned int *)(v12 + 36);
    v18 = v17 + 4;
    if ( (unsigned int)(v17 + 4) >= *(_DWORD *)(v12 + 40) )
    {
      sub_14CB0((__int64 **)v12, &dest, 4);
      v19 = dest;
    }
    else
    {
      v19 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v12 + 8LL) + v17);
      dest = v19;
      *(_DWORD *)(v12 + 36) = v18;
    }
    v20 = (_DWORD *)sub_1810C(12LL * v19);
    if ( a7 )
      goto LABEL_5;
  }
  else
  {
    v20 = 0LL;
    if ( a7 )
    {
LABEL_5:
      v47[2] = 0LL;
      v47[1] = 0LL;
      v47[0] = 0xFFFFFFFF00000000LL;
      v46 = dest;
      v21 = a5[20] - a5[24];
      v49 = a2;
      v50 = v20;
      v48 = v21;
      v51 = v12;
      v52 = v11;
      sub_C1F8((__int64)&v46, a1, a2, a3, a6);
      if ( LODWORD(v47[0]) )
      {
        v22 = 0LL;
        do
        {
          v23 = *((unsigned int *)v47 + ++v22);
          v50[3 * v23 + 2] = a3 - v48;
        }
        while ( v22 < LODWORD(v47[0]) );
      }
      if ( a4 <= 1 )
        goto LABEL_27;
      goto LABEL_15;
    }
  }
  v24 = *(__int64 ****)(a1 + 16);
  v25 = *v24;
  v26 = v24[2080];
  if ( a3 && (v27 = *((unsigned int *)v25 + 9), (unsigned int)v27 + a3 < *((_DWORD *)v25 + 10)) )
  {
    memcpy(a2, (const void *)((*v25)[1] + v27), a3);
    *((_DWORD *)v25 + 9) += a3;
  }
  else
  {
    sub_14CB0(v25, a2, a3);
  }
  sub_6C50(v12, v26, (__int64)v20, dest);
  if ( a4 <= 1 )
  {
    v28 = a3 >> 2;
    v29 = (int8x8_t *)((char *)a2 + 4 * (unsigned int)v28);
    v30 = a2;
    if ( &v29[-4].n64_u8[4] > (unsigned __int8 *)a2 )
    {
      v30 = a2;
      do
      {
        v32 = v30[1].n64_u32[0];
        v31 = v30[1].n64_u32[1];
        v33 = bswap32(v30->n64_u32[1]);
        v30->n64_u32[0] = bswap32(v30->n64_u32[0]);
        v30->n64_u32[1] = v33;
        v34 = bswap32(v32);
        v35 = v30[2].n64_u32[0];
        v36 = v30[2].n64_u32[1];
        v30[1].n64_u32[0] = v34;
        v30[1].n64_u32[1] = bswap32(v31);
        v37 = bswap32(v35);
        v38 = v30[3].n64_u32[0];
        v39 = v30[3].n64_u32[1];
        v30[2].n64_u32[0] = v37;
        v30[2].n64_u32[1] = bswap32(v36);
        v30[3].n64_u32[0] = bswap32(v38);
        v30[3].n64_u32[1] = bswap32(v39);
        v30 += 4;
      }
      while ( v30 < (int8x8_t *)&v29[-4].n64_u8[4] );
    }
    if ( v30 < v29 )
    {
      v40 = (unsigned __int64)a2->n64_u64 + 4 * v28 + ~(unsigned __int64)v30;
      if ( v40 > 0xB )
      {
        v42 = (v40 >> 2) + 1;
        v41 = (unsigned int *)v30 + (v42 & 0x7FFFFFFFFFFFFFFCLL);
        v43 = v30 + 1;
        v44 = v42 & 0x7FFFFFFFFFFFFFFCLL;
        do
        {
          v44 -= 4LL;
          v45 = vrev32_s8((int8x8_t)v43->n64_u64[0]).n64_u64[0];
          v43[-1].n64_u64[0] = vrev32_s8(v43[-1]).n64_u64[0];
          v43->n64_u64[0] = v45;
          v43 += 2;
        }
        while ( v44 );
        if ( v42 == (v42 & 0x7FFFFFFFFFFFFFFCLL) )
          goto LABEL_27;
      }
      else
      {
        v41 = (unsigned int *)v30;
      }
      do
      {
        *v41 = bswap32(*v41);
        ++v41;
      }
      while ( v41 < (unsigned int *)v29 );
    }
LABEL_27:
    sub_C740((__int64)a2, a3);
    if ( !a5[23] )
      return;
    goto LABEL_28;
  }
LABEL_15:
  sub_CA14((__int64)a2, a3);
  if ( !a5[23] )
    return;
LABEL_28:
  sub_57F4(a1, (char *)a2 + *((_QWORD *)a5 + 10) - *((_QWORD *)a5 + 12), a5[22], v20, a4, (__int64)a5);
}

//----- (00000000000071D4) ----------------------------------------------------
__int64 __fastcall sub_71D4(__int64 a1, void *dest, size_t a3, __int64 a4, __int64 a5, int a6)
{
  unsigned int *v9; // x22
  unsigned int v10; // w9
  __int64 v11; // x10
  unsigned int v12; // w8
  __int64 result; // x0
  int v14; // w8
  int v15; // w9
  unsigned int v16; // w9
  __int64 v17; // x10
  unsigned int v18; // w8
  int v19; // w8
  int v20; // w9
  __int64 v21; // x8
  int desta; // [xsp+8h] [xbp-28h] BYREF
  int v23; // [xsp+Ch] [xbp-24h] BYREF

  v9 = *(unsigned int **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16LL) + 16400LL);
  if ( (a6 & 0xFFFFFFFD) != 0 )
  {
    v11 = v9[9];
    v10 = v9[10];
    v12 = v11 + 4;
    if ( (int)v11 + 4 >= v10 )
    {
      sub_14CB0(*(__int64 ***)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16LL) + 16400LL), &desta, 4);
      v12 = v9[9];
      v10 = v9[10];
      if ( a3 )
      {
LABEL_4:
        if ( v12 + a3 < v10 )
        {
          result = (__int64)memcpy(dest, (const void *)(*(_QWORD *)(*(_QWORD *)v9 + 8LL) + v12), a3);
          v9[9] += a3;
          v14 = desta;
          v15 = desta - 2067;
          goto LABEL_6;
        }
        goto LABEL_23;
      }
    }
    else
    {
      desta = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v9 + 8LL) + v11);
      v9[9] = v12;
      if ( a3 )
        goto LABEL_4;
    }
LABEL_23:
    result = sub_14CB0((__int64 **)v9, dest, a3);
    v14 = desta;
    v15 = desta - 2067;
    if ( (unsigned int)(desta - 2067) <= 0x17 )
    {
LABEL_6:
      switch ( v15 )
      {
        case 0:
          *(_QWORD *)(a4 + 32) = *((_QWORD *)dest + 3);
          *(_DWORD *)(a4 + 40) = *((_QWORD *)dest + 4);
          break;
        case 1:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
          return result;
        case 2:
          *(_QWORD *)(a4 + 16) = *((_QWORD *)dest + 3);
          *(_DWORD *)(a4 + 24) = *((_QWORD *)dest + 4);
          break;
        case 7:
          *(_QWORD *)(a4 + 80) = *((_QWORD *)dest + 3);
          *(_DWORD *)(a4 + 88) = *((_QWORD *)dest + 4);
          *(_DWORD *)(a4 + 92) = *((_QWORD *)dest + 4) != 0LL;
          break;
        case 14:
          *(_QWORD *)(a4 + 64) = *((_QWORD *)dest + 3);
          *(_DWORD *)(a4 + 72) = *((_QWORD *)dest + 4);
          break;
        case 23:
          *(_QWORD *)(a4 + 48) = *((_QWORD *)dest + 3);
          *(_DWORD *)(a4 + 56) = *((_QWORD *)dest + 4);
          break;
        default:
          goto LABEL_24;
      }
      return result;
    }
LABEL_24:
    if ( v14 )
      return result;
    *(_QWORD *)(a4 + 96) = *((_QWORD *)dest + 3);
    v21 = *((_QWORD *)dest + 4);
LABEL_30:
    *(_QWORD *)(a4 + 104) = v21;
    return result;
  }
  v17 = v9[9];
  v16 = v9[10];
  v18 = v17 + 4;
  if ( (int)v17 + 4 >= v16 )
  {
    sub_14CB0(*(__int64 ***)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16LL) + 16400LL), &v23, 4);
    v18 = v9[9];
    v16 = v9[10];
    if ( !a3 )
      goto LABEL_27;
  }
  else
  {
    v23 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v9 + 8LL) + v17);
    v9[9] = v18;
    if ( !a3 )
      goto LABEL_27;
  }
  if ( v18 + a3 < v16 )
  {
    result = (__int64)memcpy(dest, (const void *)(*(_QWORD *)(*(_QWORD *)v9 + 8LL) + v18), a3);
    v9[9] += a3;
    v19 = v23;
    v20 = v23 - 2053;
    goto LABEL_12;
  }
LABEL_27:
  result = sub_14CB0((__int64 **)v9, dest, a3);
  v19 = v23;
  v20 = v23 - 2053;
  if ( (unsigned int)(v23 - 2053) > 0x25 )
  {
LABEL_28:
    if ( v19 )
      return result;
    *(_QWORD *)(a4 + 96) = *((unsigned int *)dest + 4);
    v21 = *((unsigned int *)dest + 5);
    goto LABEL_30;
  }
LABEL_12:
  switch ( v20 )
  {
    case 0:
      *(_DWORD *)(a4 + 4) = *((_DWORD *)dest + 4);
      break;
    case 1:
    case 2:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 15:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
      return result;
    case 3:
      *(_DWORD *)a4 = *((_DWORD *)dest + 4);
      *(_DWORD *)(a4 + 8) = *((_DWORD *)dest + 5);
      break;
    case 14:
      *(_QWORD *)(a4 + 32) = *((unsigned int *)dest + 4);
      *(_DWORD *)(a4 + 40) = *((_DWORD *)dest + 5);
      break;
    case 16:
      *(_QWORD *)(a4 + 16) = *((unsigned int *)dest + 4);
      *(_DWORD *)(a4 + 24) = *((_DWORD *)dest + 5);
      break;
    case 37:
      *(_QWORD *)(a4 + 48) = *((unsigned int *)dest + 4);
      *(_DWORD *)(a4 + 56) = *((_DWORD *)dest + 5);
      break;
    default:
      goto LABEL_28;
  }
  return result;
}

//----- (00000000000074F4) ----------------------------------------------------
void __fastcall sub_74F4(__int64 a1, int8x8_t *a2, unsigned int a3, unsigned int a4, unsigned int *a5)
{
  __int64 v10; // x0
  __int64 v11; // x8
  unsigned int v12; // w9
  __int64 v13; // x0
  _DWORD *v14; // x10
  __int64 v15; // x8
  __int64 v16; // x21
  _BOOL8 v17; // x6
  int v18; // w5
  __int64 v19; // x8
  __int64 v20; // x0
  unsigned int v21; // w1
  __int64 v22; // x8
  __int64 **v23; // x22
  char *v24; // x23
  char *v25; // x19
  int v26; // w0
  __int64 v27; // x8
  char *v28; // x8
  __int64 v29; // [xsp+8h] [xbp-58h]
  unsigned int dest; // [xsp+1Ch] [xbp-44h] BYREF
  __int64 v31; // [xsp+20h] [xbp-40h] BYREF

  v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16LL) + 16400LL);
  v11 = *(unsigned int *)(v10 + 36);
  if ( (unsigned int)(v11 + 4) >= *(_DWORD *)(v10 + 40) )
  {
    sub_14CB0((__int64 **)v10, &dest, 4);
    v12 = dest;
  }
  else
  {
    v12 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v10 + 8LL) + v11);
    dest = v12;
    *(_DWORD *)(v10 + 36) = v11 + 4;
  }
  v13 = *(_QWORD *)(a1 + 32);
  v14 = *(_DWORD **)(a1 + 48);
  v15 = *(_QWORD *)(v13 + 16);
  v16 = *(_QWORD *)(v15 + 8LL * v12);
  v17 = *v14 == 0;
  if ( (a3 & 0xFFFFFFFD) == 0 )
  {
    switch ( v12 )
    {
      case 0x805u:
        sub_5BCC(
          *(__int64 ***)(v15 + 8LL * v12),
          *(_QWORD *)(v15 + 16432),
          *(_QWORD *)(v15 + 16440),
          *(_QWORD *)(v15 + 16448),
          (unsigned __int64)a2,
          a4,
          v17,
          a5);
        return;
      case 0x806u:
      case 0x807u:
      case 0x809u:
      case 0x80Au:
      case 0x80Bu:
      case 0x80Cu:
      case 0x80Eu:
      case 0x80Fu:
      case 0x810u:
      case 0x811u:
      case 0x812u:
      case 0x814u:
      case 0x816u:
      case 0x817u:
      case 0x818u:
      case 0x819u:
      case 0x81Au:
      case 0x81Bu:
      case 0x81Cu:
      case 0x81Du:
      case 0x81Eu:
      case 0x81Fu:
      case 0x820u:
      case 0x821u:
      case 0x822u:
      case 0x823u:
      case 0x824u:
      case 0x825u:
      case 0x826u:
      case 0x827u:
      case 0x828u:
      case 0x829u:
        goto LABEL_17;
      case 0x808u:
      case 0x813u:
      case 0x82Au:
        return;
      case 0x80Du:
        v23 = *(__int64 ***)(v15 + 16496);
        sub_118BC(4LL, (__int64)&v31);
        v24 = (char *)a2 + a4;
        if ( v24 > (char *)a2 )
        {
          v25 = (char *)a2 + 4;
          do
          {
            v26 = sub_150D0(v23);
            v31 += v26;
            *((_DWORD *)v25 - 1) = v31;
            v27 = *(unsigned int *)(v16 + 36);
            if ( (unsigned int)(v27 + 4) >= *(_DWORD *)(v16 + 40) )
            {
              sub_14CB0((__int64 **)v16, v25, 4);
            }
            else
            {
              *(_DWORD *)v25 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v16 + 8LL) + v27);
              *(_DWORD *)(v16 + 36) += 4;
            }
            v28 = v25 + 4;
            v25 += 8;
          }
          while ( v24 > v28 );
        }
        return;
      case 0x815u:
        sub_6818(
          *(_QWORD *)(v15 + 8LL * v12),
          *(_QWORD *)(v15 + 16560),
          *(_QWORD *)(v15 + 16568),
          *(__int64 ***)(v15 + 16576),
          *(__int64 ***)(v15 + 16584),
          *(unsigned int **)(v15 + 16720),
          *(__int64 ***)(v15 + 16536),
          (unsigned __int64)a2,
          a4,
          v29,
          (__int64)a5);
        return;
      default:
        if ( v12 )
        {
LABEL_17:
          if ( a4 && (v22 = *(unsigned int *)(v16 + 36), (unsigned int)v22 + a4 < *(_DWORD *)(v16 + 40)) )
          {
            memcpy(a2, (const void *)(*(_QWORD *)(*(_QWORD *)v16 + 8LL) + v22), a4);
            *(_DWORD *)(v16 + 36) += a4;
          }
          else
          {
            sub_14CB0((__int64 **)v16, a2, a4);
          }
          return;
        }
        if ( a4 && (v19 = *(unsigned int *)(v16 + 36), (unsigned int)v19 + a4 < *(_DWORD *)(v16 + 40)) )
        {
          memcpy(a2, (const void *)(*(_QWORD *)(*(_QWORD *)v16 + 8LL) + v19), a4);
          *(_DWORD *)(v16 + 36) += a4;
          v20 = (__int64)a2;
          v21 = a4;
          if ( a3 > 1 )
          {
LABEL_14:
            sub_CA14(v20, v21);
            return;
          }
        }
        else
        {
          sub_14CB0((__int64 **)v16, a2, a4);
          v20 = (__int64)a2;
          v21 = a4;
          if ( a3 > 1 )
            goto LABEL_14;
        }
        sub_C958(v20, v21);
        return;
    }
  }
  v18 = v14[1];
  switch ( v12 )
  {
    case 0x80Fu:
      sub_5DC0(
        *(_QWORD *)(v15 + 8LL * v12),
        *(_QWORD *)(v15 + 16512),
        *(__int64 ***)(v15 + 16520),
        (unsigned __int64)a2,
        a4);
      break;
    case 0x810u:
    case 0x811u:
    case 0x812u:
    case 0x814u:
    case 0x816u:
    case 0x817u:
    case 0x818u:
    case 0x819u:
    case 0x81Bu:
    case 0x81Cu:
    case 0x81Du:
    case 0x81Eu:
    case 0x81Fu:
    case 0x820u:
    case 0x822u:
    case 0x823u:
    case 0x824u:
    case 0x825u:
    case 0x826u:
    case 0x827u:
    case 0x828u:
    case 0x829u:
    case 0x82Bu:
    case 0x82Cu:
    case 0x82Du:
    case 0x82Eu:
    case 0x82Fu:
    case 0x830u:
    case 0x831u:
    case 0x832u:
    case 0x833u:
    case 0x834u:
    case 0x835u:
    case 0x836u:
    case 0x837u:
    case 0x838u:
      goto LABEL_17;
    case 0x813u:
    case 0x81Au:
    case 0x82Au:
      return;
    case 0x815u:
      sub_6A30(
        *(_QWORD *)(v15 + 8LL * v12),
        *(_QWORD *)(v15 + 16560),
        *(_QWORD *)(v15 + 16568),
        *(__int64 ***)(v15 + 16576),
        *(__int64 ***)(v15 + 16584),
        *(unsigned int **)(v15 + 16720),
        *(__int64 ***)(v15 + 16536),
        (unsigned __int64)a2,
        a4,
        v29,
        (__int64)a5);
      break;
    case 0x821u:
      if ( !a5[23] )
        goto LABEL_17;
      break;
    case 0x839u:
      sub_61BC(
        v16,
        *(_QWORD *)(v15 + 16848),
        *(_QWORD *)(v15 + 16856),
        *(_QWORD *)(v15 + 16864),
        *(unsigned int **)(v15 + 16872),
        a2,
        a4,
        a3,
        v18);
      break;
    default:
      if ( v12 )
        goto LABEL_17;
      sub_6ED4(v13, a2, a4, a3, a5, v18, v17);
      break;
  }
}
// 7690: variable 'v29' is possibly undefined

//----- (0000000000007824) ----------------------------------------------------
void __fastcall sub_7824(__int64 a1)
{
  __int64 v1; // x28
  char *v2; // x29
  __int64 v3; // x21
  __int64 v5; // x20
  unsigned int v6; // w0
  unsigned int v7; // w22
  unsigned int *v8; // x21
  __int64 v9; // x8
  unsigned int v10; // w8
  __int64 v11; // x27
  _OWORD *v12; // x23
  __int64 v13; // x8
  __int128 *v14; // x8
  __int128 v15; // q0
  __int128 v16; // q2
  __int128 v17; // q3
  unsigned int v18; // w9
  int v19; // w24
  char *v20; // x8
  __int64 v21; // x4
  unsigned __int64 v22; // x8
  __int64 v23; // x28
  unsigned __int64 v24; // x25
  char *v25; // x24
  unsigned __int64 v26; // x24
  __int64 v27; // x3
  __int64 v28; // x8
  __int128 *v29; // x8
  __int128 v30; // q0
  __int128 v31; // q1
  __int128 v32; // q2
  unsigned int v33; // w9
  int v34; // w24
  char *v35; // x8
  __int64 v36; // x4
  unsigned __int64 v37; // x8
  __int64 v38; // x29
  unsigned __int64 v39; // x25
  char *v40; // x24
  unsigned __int64 v41; // x24
  unsigned int v42; // w3
  __int128 v43; // [xsp+10h] [xbp-E0h] BYREF
  __int128 v44; // [xsp+20h] [xbp-D0h]
  __int128 v45; // [xsp+30h] [xbp-C0h]
  __int128 v46; // [xsp+40h] [xbp-B0h]
  __int128 v47; // [xsp+50h] [xbp-A0h]
  __int128 v48; // [xsp+60h] [xbp-90h]
  __int128 v49; // [xsp+70h] [xbp-80h]
  unsigned int dest; // [xsp+8Ch] [xbp-64h] BYREF

  v3 = *(_QWORD *)(a1 + 8);
  v5 = sub_183A8(v3);
  v6 = sub_183A0(v3);
  v7 = v6;
  v8 = *(unsigned int **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16LL) + 16400LL);
  v9 = v8[9];
  if ( (int)v9 + 4 >= v8[10] )
  {
    sub_14CB0(*(__int64 ***)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16LL) + 16400LL), &dest, 4);
    if ( v7 )
      goto LABEL_3;
  }
  else
  {
    dest = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v8 + 8LL) + v9);
    v8[9] = v9 + 4;
    if ( v6 )
    {
LABEL_3:
      v10 = 0;
      do
      {
        while ( 1 )
        {
          v11 = v10;
          v12 = (_OWORD *)(v5 + v10);
          if ( (dest & 0xFFFFFFFD) != 1 )
            break;
          v48 = 0uLL;
          v49 = 0uLL;
          v46 = 0uLL;
          v47 = 0uLL;
          v44 = 0uLL;
          v45 = 0uLL;
          v43 = 0uLL;
          v13 = v8[9];
          if ( (int)v13 + 64 >= v8[10] )
          {
            sub_14CB0((__int64 **)v8, v12, 64);
            v18 = v8[9];
          }
          else
          {
            v14 = (__int128 *)(*(_QWORD *)(*(_QWORD *)v8 + 8LL) + v13);
            v15 = v14[3];
            v17 = *v14;
            v16 = v14[1];
            v12[2] = v14[2];
            v12[3] = v15;
            *v12 = v17;
            v12[1] = v16;
            v18 = v8[9] + 64;
            v8[9] = v18;
          }
          v19 = *((unsigned __int16 *)v12 + 28) * *((unsigned __int16 *)v12 + 27);
          v20 = (char *)v12 + *((_QWORD *)v12 + 4);
          if ( v19 && v19 + v18 < v8[10] )
          {
            memcpy(v20, (const void *)(*(_QWORD *)(*(_QWORD *)v8 + 8LL) + v18), v19);
            v8[9] += v19;
            LOWORD(v22) = *((_WORD *)v12 + 30);
            if ( (_WORD)v22 )
              goto LABEL_12;
          }
          else
          {
            sub_14CB0((__int64 **)v8, v20, v19);
            LOWORD(v22) = *((_WORD *)v12 + 30);
            if ( (_WORD)v22 )
            {
LABEL_12:
              v23 = *((_QWORD *)v12 + 5);
              v24 = 0LL;
              v25 = (char *)v12 + v23;
              do
              {
                sub_71D4(a1, v25, 0x40u, (__int64)&v43, v21, dest);
                v22 = *((unsigned __int16 *)v12 + 30);
                ++v24;
                v25 += 64;
              }
              while ( v24 < v22 );
              if ( *((_WORD *)v12 + 30) )
              {
                v26 = 0LL;
                v1 = v5 - 64 + v23 + v11;
                do
                {
                  v27 = *(_QWORD *)(v1 + 96);
                  if ( v27 )
                  {
                    if ( *(_DWORD *)(v1 + 68) != 8 )
                    {
                      sub_74F4(a1, (int8x8_t *)((char *)v12 + *(_QWORD *)(v1 + 88)), dest, v27, (unsigned int *)&v43);
                      LOWORD(v22) = *((_WORD *)v12 + 30);
                    }
                  }
                  ++v26;
                  v1 += 64LL;
                }
                while ( v26 < (unsigned __int16)v22 );
              }
              else
              {
                v1 = (__int64)(v25 - 64);
              }
              goto LABEL_34;
            }
          }
LABEL_34:
          v10 = (v11
               + *(_DWORD *)(v1 + 32)
               + *(_DWORD *)(v1 + 24)
               + *((unsigned __int16 *)v12 + 29) * (unsigned __int16)v22
               + 7) & 0xFFFFFFF8;
          if ( v10 >= v7 )
            return;
        }
        v48 = 0uLL;
        v49 = 0uLL;
        v46 = 0uLL;
        v47 = 0uLL;
        v44 = 0uLL;
        v45 = 0uLL;
        v43 = 0uLL;
        v28 = v8[9];
        if ( (int)v28 + 52 >= v8[10] )
        {
          sub_14CB0((__int64 **)v8, v12, 52);
          v33 = v8[9];
        }
        else
        {
          v29 = (__int128 *)(*(_QWORD *)(*(_QWORD *)v8 + 8LL) + v28);
          v31 = v29[1];
          v30 = v29[2];
          v32 = *v29;
          *((_DWORD *)v12 + 12) = *((_DWORD *)v29 + 12);
          v12[1] = v31;
          v12[2] = v30;
          *v12 = v32;
          v33 = v8[9] + 52;
          v8[9] = v33;
        }
        v34 = *((unsigned __int16 *)v12 + 22) * *((unsigned __int16 *)v12 + 21);
        v35 = (char *)v12 + *((unsigned int *)v12 + 7);
        if ( v34 && v34 + v33 < v8[10] )
        {
          memcpy(v35, (const void *)(*(_QWORD *)(*(_QWORD *)v8 + 8LL) + v33), v34);
          v8[9] += v34;
          LOWORD(v37) = *((_WORD *)v12 + 24);
          if ( (_WORD)v37 )
            goto LABEL_25;
        }
        else
        {
          sub_14CB0((__int64 **)v8, v35, v34);
          LOWORD(v37) = *((_WORD *)v12 + 24);
          if ( (_WORD)v37 )
          {
LABEL_25:
            v38 = *((unsigned int *)v12 + 8);
            v39 = 0LL;
            v40 = (char *)v12 + v38;
            do
            {
              sub_71D4(a1, v40, 0x28u, (__int64)&v43, v36, dest);
              v37 = *((unsigned __int16 *)v12 + 24);
              ++v39;
              v40 += 40;
            }
            while ( v39 < v37 );
            if ( *((_WORD *)v12 + 24) )
            {
              v41 = 0LL;
              v2 = (char *)(v5 - 40 + v11 + v38);
              do
              {
                v42 = *((_DWORD *)v2 + 15);
                if ( v42 && *((_DWORD *)v2 + 11) != 8 )
                {
                  sub_74F4(a1, (int8x8_t *)((char *)v12 + *((unsigned int *)v2 + 14)), dest, v42, (unsigned int *)&v43);
                  LOWORD(v37) = *((_WORD *)v12 + 24);
                }
                ++v41;
                v2 += 40;
              }
              while ( v41 < (unsigned __int16)v37 );
            }
            else
            {
              v2 = v40 - 40;
            }
            goto LABEL_5;
          }
        }
LABEL_5:
        v10 = (v11
             + *((_DWORD *)v2 + 4)
             + *((_DWORD *)v2 + 5)
             + *((unsigned __int16 *)v12 + 23) * (unsigned __int16)v37
             + 3) & 0xFFFFFFFC;
      }
      while ( v10 < v7 );
    }
  }
}
// 78AC: variable 'v2' is possibly undefined
// 79AC: variable 'v21' is possibly undefined
// 7AE0: variable 'v36' is possibly undefined
// 7B5C: variable 'v1' is possibly undefined

//----- (0000000000007C24) ----------------------------------------------------
__int64 __fastcall sub_7C24(__int64 result, void *dest, int a3, unsigned __int8 *a4)
{
  int v5; // w8
  unsigned __int8 v6; // w9
  int v7; // w8
  unsigned __int8 v8; // w9
  char v9; // w8
  int v10; // w8
  int v11; // w8
  unsigned int v12; // w8
  __int64 *v13; // x9
  __int64 v14; // x8
  unsigned int v15; // w8
  __int64 *v16; // x9
  __int64 v17; // x8
  unsigned int v18; // w8
  __int64 *v19; // x9
  __int64 v20; // x8
  unsigned int v21; // w8
  __int64 *v22; // x9
  unsigned int v23; // w8
  __int64 *v24; // x9
  unsigned int v25; // w8
  __int64 *v26; // x9
  unsigned int v27; // w8
  __int64 *v28; // x9
  __int64 v29; // x8
  unsigned int v30; // w8
  __int64 *v31; // x9
  int v32; // w8
  unsigned int v33; // w8
  __int64 *v34; // x9
  __int64 v35; // x8
  unsigned int v36; // w8
  __int64 *v37; // x9
  unsigned int v38; // w8
  __int64 *v39; // x9
  unsigned int v40; // w8
  __int64 *v41; // x9
  unsigned int v42; // w8
  __int64 *v43; // x9
  unsigned int v44; // w8
  __int64 *v45; // x9
  __int64 v46; // x8
  __int64 v47; // x8
  unsigned int v48; // w9
  __int64 *v49; // x10
  __int64 v50; // x8
  unsigned int v51; // w9
  __int64 *v52; // x10
  __int64 v53; // x8
  __int64 v54; // x8
  unsigned int v55; // w9
  __int64 *v56; // x10
  unsigned int v57; // w8
  __int64 *v58; // x9
  unsigned int v59; // w8
  __int64 *v60; // x9
  __int64 v61; // x8
  unsigned int v62; // w8
  __int64 *v63; // x9
  unsigned int v64; // w8
  __int64 *v65; // x9
  __int64 v66; // x8
  unsigned int v67; // w8
  __int64 *v68; // x9
  __int64 v69; // x8
  unsigned int v70; // w8
  __int64 *v71; // x9
  unsigned int v72; // w8
  __int64 *v73; // x9
  __int64 v74; // x8
  unsigned int v75; // w8
  __int64 *v76; // x9
  __int64 v77; // x8
  unsigned int v78; // w8
  __int64 *v79; // x9
  unsigned int v80; // w8
  __int64 *v81; // x9
  unsigned int v82; // w8
  __int64 *v83; // x9
  unsigned int v84; // w8
  __int64 *v85; // x9
  __int64 v86; // x8
  unsigned int v87; // w8
  __int64 *v88; // x9
  __int64 v89; // x8
  unsigned int v90; // w8
  __int64 *v91; // x9
  unsigned int v92; // w8
  __int64 *v93; // x9
  unsigned int v94; // w8
  __int64 *v95; // x9
  __int64 v96; // x8
  unsigned int v97; // w8
  __int64 *v98; // x9
  unsigned int v99; // w8
  __int64 *v100; // x9
  unsigned int v101; // w8
  __int64 *v102; // x9
  unsigned int v103; // w8
  __int64 *v104; // x9
  unsigned int v105; // w8
  __int64 *v106; // x9
  __int64 v107; // x8
  unsigned int v108; // w8
  __int64 *v109; // x9
  unsigned int v110; // w8
  __int64 *v111; // x9
  __int64 v112; // x8
  __int64 v113; // x8
  unsigned int v114; // w9
  __int64 *v115; // x10
  __int64 v116; // x8
  unsigned int v117; // w9
  __int64 *v118; // x10
  unsigned int v119; // w8
  __int64 *v120; // x9
  unsigned int v121; // w8
  __int64 *v122; // x9
  unsigned int v123; // w8
  __int64 *v124; // x9
  _BYTE *v125; // x1
  unsigned int v126; // w8
  __int64 *v127; // x9
  unsigned int v128; // w8
  __int64 *v129; // x9
  int v130; // w8
  _BYTE *v131; // x19
  __int64 v132; // x8
  unsigned int v133; // w9
  __int64 *v134; // x10
  int v135; // w8
  unsigned int v136; // w8
  __int64 *v137; // x9
  unsigned int v138; // w8
  __int64 *v139; // x9
  __int64 v140; // x8
  unsigned int v141; // w8
  __int64 *v142; // x9
  int v143; // w8
  unsigned int v144; // w8
  __int64 *v145; // x9
  unsigned int v146; // w8
  __int64 *v147; // x9
  __int64 v148; // x8
  int v149; // w8
  __int64 v150; // x8
  unsigned int v151; // w9
  __int64 *v152; // x10
  __int64 v153; // x9
  unsigned int v154; // w9
  __int64 *v155; // x10
  unsigned int v156; // w9
  __int64 *v157; // x10
  unsigned int v158; // w9
  __int64 *v159; // x10
  unsigned int v160; // w9
  __int64 *v161; // x10
  unsigned int v162; // w8
  __int64 *v163; // x9
  __int64 v164; // x8
  unsigned int v165; // w8
  __int64 *v166; // x9
  unsigned int v167; // w8
  __int64 *v168; // x9
  unsigned int v169; // w8
  __int64 *v170; // x9
  unsigned int v171; // w8
  __int64 *v172; // x9
  _BYTE *v173; // x1
  __int64 v174; // x8
  unsigned int v175; // w9
  __int64 *v176; // x10
  unsigned int v177; // w8
  __int64 *v178; // x9
  unsigned int v179; // w8
  __int64 *v180; // x9
  unsigned int v181; // w8
  __int64 *v182; // x9
  unsigned int v183; // w8
  __int64 *v184; // x9
  unsigned int v185; // w8
  __int64 *v186; // x9
  int v187; // w8
  int v188; // w8
  __int64 v189; // x8
  unsigned int v190; // w9
  __int64 *v191; // x10
  unsigned int v192; // w9
  __int64 *v193; // x10
  unsigned int v194; // w9
  __int64 *v195; // x10
  unsigned int v196; // w8
  __int64 *v197; // x9
  unsigned int v198; // w8
  __int64 *v199; // x9
  unsigned int v200; // w8
  __int64 *v201; // x9
  unsigned int v202; // w8
  __int64 *v203; // x9
  unsigned int v204; // w8
  __int64 *v205; // x9
  __int64 v206; // x8
  unsigned int v207; // w9
  __int64 *v208; // x10
  unsigned int v209; // w8
  __int64 *v210; // x9
  unsigned int v211; // w8
  __int64 *v212; // x9
  unsigned int v213; // w8
  __int64 *v214; // x9
  unsigned int v215; // w8
  __int64 *v216; // x9
  int v217; // w8
  int v218; // w8
  unsigned int v219; // w8
  __int64 *v220; // x9
  unsigned int v221; // w8
  __int64 *v222; // x9
  _BYTE *v223; // x1
  unsigned int v224; // w8
  __int64 *v225; // x9
  int v226; // w8
  unsigned int v227; // w8
  __int64 *v228; // x9
  unsigned int v229; // w8
  __int64 *v230; // x9
  unsigned int v231; // w8
  __int64 *v232; // x9
  unsigned int v233; // w8
  __int64 *v234; // x9
  unsigned int v235; // w8
  __int64 *v236; // x9
  unsigned int v237; // w8
  __int64 *v238; // x9
  int v239; // w8
  int v240; // w8
  int v241; // w8
  int v242; // w8
  unsigned int v243; // w8
  __int64 *v244; // x9
  int v245; // w8
  int v246; // w8
  int v247; // w8
  int v248; // w8
  int v249; // w8
  int v250; // w8
  unsigned int v251; // w8
  __int64 *v252; // x9
  unsigned int v253; // w8
  __int64 *v254; // x9
  unsigned int v255; // w8
  __int64 *v256; // x9
  int v257; // w8
  int v258; // w8
  unsigned int v259; // w8
  __int64 *v260; // x9
  unsigned int v261; // w8
  __int64 *v262; // x9
  int v263; // w8
  int v264; // w8
  int v265; // w8
  int v266; // w8
  int v267; // w8
  unsigned int v268; // w8
  __int64 *v269; // x9
  int v270; // w8
  int v271; // w8
  int v272; // w8
  unsigned int v273; // w8
  __int64 *v274; // x9
  int v275; // w8
  unsigned int v276; // w8
  __int64 *v277; // x9
  unsigned int v278; // w8
  __int64 *v279; // x9
  char v280; // w9
  char v281; // w9
  char v282; // w11
  char v283; // w9
  char v284; // w9
  char v285; // w11
  char v286; // w9
  char v287; // w9
  char v288; // w10
  char v289; // w11
  char v290; // w9
  char v291; // w11
  char v292; // w9
  char v293; // w9
  char v294; // w9
  char v295; // w9
  char v296; // w9
  char v297; // w9
  char v298; // w9
  char v299; // w9
  char v300; // w9
  char v301; // w11
  char v302; // w9
  char v303; // w9
  char v304; // w9
  char v305; // w10
  char v306; // w9
  __int64 v307; // [xsp+8h] [xbp-28h]
  __int64 v308; // [xsp+8h] [xbp-28h]
  __int64 v309; // [xsp+8h] [xbp-28h]
  __int64 v310; // [xsp+8h] [xbp-28h]
  __int64 v311; // [xsp+8h] [xbp-28h]
  __int64 v312; // [xsp+8h] [xbp-28h]
  __int64 v313; // [xsp+10h] [xbp-20h]
  __int64 v314; // [xsp+10h] [xbp-20h]
  __int64 v315; // [xsp+10h] [xbp-20h]
  __int64 v316; // [xsp+10h] [xbp-20h]
  __int64 v317; // [xsp+10h] [xbp-20h]
  __int64 v318; // [xsp+10h] [xbp-20h]
  __int64 v319; // [xsp+10h] [xbp-20h]
  __int64 v320; // [xsp+10h] [xbp-20h]
  __int64 v321; // [xsp+10h] [xbp-20h]
  __int64 v322; // [xsp+10h] [xbp-20h]
  __int64 v323; // [xsp+10h] [xbp-20h]
  __int64 v324; // [xsp+10h] [xbp-20h]
  __int64 v325; // [xsp+10h] [xbp-20h]
  __int64 v326; // [xsp+10h] [xbp-20h]
  __int64 v327; // [xsp+10h] [xbp-20h]
  __int64 v328; // [xsp+10h] [xbp-20h]
  __int64 v329; // [xsp+10h] [xbp-20h]
  __int64 v330; // [xsp+10h] [xbp-20h]
  __int64 v331; // [xsp+10h] [xbp-20h]
  __int64 v332; // [xsp+10h] [xbp-20h]
  __int64 v333; // [xsp+10h] [xbp-20h]
  __int64 v334; // [xsp+10h] [xbp-20h]
  __int64 v335; // [xsp+10h] [xbp-20h]
  __int64 v336; // [xsp+10h] [xbp-20h]
  __int64 v337; // [xsp+10h] [xbp-20h]
  __int64 v338; // [xsp+10h] [xbp-20h]
  __int64 v339; // [xsp+10h] [xbp-20h]
  __int64 v340; // [xsp+10h] [xbp-20h]
  __int64 v341; // [xsp+10h] [xbp-20h]
  __int64 v342; // [xsp+10h] [xbp-20h]
  __int64 v343; // [xsp+10h] [xbp-20h]
  __int64 v344; // [xsp+10h] [xbp-20h]
  __int64 v345; // [xsp+10h] [xbp-20h]
  __int64 v346; // [xsp+10h] [xbp-20h]
  __int64 v347; // [xsp+10h] [xbp-20h]
  unsigned __int8 *v348; // [xsp+10h] [xbp-20h]
  __int64 v349; // [xsp+10h] [xbp-20h]
  __int64 v350; // [xsp+10h] [xbp-20h]
  __int64 v351; // [xsp+10h] [xbp-20h]
  __int64 v352; // [xsp+10h] [xbp-20h]
  __int64 v353; // [xsp+10h] [xbp-20h]
  __int64 v354; // [xsp+10h] [xbp-20h]
  __int64 v355; // [xsp+10h] [xbp-20h]
  __int64 v356; // [xsp+10h] [xbp-20h]
  __int64 v357; // [xsp+10h] [xbp-20h]
  __int64 v358; // [xsp+10h] [xbp-20h]
  __int64 v359; // [xsp+10h] [xbp-20h]
  __int64 v360; // [xsp+10h] [xbp-20h]
  __int64 v361; // [xsp+10h] [xbp-20h]
  __int64 v362; // [xsp+10h] [xbp-20h]
  __int64 v363; // [xsp+10h] [xbp-20h]
  __int64 v364; // [xsp+10h] [xbp-20h]
  __int64 v365; // [xsp+10h] [xbp-20h]
  __int64 v366; // [xsp+10h] [xbp-20h]
  __int64 v367; // [xsp+10h] [xbp-20h]
  __int64 v368; // [xsp+10h] [xbp-20h]
  __int64 v369; // [xsp+10h] [xbp-20h]
  __int64 v370; // [xsp+10h] [xbp-20h]
  __int64 v371; // [xsp+10h] [xbp-20h]
  __int64 v372; // [xsp+10h] [xbp-20h]
  __int64 v373; // [xsp+10h] [xbp-20h]
  __int64 v374; // [xsp+10h] [xbp-20h]
  __int64 v375; // [xsp+10h] [xbp-20h]
  __int64 v376; // [xsp+10h] [xbp-20h]
  __int64 v377; // [xsp+10h] [xbp-20h]
  __int64 v378; // [xsp+10h] [xbp-20h]
  __int64 v379; // [xsp+10h] [xbp-20h]
  __int64 v380; // [xsp+10h] [xbp-20h]
  __int64 v381; // [xsp+10h] [xbp-20h]
  __int64 v382; // [xsp+10h] [xbp-20h]
  __int64 v383; // [xsp+10h] [xbp-20h]
  __int64 v384; // [xsp+10h] [xbp-20h]
  __int64 v385; // [xsp+10h] [xbp-20h]
  __int64 v386; // [xsp+10h] [xbp-20h]
  __int64 v387; // [xsp+10h] [xbp-20h]
  __int64 v388; // [xsp+10h] [xbp-20h]
  __int64 v389; // [xsp+10h] [xbp-20h]
  __int64 v390; // [xsp+10h] [xbp-20h]
  __int64 v391; // [xsp+10h] [xbp-20h]
  __int64 desta; // [xsp+18h] [xbp-18h] BYREF

  switch ( a3 )
  {
    case -1:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 8LL);
      v12 = *(_DWORD *)(result + 36) + 4;
      if ( v12 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, dest, 4);
        v287 = *(_BYTE *)dest;
        v288 = *((_BYTE *)dest + 2);
        v289 = *((_BYTE *)dest + 1);
        *(_BYTE *)dest = *((_BYTE *)dest + 3);
        *((_BYTE *)dest + 3) = v287;
        *((_BYTE *)dest + 1) = v288;
        *((_BYTE *)dest + 2) = v289;
      }
      else
      {
        v13 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v12;
        v14 = v13[1] + v12;
        *(_BYTE *)dest = *(_BYTE *)(v14 - 1);
        *((_BYTE *)dest + 1) = *(_BYTE *)(v14 - 2);
        *((_BYTE *)dest + 2) = *(_BYTE *)(v14 - 3);
        *((_BYTE *)dest + 3) = *(_BYTE *)(v14 - 4);
      }
      return result;
    case 0:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 16LL);
      goto LABEL_20;
    case 1:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 24LL);
LABEL_20:
      desta = 0LL;
      v15 = *(_DWORD *)(result + 36) + 4;
      if ( v15 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 4);
        v284 = desta;
        v285 = BYTE1(desta);
        LOBYTE(desta) = BYTE3(desta);
        BYTE3(desta) = v284;
        BYTE1(desta) = BYTE2(desta);
        BYTE2(desta) = v285;
      }
      else
      {
        v16 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v15;
        v17 = v16[1] + v15;
        LOBYTE(desta) = *(_BYTE *)(v17 - 1);
        BYTE1(desta) = *(_BYTE *)(v17 - 2);
        BYTE2(desta) = *(_BYTE *)(v17 - 3);
        BYTE3(desta) = *(_BYTE *)(v17 - 4);
      }
      goto LABEL_294;
    case 4:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 32LL);
      goto LABEL_116;
    case 5:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 40LL);
      goto LABEL_116;
    case 6:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 48LL);
      goto LABEL_116;
    case 7:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 56LL);
      goto LABEL_116;
    case 8:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 64LL);
      goto LABEL_116;
    case 9:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 72LL);
      goto LABEL_116;
    case 10:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 80LL);
      goto LABEL_116;
    case 11:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 88LL);
      goto LABEL_116;
    case 12:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 96LL);
      goto LABEL_116;
    case 13:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 104LL);
      goto LABEL_116;
    case 14:
      *(_BYTE *)dest = *a4;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 112LL);
      desta = 0LL;
      v18 = *(_DWORD *)(result + 36) + 4;
      if ( v18 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 4);
        v290 = desta;
        v291 = BYTE1(desta);
        LOBYTE(desta) = BYTE3(desta);
        BYTE3(desta) = v290;
        BYTE1(desta) = BYTE2(desta);
        BYTE2(desta) = v291;
      }
      else
      {
        v19 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v18;
        v20 = v19[1] + v18;
        LOBYTE(desta) = *(_BYTE *)(v20 - 1);
        BYTE1(desta) = *(_BYTE *)(v20 - 2);
        BYTE2(desta) = *(_BYTE *)(v20 - 3);
        BYTE3(desta) = *(_BYTE *)(v20 - 4);
      }
      *(_DWORD *)dest |= (8 * desta) & 0xFFFFE0 | ((desta & 3) << 29);
      return result;
    case 15:
      *(_BYTE *)dest = *a4;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 120LL);
      desta = 0LL;
      v21 = *(_DWORD *)(result + 36) + 1;
      if ( v21 >= *(_DWORD *)(result + 40) )
      {
        v316 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v316;
      }
      else
      {
        v22 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v21;
        LOBYTE(desta) = *(_BYTE *)(v22[1] + v21 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 6;
      desta = 0LL;
      v23 = *(_DWORD *)(result + 36) + 1;
      if ( v23 >= *(_DWORD *)(result + 40) )
      {
        v317 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v317;
      }
      else
      {
        v24 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v23;
        LOBYTE(desta) = *(_BYTE *)(v24[1] + v23 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 14;
      desta = 0LL;
      v25 = *(_DWORD *)(result + 36) + 1;
      if ( v25 >= *(_DWORD *)(result + 40) )
      {
        v318 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v318;
      }
      else
      {
        v26 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v25;
        LOBYTE(desta) = *(_BYTE *)(v26[1] + v25 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 30;
      desta = 0LL;
      v27 = *(_DWORD *)(result + 36) + 2;
      if ( v27 >= *(_DWORD *)(result + 40) )
      {
        v319 = result;
        sub_14CB0((__int64 **)result, &desta, 2);
        v292 = desta;
        result = v319;
        LOBYTE(desta) = BYTE1(desta);
        BYTE1(desta) = v292;
      }
      else
      {
        v28 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v27;
        v29 = v28[1] + v27;
        LOBYTE(desta) = *(_BYTE *)(v29 - 1);
        BYTE1(desta) = *(_BYTE *)(v29 - 2);
      }
      *(_DWORD *)dest |= 32 * desta;
      desta = 0LL;
      v30 = *(_DWORD *)(result + 36) + 1;
      if ( v30 >= *(_DWORD *)(result + 40) )
      {
        v320 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v320;
      }
      else
      {
        v31 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v30;
        LOBYTE(desta) = *(_BYTE *)(v31[1] + v30 - 1);
      }
      v32 = *(_DWORD *)dest | ((_DWORD)desta << 20);
      goto LABEL_256;
    case 16:
      *(_BYTE *)dest = *a4;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 128LL);
      goto LABEL_116;
    case 17:
      *(_BYTE *)dest = *a4;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 136LL);
      goto LABEL_116;
    case 18:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 144LL);
      desta = 0LL;
      v33 = *(_DWORD *)(result + 36) + 2;
      if ( v33 >= *(_DWORD *)(result + 40) )
      {
        v321 = result;
        sub_14CB0((__int64 **)result, &desta, 2);
        v293 = desta;
        result = v321;
        LOBYTE(desta) = BYTE1(desta);
        BYTE1(desta) = v293;
      }
      else
      {
        v34 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v33;
        v35 = v34[1] + v33;
        LOBYTE(desta) = *(_BYTE *)(v35 - 1);
        BYTE1(desta) = *(_BYTE *)(v35 - 2);
      }
      *(_DWORD *)dest |= 32 * desta;
      desta = 0LL;
      v36 = *(_DWORD *)(result + 36) + 1;
      if ( v36 >= *(_DWORD *)(result + 40) )
      {
        v322 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v322;
      }
      else
      {
        v37 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v36;
        LOBYTE(desta) = *(_BYTE *)(v37[1] + v36 - 1);
      }
      *(_DWORD *)dest |= 8 * desta;
      desta = 0LL;
      v38 = *(_DWORD *)(result + 36) + 1;
      if ( v38 >= *(_DWORD *)(result + 40) )
      {
        v323 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v323;
      }
      else
      {
        v39 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v38;
        LOBYTE(desta) = *(_BYTE *)(v39[1] + v38 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 20;
      desta = 0LL;
      v40 = *(_DWORD *)(result + 36) + 1;
      if ( v40 >= *(_DWORD *)(result + 40) )
      {
        v324 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v324;
      }
      else
      {
        v41 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v40;
        LOBYTE(desta) = *(_BYTE *)(v41[1] + v40 - 1);
      }
      *(_DWORD *)dest |= desta;
      desta = 0LL;
      v42 = *(_DWORD *)(result + 36) + 1;
      if ( v42 >= *(_DWORD *)(result + 40) )
      {
        v325 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v325;
      }
      else
      {
        v43 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v42;
        LOBYTE(desta) = *(_BYTE *)(v43[1] + v42 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 13;
      desta = 0LL;
      v44 = *(_DWORD *)(result + 36) + 2;
      if ( v44 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 2);
        v294 = desta;
        LOBYTE(desta) = BYTE1(desta);
        BYTE1(desta) = v294;
      }
      else
      {
        v45 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v44;
        v46 = v45[1] + v44;
        LOBYTE(desta) = *(_BYTE *)(v46 - 1);
        BYTE1(desta) = *(_BYTE *)(v46 - 2);
      }
      goto LABEL_99;
    case 19:
      *(_BYTE *)dest = *a4;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 152LL);
      goto LABEL_94;
    case 20:
    case 29:
    case 76:
    case 145:
    case 170:
    case 195:
      desta = 0LL;
      desta = *a4;
      goto LABEL_118;
    case 21:
      *(_BYTE *)dest = *a4;
      v47 = *(_QWORD *)(*(_QWORD *)(result + 16) + 160LL);
      desta = 0LL;
      v48 = *(_DWORD *)(v47 + 36) + 1;
      if ( v48 >= *(_DWORD *)(v47 + 40) )
      {
        v326 = result;
        sub_14CB0((__int64 **)v47, &desta, 1);
        result = v326;
      }
      else
      {
        v49 = *(__int64 **)v47;
        *(_DWORD *)(v47 + 36) = v48;
        LOBYTE(desta) = *(_BYTE *)(v49[1] + v48 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 19;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 168LL);
      goto LABEL_90;
    case 22:
      *(_BYTE *)dest = *a4;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 176LL);
      goto LABEL_116;
    case 23:
      *(_BYTE *)dest = *a4;
      v50 = *(_QWORD *)(*(_QWORD *)(result + 16) + 184LL);
      desta = 0LL;
      v51 = *(_DWORD *)(v50 + 36) + 2;
      if ( v51 >= *(_DWORD *)(v50 + 40) )
      {
        v327 = result;
        sub_14CB0((__int64 **)v50, &desta, 2);
        v295 = desta;
        result = v327;
        LOBYTE(desta) = BYTE1(desta);
        BYTE1(desta) = v295;
      }
      else
      {
        v52 = *(__int64 **)v50;
        *(_DWORD *)(v50 + 36) = v51;
        v53 = v52[1] + v51;
        LOBYTE(desta) = *(_BYTE *)(v53 - 1);
        BYTE1(desta) = *(_BYTE *)(v53 - 2);
      }
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 192LL);
      goto LABEL_97;
    case 24:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 200LL);
      goto LABEL_233;
    case 25:
      *(_BYTE *)dest = *a4;
      v54 = *(_QWORD *)(*(_QWORD *)(result + 16) + 208LL);
      desta = 0LL;
      v55 = *(_DWORD *)(v54 + 36) + 1;
      if ( v55 >= *(_DWORD *)(v54 + 40) )
      {
        v328 = result;
        sub_14CB0((__int64 **)v54, &desta, 1);
        result = v328;
      }
      else
      {
        v56 = *(__int64 **)v54;
        *(_DWORD *)(v54 + 36) = v55;
        LOBYTE(desta) = *(_BYTE *)(v56[1] + v55 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 19;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 216LL);
      goto LABEL_90;
    case 26:
      *(_BYTE *)dest = *a4;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 224LL);
      goto LABEL_116;
    case 27:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 232LL);
      goto LABEL_233;
    case 28:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 240LL);
      goto LABEL_385;
    case 30:
      *(_BYTE *)dest = *a4;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 248LL);
      goto LABEL_120;
    case 31:
    case 124:
      *(_BYTE *)dest = *a4;
      return result;
    case 32:
      *(_BYTE *)dest = *a4;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 256LL);
      desta = 0LL;
      v57 = *(_DWORD *)(result + 36) + 1;
      if ( v57 >= *(_DWORD *)(result + 40) )
      {
        v329 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v329;
      }
      else
      {
        v58 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v57;
        LOBYTE(desta) = *(_BYTE *)(v58[1] + v57 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 17;
      desta = 0LL;
      v59 = *(_DWORD *)(result + 36) + 2;
      if ( v59 >= *(_DWORD *)(result + 40) )
      {
        v330 = result;
        sub_14CB0((__int64 **)result, &desta, 2);
        v296 = desta;
        result = v330;
        LOBYTE(desta) = BYTE1(desta);
        BYTE1(desta) = v296;
      }
      else
      {
        v60 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v59;
        v61 = v60[1] + v59;
        LOBYTE(desta) = *(_BYTE *)(v61 - 1);
        BYTE1(desta) = *(_BYTE *)(v61 - 2);
      }
      *(_DWORD *)dest |= 32 * desta;
      desta = 0LL;
      v62 = *(_DWORD *)(result + 36) + 1;
      if ( v62 >= *(_DWORD *)(result + 40) )
      {
        v331 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v331;
      }
      else
      {
        v63 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v62;
        LOBYTE(desta) = *(_BYTE *)(v63[1] + v62 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 16;
      desta = 0LL;
      v64 = *(_DWORD *)(result + 36) + 2;
      if ( v64 >= *(_DWORD *)(result + 40) )
      {
        v332 = result;
        sub_14CB0((__int64 **)result, &desta, 2);
        v297 = desta;
        result = v332;
        LOBYTE(desta) = BYTE1(desta);
        BYTE1(desta) = v297;
      }
      else
      {
        v65 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v64;
        v66 = v65[1] + v64;
        LOBYTE(desta) = *(_BYTE *)(v66 - 1);
        BYTE1(desta) = *(_BYTE *)(v66 - 2);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 6;
      desta = 0LL;
      v67 = *(_DWORD *)(result + 36) + 2;
      if ( v67 >= *(_DWORD *)(result + 40) )
      {
        v333 = result;
        sub_14CB0((__int64 **)result, &desta, 2);
        v298 = desta;
        result = v333;
        LOBYTE(desta) = BYTE1(desta);
        BYTE1(desta) = v298;
      }
      else
      {
        v68 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v67;
        v69 = v68[1] + v67;
        LOBYTE(desta) = *(_BYTE *)(v69 - 1);
        BYTE1(desta) = *(_BYTE *)(v69 - 2);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 20;
      desta = 0LL;
      v70 = *(_DWORD *)(result + 36) + 1;
      if ( v70 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 1);
      }
      else
      {
        v71 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v70;
        LOBYTE(desta) = *(_BYTE *)(v71[1] + v70 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 22;
      return result;
    case 33:
      *(_BYTE *)dest = *a4;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 264LL);
LABEL_90:
      desta = 0LL;
      v72 = *(_DWORD *)(result + 36) + 2;
      if ( v72 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 2);
        v283 = desta;
        LOBYTE(desta) = BYTE1(desta);
        BYTE1(desta) = v283;
      }
      else
      {
        v73 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v72;
        v74 = v73[1] + v72;
        LOBYTE(desta) = *(_BYTE *)(v74 - 1);
        BYTE1(desta) = *(_BYTE *)(v74 - 2);
      }
      goto LABEL_118;
    case 34:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 272LL);
      goto LABEL_395;
    case 35:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 280LL);
LABEL_94:
      desta = 0LL;
      v75 = *(_DWORD *)(result + 36) + 2;
      if ( v75 >= *(_DWORD *)(result + 40) )
      {
        v314 = result;
        sub_14CB0((__int64 **)result, &desta, 2);
        v286 = desta;
        result = v314;
        LOBYTE(desta) = BYTE1(desta);
        BYTE1(desta) = v286;
      }
      else
      {
        v76 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v75;
        v77 = v76[1] + v75;
        LOBYTE(desta) = *(_BYTE *)(v77 - 1);
        BYTE1(desta) = *(_BYTE *)(v77 - 2);
      }
      *(_DWORD *)dest |= 32 * desta;
LABEL_97:
      desta = 0LL;
      v78 = *(_DWORD *)(result + 36) + 1;
      if ( v78 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 1);
      }
      else
      {
        v79 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v78;
        LOBYTE(desta) = *(_BYTE *)(v79[1] + v78 - 1);
      }
LABEL_99:
      *(_DWORD *)dest |= (_DWORD)desta << 21;
      return result;
    case 36:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= 2 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 288LL);
      desta = 0LL;
      v80 = *(_DWORD *)(result + 36) + 1;
      if ( v80 >= *(_DWORD *)(result + 40) )
      {
        v334 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v334;
      }
      else
      {
        v81 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v80;
        LOBYTE(desta) = *(_BYTE *)(v81[1] + v80 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 15;
      desta = 0LL;
      v82 = *(_DWORD *)(result + 36) + 1;
      if ( v82 >= *(_DWORD *)(result + 40) )
      {
        v335 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v335;
      }
      else
      {
        v83 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v82;
        LOBYTE(desta) = *(_BYTE *)(v83[1] + v82 - 1);
      }
      *(_DWORD *)dest |= 32 * desta;
      desta = 0LL;
      v84 = *(_DWORD *)(result + 36) + 2;
      if ( v84 >= *(_DWORD *)(result + 40) )
      {
        v336 = result;
        sub_14CB0((__int64 **)result, &desta, 2);
        v299 = desta;
        result = v336;
        LOBYTE(desta) = BYTE1(desta);
        BYTE1(desta) = v299;
      }
      else
      {
        v85 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v84;
        v86 = v85[1] + v84;
        LOBYTE(desta) = *(_BYTE *)(v86 - 1);
        BYTE1(desta) = *(_BYTE *)(v86 - 2);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 11;
      desta = 0LL;
      v87 = *(_DWORD *)(result + 36) + 4;
      if ( v87 >= *(_DWORD *)(result + 40) )
      {
        v337 = result;
        sub_14CB0((__int64 **)result, &desta, 4);
        v300 = desta;
        v301 = BYTE1(desta);
        result = v337;
        LOBYTE(desta) = BYTE3(desta);
        BYTE3(desta) = v300;
        BYTE1(desta) = BYTE2(desta);
        BYTE2(desta) = v301;
      }
      else
      {
        v88 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v87;
        v89 = v88[1] + v87;
        LOBYTE(desta) = *(_BYTE *)(v89 - 1);
        BYTE1(desta) = *(_BYTE *)(v89 - 2);
        BYTE2(desta) = *(_BYTE *)(v89 - 3);
        BYTE3(desta) = *(_BYTE *)(v89 - 4);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 6;
      desta = 0LL;
      v90 = *(_DWORD *)(result + 36) + 1;
      if ( v90 >= *(_DWORD *)(result + 40) )
      {
        v338 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v338;
      }
      else
      {
        v91 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v90;
        LOBYTE(desta) = *(_BYTE *)(v91[1] + v90 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 20;
      desta = 0LL;
      v92 = *(_DWORD *)(result + 36) + 1;
      if ( v92 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 1);
      }
      else
      {
        v93 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v92;
        LOBYTE(desta) = *(_BYTE *)(v93[1] + v92 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 30;
      return result;
    case 37:
      *(_BYTE *)dest = *a4;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 296LL);
      goto LABEL_116;
    case 38:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 304LL);
      goto LABEL_233;
    case 39:
      *(_BYTE *)dest = *a4;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 312LL);
LABEL_116:
      desta = 0LL;
      v94 = *(_DWORD *)(result + 36) + 4;
      if ( v94 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 4);
        v281 = desta;
        v282 = BYTE1(desta);
        LOBYTE(desta) = BYTE3(desta);
        BYTE3(desta) = v281;
        BYTE1(desta) = BYTE2(desta);
        BYTE2(desta) = v282;
      }
      else
      {
        v95 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v94;
        v96 = v95[1] + v94;
        LOBYTE(desta) = *(_BYTE *)(v96 - 1);
        BYTE1(desta) = *(_BYTE *)(v96 - 2);
        BYTE2(desta) = *(_BYTE *)(v96 - 3);
        BYTE3(desta) = *(_BYTE *)(v96 - 4);
      }
      goto LABEL_118;
    case 40:
      *(_BYTE *)dest = *a4;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 320LL);
LABEL_120:
      desta = 0LL;
      v97 = *(_DWORD *)(result + 36) + 1;
      if ( v97 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 1);
      }
      else
      {
        v98 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v97;
        LOBYTE(desta) = *(_BYTE *)(v98[1] + v97 - 1);
      }
      goto LABEL_118;
    case 41:
      *(_BYTE *)dest = *a4;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 328LL);
      goto LABEL_332;
    case 42:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= 2 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 336LL);
      desta = 0LL;
      v99 = *(_DWORD *)(result + 36) + 1;
      if ( v99 >= *(_DWORD *)(result + 40) )
      {
        v339 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v339;
      }
      else
      {
        v100 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v99;
        LOBYTE(desta) = *(_BYTE *)(v100[1] + v99 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 10;
      desta = 0LL;
      v101 = *(_DWORD *)(result + 36) + 1;
      if ( v101 >= *(_DWORD *)(result + 40) )
      {
        v340 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v340;
      }
      else
      {
        v102 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v101;
        LOBYTE(desta) = *(_BYTE *)(v102[1] + v101 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 30;
      desta = 0LL;
      v103 = *(_DWORD *)(result + 36) + 1;
      if ( v103 >= *(_DWORD *)(result + 40) )
      {
        v341 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v341;
      }
      else
      {
        v104 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v103;
        LOBYTE(desta) = *(_BYTE *)(v104[1] + v103 - 1);
      }
      *(_DWORD *)dest |= 32 * desta;
      desta = 0LL;
      v105 = *(_DWORD *)(result + 36) + 2;
      if ( v105 >= *(_DWORD *)(result + 40) )
      {
        v342 = result;
        sub_14CB0((__int64 **)result, &desta, 2);
        v302 = desta;
        result = v342;
        LOBYTE(desta) = BYTE1(desta);
        BYTE1(desta) = v302;
      }
      else
      {
        v106 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v105;
        v107 = v106[1] + v105;
        LOBYTE(desta) = *(_BYTE *)(v107 - 1);
        BYTE1(desta) = *(_BYTE *)(v107 - 2);
      }
      *(_DWORD *)dest |= ((_DWORD)desta << 19) & 0x280000 | (8 * desta) & 0x40C0;
      desta = 0LL;
      v108 = *(_DWORD *)(result + 36) + 1;
      if ( v108 >= *(_DWORD *)(result + 40) )
      {
        v343 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v343;
      }
      else
      {
        v109 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v108;
        LOBYTE(desta) = *(_BYTE *)(v109[1] + v108 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 15;
      desta = 0LL;
      v110 = *(_DWORD *)(result + 36) + 2;
      if ( v110 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 2);
        v303 = desta;
        LOBYTE(desta) = BYTE1(desta);
        BYTE1(desta) = v303;
      }
      else
      {
        v111 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v110;
        v112 = v111[1] + v110;
        LOBYTE(desta) = *(_BYTE *)(v112 - 1);
        BYTE1(desta) = *(_BYTE *)(v112 - 2);
      }
      goto LABEL_357;
    case 43:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= 32 * desta;
      v113 = *(_QWORD *)(*(_QWORD *)(result + 16) + 344LL);
      desta = 0LL;
      v114 = *(_DWORD *)(v113 + 36) + 1;
      if ( v114 >= *(_DWORD *)(v113 + 40) )
      {
        v344 = result;
        sub_14CB0((__int64 **)v113, &desta, 1);
        result = v344;
      }
      else
      {
        v115 = *(__int64 **)v113;
        *(_DWORD *)(v113 + 36) = v114;
        LOBYTE(desta) = *(_BYTE *)(v115[1] + v114 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 16;
      v116 = *(_QWORD *)(*(_QWORD *)(result + 16) + 352LL);
      desta = 0LL;
      v117 = *(_DWORD *)(v116 + 36) + 1;
      if ( v117 >= *(_DWORD *)(v116 + 40) )
      {
        v345 = result;
        sub_14CB0((__int64 **)v116, &desta, 1);
        result = v345;
      }
      else
      {
        v118 = *(__int64 **)v116;
        *(_DWORD *)(v116 + 36) = v117;
        LOBYTE(desta) = *(_BYTE *)(v118[1] + v117 - 1);
      }
      *(_DWORD *)dest |= 2 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 360LL);
      goto LABEL_385;
    case 44:
      *(_BYTE *)dest = *a4;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 368LL);
      goto LABEL_389;
    case 45:
    case 52:
    case 161:
      desta = 0LL;
      desta = *a4;
      v10 = *(_DWORD *)dest | desta;
      goto LABEL_13;
    case 46:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 376LL);
      goto LABEL_233;
    case 47:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 384LL);
      goto LABEL_233;
    case 48:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 392LL);
      goto LABEL_233;
    case 49:
    case 61:
    case 70:
    case 77:
    case 80:
    case 83:
    case 85:
    case 88:
    case 94:
    case 109:
    case 112:
    case 126:
    case 131:
    case 143:
    case 147:
    case 153:
    case 157:
    case 160:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      goto LABEL_118;
    case 50:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 400LL);
      goto LABEL_233;
    case 51:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 408LL);
      goto LABEL_233;
    case 53:
    case 63:
    case 64:
    case 86:
    case 99:
    case 100:
      desta = 0LL;
      desta = *a4;
      goto LABEL_294;
    case 54:
    case 67:
    case 163:
      desta = 0LL;
      desta = *a4;
      v10 = *(_DWORD *)dest | (32 * desta);
LABEL_13:
      *(_DWORD *)dest = v10;
      *((_BYTE *)dest + 2) = a4[1];
      return result;
    case 55:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 416LL);
      goto LABEL_332;
    case 56:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 424LL);
      goto LABEL_332;
    case 57:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 432LL);
      goto LABEL_339;
    case 58:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 440LL);
      goto LABEL_339;
    case 59:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 448LL);
      goto LABEL_395;
    case 60:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 456LL);
      goto LABEL_233;
    case 62:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 464LL);
      goto LABEL_233;
    case 65:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 472LL);
      goto LABEL_233;
    case 66:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 480LL);
      goto LABEL_233;
    case 68:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 488LL);
      goto LABEL_233;
    case 69:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 496LL);
      goto LABEL_233;
    case 71:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 504LL);
      goto LABEL_233;
    case 72:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 512LL);
      goto LABEL_233;
    case 73:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 520LL);
      goto LABEL_233;
    case 74:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 528LL);
      goto LABEL_233;
    case 75:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 536LL);
      goto LABEL_233;
    case 78:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 544LL);
      goto LABEL_233;
    case 79:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 552LL);
      goto LABEL_332;
    case 81:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 560LL);
      desta = 0LL;
      v119 = *(_DWORD *)(result + 36) + 1;
      if ( v119 >= *(_DWORD *)(result + 40) )
      {
        v346 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v346;
      }
      else
      {
        v120 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v119;
        LOBYTE(desta) = *(_BYTE *)(v120[1] + v119 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 16;
      desta = 0LL;
      v121 = *(_DWORD *)(result + 36) + 1;
      if ( v121 >= *(_DWORD *)(result + 40) )
      {
        v347 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v347;
      }
      else
      {
        v122 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v121;
        LOBYTE(desta) = *(_BYTE *)(v122[1] + v121 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 17;
      goto LABEL_395;
    case 82:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 568LL);
      goto LABEL_233;
    case 84:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 576LL);
      goto LABEL_395;
    case 87:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 584LL);
      goto LABEL_339;
    case 89:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 592LL);
      goto LABEL_233;
    case 90:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 600LL);
      goto LABEL_233;
    case 91:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 608LL);
      goto LABEL_385;
    case 92:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 616LL);
      goto LABEL_233;
    case 93:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 624LL);
      goto LABEL_385;
    case 95:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 632LL);
      goto LABEL_233;
    case 96:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 640LL);
      goto LABEL_339;
    case 97:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 648LL);
      goto LABEL_233;
    case 98:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 656LL);
      goto LABEL_395;
    case 101:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 664LL);
      goto LABEL_233;
    case 102:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 672LL);
      goto LABEL_233;
    case 103:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 680LL);
      goto LABEL_233;
    case 104:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 688LL);
      goto LABEL_233;
    case 105:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 696LL);
      goto LABEL_233;
    case 106:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 704LL);
      goto LABEL_233;
    case 107:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 712LL);
      goto LABEL_233;
    case 108:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 720LL);
      goto LABEL_395;
    case 110:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 728LL);
      goto LABEL_233;
    case 111:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 736LL);
      goto LABEL_395;
    case 113:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 744LL);
      goto LABEL_385;
    case 114:
    case 141:
    case 162:
    case 165:
      desta = 0LL;
      v9 = *a4;
      goto LABEL_293;
    case 115:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 752LL);
      goto LABEL_233;
    case 116:
      *(_BYTE *)dest = *a4;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 760LL);
      desta = 0LL;
      v123 = *(_DWORD *)(result + 36) + 1;
      if ( v123 >= *(_DWORD *)(result + 40) )
      {
        v348 = a4;
        result = sub_14CB0((__int64 **)result, &desta, 1);
        a4 = v348;
      }
      else
      {
        v124 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v123;
        LOBYTE(desta) = *(_BYTE *)(v124[1] + v123 - 1);
      }
      v7 = *(_DWORD *)dest | ((_DWORD)desta << 20);
      *(_DWORD *)dest = v7;
      desta = 0LL;
      v8 = a4[1];
      goto LABEL_9;
    case 117:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      v125 = (char *)dest + 2;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 768LL);
      v126 = *(_DWORD *)(result + 36) + 1;
      if ( v126 >= *(_DWORD *)(result + 40) )
      {
        v349 = result;
        sub_14CB0((__int64 **)result, v125, 1);
        result = v349;
      }
      else
      {
        v127 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v126;
        *v125 = *(_BYTE *)(v127[1] + v126 - 1);
      }
      goto LABEL_395;
    case 118:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 776LL);
      goto LABEL_389;
    case 119:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 784LL);
      goto LABEL_385;
    case 120:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 792LL);
      goto LABEL_389;
    case 121:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 800LL);
      desta = 0LL;
      v128 = *(_DWORD *)(result + 36) + 1;
      if ( v128 >= *(_DWORD *)(result + 40) )
      {
        v350 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v350;
      }
      else
      {
        v129 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v128;
        LOBYTE(desta) = *(_BYTE *)(v129[1] + v128 - 1);
      }
      v130 = *(_DWORD *)dest | ((_DWORD)desta << 18);
      goto LABEL_324;
    case 122:
      desta = 0LL;
      v5 = *(_DWORD *)dest | *a4;
      goto LABEL_299;
    case 123:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      v131 = (char *)dest + 2;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 808LL);
      goto LABEL_228;
    case 125:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 816LL);
      goto LABEL_395;
    case 127:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 824LL);
      goto LABEL_339;
    case 128:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 832LL);
      goto LABEL_385;
    case 129:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      v132 = *(_QWORD *)(*(_QWORD *)(result + 16) + 840LL);
      desta = 0LL;
      v133 = *(_DWORD *)(v132 + 36) + 1;
      if ( v133 >= *(_DWORD *)(v132 + 40) )
      {
        v351 = result;
        sub_14CB0((__int64 **)v132, &desta, 1);
        result = v351;
      }
      else
      {
        v134 = *(__int64 **)v132;
        *(_DWORD *)(v132 + 36) = v133;
        LOBYTE(desta) = *(_BYTE *)(v134[1] + v133 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 16;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 848LL);
      goto LABEL_395;
    case 130:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 856LL);
      goto LABEL_395;
    case 132:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 864LL);
      goto LABEL_332;
    case 133:
      desta = 0LL;
      v135 = *(_DWORD *)dest | (2 * *a4);
      *(_DWORD *)dest = v135;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest = v135 | ((_DWORD)desta << 12);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 872LL);
      desta = 0LL;
      v136 = *(_DWORD *)(result + 36) + 1;
      if ( v136 >= *(_DWORD *)(result + 40) )
      {
        v352 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v352;
      }
      else
      {
        v137 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v136;
        LOBYTE(desta) = *(_BYTE *)(v137[1] + v136 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 11;
      desta = 0LL;
      v138 = *(_DWORD *)(result + 36) + 2;
      if ( v138 >= *(_DWORD *)(result + 40) )
      {
        v353 = result;
        sub_14CB0((__int64 **)result, &desta, 2);
        v304 = desta;
        result = v353;
        LOBYTE(desta) = BYTE1(desta);
        BYTE1(desta) = v304;
      }
      else
      {
        v139 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v138;
        v140 = v139[1] + v138;
        LOBYTE(desta) = *(_BYTE *)(v140 - 1);
        BYTE1(desta) = *(_BYTE *)(v140 - 2);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 6;
      desta = 0LL;
      v141 = *(_DWORD *)(result + 36) + 1;
      if ( v141 >= *(_DWORD *)(result + 40) )
      {
        v354 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v354;
      }
      else
      {
        v142 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v141;
        LOBYTE(desta) = *(_BYTE *)(v142[1] + v141 - 1);
      }
      v143 = *(_DWORD *)dest | ((_DWORD)desta << 10);
      goto LABEL_291;
    case 134:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 880LL);
      goto LABEL_385;
    case 135:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 888LL);
      goto LABEL_395;
    case 136:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 896LL);
      goto LABEL_389;
    case 137:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 904LL);
      goto LABEL_233;
    case 138:
      desta = 0LL;
      v5 = *(_DWORD *)dest | (32 * *a4);
      goto LABEL_299;
    case 139:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 912LL);
      goto LABEL_385;
    case 140:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      v131 = (char *)dest + 2;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 920LL);
LABEL_228:
      v144 = *(_DWORD *)(result + 36) + 1;
      if ( v144 >= *(_DWORD *)(result + 40) )
        return sub_14CB0((__int64 **)result, v131, 1);
      v145 = *(__int64 **)result;
      *(_DWORD *)(result + 36) = v144;
      *v131 = *(_BYTE *)(v145[1] + v144 - 1);
      return result;
    case 142:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 928LL);
      goto LABEL_385;
    case 144:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 936LL);
      goto LABEL_385;
    case 146:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 944LL);
LABEL_233:
      desta = 0LL;
      v146 = *(_DWORD *)(result + 36) + 2;
      if ( v146 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 2);
        v280 = desta;
        LOBYTE(desta) = BYTE1(desta);
        BYTE1(desta) = v280;
      }
      else
      {
        v147 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v146;
        v148 = v147[1] + v146;
        LOBYTE(desta) = *(_BYTE *)(v148 - 1);
        BYTE1(desta) = *(_BYTE *)(v148 - 2);
      }
      goto LABEL_397;
    case 148:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= 32 * desta;
      *((_BYTE *)dest + 2) = a4[1];
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 952LL);
      goto LABEL_377;
    case 149:
      desta = 0LL;
      v149 = *(_DWORD *)dest | *a4;
      *(_DWORD *)dest = v149;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest = v149 | (32 * desta);
      v150 = *(_QWORD *)(*(_QWORD *)(result + 16) + 960LL);
      desta = 0LL;
      v151 = *(_DWORD *)(v150 + 36) + 2;
      if ( v151 >= *(_DWORD *)(v150 + 40) )
      {
        v307 = v150;
        v355 = result;
        sub_14CB0((__int64 **)v150, &desta, 2);
        v305 = desta;
        v150 = v307;
        result = v355;
        LOBYTE(desta) = BYTE1(desta);
        BYTE1(desta) = v305;
      }
      else
      {
        v152 = *(__int64 **)v150;
        *(_DWORD *)(v150 + 36) = v151;
        v153 = v152[1] + v151;
        LOBYTE(desta) = *(_BYTE *)(v153 - 1);
        BYTE1(desta) = *(_BYTE *)(v153 - 2);
      }
      *(_DWORD *)dest |= (((_DWORD)desta << 18) | ((_DWORD)desta << 10)) & 0x140800;
      desta = 0LL;
      v154 = *(_DWORD *)(v150 + 36) + 1;
      if ( v154 >= *(_DWORD *)(v150 + 40) )
      {
        v308 = v150;
        v356 = result;
        sub_14CB0((__int64 **)v150, &desta, 1);
        v150 = v308;
        result = v356;
      }
      else
      {
        v155 = *(__int64 **)v150;
        *(_DWORD *)(v150 + 36) = v154;
        LOBYTE(desta) = *(_BYTE *)(v155[1] + v154 - 1);
      }
      *(_DWORD *)dest |= 16 * desta;
      desta = 0LL;
      v156 = *(_DWORD *)(v150 + 36) + 1;
      if ( v156 >= *(_DWORD *)(v150 + 40) )
      {
        v309 = v150;
        v357 = result;
        sub_14CB0((__int64 **)v150, &desta, 1);
        v150 = v309;
        result = v357;
      }
      else
      {
        v157 = *(__int64 **)v150;
        *(_DWORD *)(v150 + 36) = v156;
        LOBYTE(desta) = *(_BYTE *)(v157[1] + v156 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 14;
      desta = 0LL;
      v158 = *(_DWORD *)(v150 + 36) + 1;
      if ( v158 >= *(_DWORD *)(v150 + 40) )
      {
        v310 = v150;
        v358 = result;
        sub_14CB0((__int64 **)v150, &desta, 1);
        v150 = v310;
        result = v358;
      }
      else
      {
        v159 = *(__int64 **)v150;
        *(_DWORD *)(v150 + 36) = v158;
        LOBYTE(desta) = *(_BYTE *)(v159[1] + v158 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 17;
      desta = 0LL;
      v160 = *(_DWORD *)(v150 + 36) + 1;
      if ( v160 >= *(_DWORD *)(v150 + 40) )
      {
        v359 = result;
        sub_14CB0((__int64 **)v150, &desta, 1);
        result = v359;
      }
      else
      {
        v161 = *(__int64 **)v150;
        *(_DWORD *)(v150 + 36) = v160;
        LOBYTE(desta) = *(_BYTE *)(v161[1] + v160 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 12;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 968LL);
      goto LABEL_395;
    case 150:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 976LL);
      desta = 0LL;
      v162 = *(_DWORD *)(result + 36) + 2;
      if ( v162 >= *(_DWORD *)(result + 40) )
      {
        v360 = result;
        sub_14CB0((__int64 **)result, &desta, 2);
        v306 = desta;
        result = v360;
        LOBYTE(desta) = BYTE1(desta);
        BYTE1(desta) = v306;
      }
      else
      {
        v163 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v162;
        v164 = v163[1] + v162;
        LOBYTE(desta) = *(_BYTE *)(v164 - 1);
        BYTE1(desta) = *(_BYTE *)(v164 - 2);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 12;
      desta = 0LL;
      v165 = *(_DWORD *)(result + 36) + 1;
      if ( v165 >= *(_DWORD *)(result + 40) )
      {
        v361 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v361;
      }
      else
      {
        v166 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v165;
        LOBYTE(desta) = *(_BYTE *)(v166[1] + v165 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 8;
      desta = 0LL;
      v167 = *(_DWORD *)(result + 36) + 1;
      if ( v167 >= *(_DWORD *)(result + 40) )
      {
        v362 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v362;
      }
      else
      {
        v168 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v167;
        LOBYTE(desta) = *(_BYTE *)(v168[1] + v167 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 11;
      desta = 0LL;
      v169 = *(_DWORD *)(result + 36) + 1;
      if ( v169 >= *(_DWORD *)(result + 40) )
      {
        v363 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v363;
      }
      else
      {
        v170 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v169;
        LOBYTE(desta) = *(_BYTE *)(v170[1] + v169 - 1);
      }
      v32 = *(_DWORD *)dest | ((_DWORD)desta << 18);
LABEL_256:
      *(_DWORD *)dest = v32;
      desta = 0LL;
      v171 = *(_DWORD *)(result + 36) + 1;
      if ( v171 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 1);
      }
      else
      {
        v172 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v171;
        LOBYTE(desta) = *(_BYTE *)(v172[1] + v171 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 7;
      return result;
    case 151:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      v173 = (char *)dest + 2;
      v174 = *(_QWORD *)(*(_QWORD *)(result + 16) + 984LL);
      v175 = *(_DWORD *)(v174 + 36) + 1;
      if ( v175 >= *(_DWORD *)(v174 + 40) )
      {
        v364 = result;
        sub_14CB0((__int64 **)v174, v173, 1);
        result = v364;
      }
      else
      {
        v176 = *(__int64 **)v174;
        *(_DWORD *)(v174 + 36) = v175;
        *v173 = *(_BYTE *)(v176[1] + v175 - 1);
      }
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 992LL);
      goto LABEL_395;
    case 152:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1000LL);
      desta = 0LL;
      v177 = *(_DWORD *)(result + 36) + 1;
      if ( v177 >= *(_DWORD *)(result + 40) )
      {
        v365 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v365;
      }
      else
      {
        v178 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v177;
        LOBYTE(desta) = *(_BYTE *)(v178[1] + v177 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 11;
      desta = 0LL;
      v179 = *(_DWORD *)(result + 36) + 1;
      if ( v179 >= *(_DWORD *)(result + 40) )
      {
        v366 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v366;
      }
      else
      {
        v180 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v179;
        LOBYTE(desta) = *(_BYTE *)(v180[1] + v179 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 12;
      goto LABEL_395;
    case 154:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1008LL);
      goto LABEL_385;
    case 156:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1016LL);
      goto LABEL_332;
    case 159:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1024LL);
      desta = 0LL;
      v181 = *(_DWORD *)(result + 36) + 1;
      if ( v181 >= *(_DWORD *)(result + 40) )
      {
        v367 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v367;
      }
      else
      {
        v182 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v181;
        LOBYTE(desta) = *(_BYTE *)(v182[1] + v181 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 12;
      desta = 0LL;
      v183 = *(_DWORD *)(result + 36) + 1;
      if ( v183 >= *(_DWORD *)(result + 40) )
      {
        v368 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v368;
      }
      else
      {
        v184 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v183;
        LOBYTE(desta) = *(_BYTE *)(v184[1] + v183 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 16;
      desta = 0LL;
      v185 = *(_DWORD *)(result + 36) + 1;
      if ( v185 >= *(_DWORD *)(result + 40) )
      {
        v369 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v369;
      }
      else
      {
        v186 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v185;
        LOBYTE(desta) = *(_BYTE *)(v186[1] + v185 - 1);
      }
      v187 = *(_DWORD *)dest | ((_DWORD)desta << 17);
      goto LABEL_354;
    case 164:
      desta = 0LL;
      v188 = *(_DWORD *)dest | (8 * *a4);
      *(_DWORD *)dest = v188;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest = v188 | ((_DWORD)desta << 6);
      v189 = *(_QWORD *)(*(_QWORD *)(result + 16) + 1032LL);
      desta = 0LL;
      v190 = *(_DWORD *)(v189 + 36) + 1;
      if ( v190 >= *(_DWORD *)(v189 + 40) )
      {
        v311 = v189;
        v370 = result;
        sub_14CB0((__int64 **)v189, &desta, 1);
        v189 = v311;
        result = v370;
      }
      else
      {
        v191 = *(__int64 **)v189;
        *(_DWORD *)(v189 + 36) = v190;
        LOBYTE(desta) = *(_BYTE *)(v191[1] + v190 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 18;
      desta = 0LL;
      v192 = *(_DWORD *)(v189 + 36) + 1;
      if ( v192 >= *(_DWORD *)(v189 + 40) )
      {
        v312 = v189;
        v371 = result;
        sub_14CB0((__int64 **)v189, &desta, 1);
        v189 = v312;
        result = v371;
      }
      else
      {
        v193 = *(__int64 **)v189;
        *(_DWORD *)(v189 + 36) = v192;
        LOBYTE(desta) = *(_BYTE *)(v193[1] + v192 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 13;
      desta = 0LL;
      v194 = *(_DWORD *)(v189 + 36) + 1;
      if ( v194 >= *(_DWORD *)(v189 + 40) )
      {
        v372 = result;
        sub_14CB0((__int64 **)v189, &desta, 1);
        result = v372;
      }
      else
      {
        v195 = *(__int64 **)v189;
        *(_DWORD *)(v189 + 36) = v194;
        LOBYTE(desta) = *(_BYTE *)(v195[1] + v194 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 15;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1040LL);
      desta = 0LL;
      v196 = *(_DWORD *)(result + 36) + 1;
      if ( v196 >= *(_DWORD *)(result + 40) )
      {
        v373 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v373;
      }
      else
      {
        v197 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v196;
        LOBYTE(desta) = *(_BYTE *)(v197[1] + v196 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 11;
      desta = 0LL;
      v198 = *(_DWORD *)(result + 36) + 1;
      if ( v198 >= *(_DWORD *)(result + 40) )
      {
        v374 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v374;
      }
      else
      {
        v199 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v198;
        LOBYTE(desta) = *(_BYTE *)(v199[1] + v198 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 14;
      desta = 0LL;
      v200 = *(_DWORD *)(result + 36) + 1;
      if ( v200 >= *(_DWORD *)(result + 40) )
      {
        v375 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v375;
      }
      else
      {
        v201 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v200;
        LOBYTE(desta) = *(_BYTE *)(v201[1] + v200 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 10;
      desta = 0LL;
      v202 = *(_DWORD *)(result + 36) + 1;
      if ( v202 >= *(_DWORD *)(result + 40) )
      {
        v376 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v376;
      }
      else
      {
        v203 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v202;
        LOBYTE(desta) = *(_BYTE *)(v203[1] + v202 - 1);
      }
      v143 = *(_DWORD *)dest | ((_DWORD)desta << 20);
LABEL_291:
      *(_DWORD *)dest = v143;
      desta = 0LL;
      v204 = *(_DWORD *)(result + 36) + 1;
      if ( v204 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 1);
      }
      else
      {
        v205 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v204;
        v9 = *(_BYTE *)(v205[1] + v204 - 1);
LABEL_293:
        LOBYTE(desta) = v9;
      }
LABEL_294:
      *(_DWORD *)dest |= desta;
      return result;
    case 166:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      v206 = *(_QWORD *)(*(_QWORD *)(result + 16) + 1048LL);
      desta = 0LL;
      v207 = *(_DWORD *)(v206 + 36) + 1;
      if ( v207 >= *(_DWORD *)(v206 + 40) )
      {
        v377 = result;
        sub_14CB0((__int64 **)v206, &desta, 1);
        result = v377;
      }
      else
      {
        v208 = *(__int64 **)v206;
        *(_DWORD *)(v206 + 36) = v207;
        LOBYTE(desta) = *(_BYTE *)(v208[1] + v207 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 16;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1056LL);
      goto LABEL_355;
    case 167:
      desta = 0LL;
      v5 = *(_DWORD *)dest | (*a4 << 6);
LABEL_299:
      *(_DWORD *)dest = v5;
      desta = 0LL;
      v6 = a4[1];
      goto LABEL_3;
    case 168:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1064LL);
      desta = 0LL;
      v209 = *(_DWORD *)(result + 36) + 1;
      if ( v209 >= *(_DWORD *)(result + 40) )
      {
        v378 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v378;
      }
      else
      {
        v210 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v209;
        LOBYTE(desta) = *(_BYTE *)(v210[1] + v209 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 11;
      desta = 0LL;
      v211 = *(_DWORD *)(result + 36) + 1;
      if ( v211 >= *(_DWORD *)(result + 40) )
      {
        v379 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v379;
      }
      else
      {
        v212 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v211;
        LOBYTE(desta) = *(_BYTE *)(v212[1] + v211 - 1);
      }
      *(_DWORD *)dest |= (((_DWORD)desta << 17) | ((_DWORD)desta << 21)) & 0x200000;
      desta = 0LL;
      v213 = *(_DWORD *)(result + 36) + 1;
      if ( v213 >= *(_DWORD *)(result + 40) )
      {
        v380 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v380;
      }
      else
      {
        v214 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v213;
        LOBYTE(desta) = *(_BYTE *)(v214[1] + v213 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 18;
      desta = 0LL;
      v215 = *(_DWORD *)(result + 36) + 1;
      if ( v215 >= *(_DWORD *)(result + 40) )
      {
        v381 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v381;
      }
      else
      {
        v216 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v215;
        LOBYTE(desta) = *(_BYTE *)(v216[1] + v215 - 1);
      }
      v217 = *(_DWORD *)dest | ((_DWORD)desta << 17);
      goto LABEL_327;
    case 169:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1072LL);
      goto LABEL_385;
    case 171:
      desta = 0LL;
      v218 = *(_DWORD *)dest | (2 * *a4);
      *(_DWORD *)dest = v218;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest = v218 | (32 * desta);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1080LL);
      desta = 0LL;
      v219 = *(_DWORD *)(result + 36) + 1;
      if ( v219 >= *(_DWORD *)(result + 40) )
      {
        v382 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v382;
      }
      else
      {
        v220 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v219;
        LOBYTE(desta) = *(_BYTE *)(v220[1] + v219 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 10;
      desta = 0LL;
      v221 = *(_DWORD *)(result + 36) + 1;
      if ( v221 >= *(_DWORD *)(result + 40) )
      {
        v383 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v383;
      }
      else
      {
        v222 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v221;
        LOBYTE(desta) = *(_BYTE *)(v222[1] + v221 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 12;
      v223 = (char *)dest + 2;
      v224 = *(_DWORD *)(result + 36) + 1;
      if ( v224 >= *(_DWORD *)(result + 40) )
      {
        v384 = result;
        sub_14CB0((__int64 **)result, v223, 1);
        result = v384;
      }
      else
      {
        v225 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v224;
        *v223 = *(_BYTE *)(v225[1] + v224 - 1);
      }
      goto LABEL_328;
    case 172:
      desta = 0LL;
      v226 = *(_DWORD *)dest | *a4;
      *(_DWORD *)dest = v226;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest = v226 | (32 * desta);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1088LL);
      goto LABEL_395;
    case 173:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1096LL);
      desta = 0LL;
      v227 = *(_DWORD *)(result + 36) + 1;
      if ( v227 >= *(_DWORD *)(result + 40) )
      {
        v385 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v385;
      }
      else
      {
        v228 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v227;
        LOBYTE(desta) = *(_BYTE *)(v228[1] + v227 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 18;
      desta = 0LL;
      v229 = *(_DWORD *)(result + 36) + 1;
      if ( v229 >= *(_DWORD *)(result + 40) )
      {
        v386 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v386;
      }
      else
      {
        v230 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v229;
        LOBYTE(desta) = *(_BYTE *)(v230[1] + v229 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 20;
      desta = 0LL;
      v231 = *(_DWORD *)(result + 36) + 1;
      if ( v231 >= *(_DWORD *)(result + 40) )
      {
        v387 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v387;
      }
      else
      {
        v232 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v231;
        LOBYTE(desta) = *(_BYTE *)(v232[1] + v231 - 1);
      }
      v130 = *(_DWORD *)dest | ((_DWORD)desta << 17);
LABEL_324:
      *(_DWORD *)dest = v130;
      desta = 0LL;
      v233 = *(_DWORD *)(result + 36) + 1;
      if ( v233 >= *(_DWORD *)(result + 40) )
      {
        v315 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v315;
      }
      else
      {
        v234 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v233;
        LOBYTE(desta) = *(_BYTE *)(v234[1] + v233 - 1);
      }
      v217 = *(_DWORD *)dest | ((_DWORD)desta << 16);
LABEL_327:
      *(_DWORD *)dest = v217;
LABEL_328:
      desta = 0LL;
      v235 = *(_DWORD *)(result + 36) + 1;
      if ( v235 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 1);
      }
      else
      {
        v236 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v235;
        LOBYTE(desta) = *(_BYTE *)(v236[1] + v235 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 19;
      return result;
    case 174:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1104LL);
LABEL_332:
      desta = 0LL;
      v237 = *(_DWORD *)(result + 36) + 1;
      if ( v237 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 1);
      }
      else
      {
        v238 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v237;
        LOBYTE(desta) = *(_BYTE *)(v238[1] + v237 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 14;
      return result;
    case 175:
      desta = 0LL;
      v239 = *(_DWORD *)dest | *a4;
      *(_DWORD *)dest = v239;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest = v239 | ((_DWORD)desta << 10);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1112LL);
      goto LABEL_389;
    case 176:
      desta = 0LL;
      v240 = *(_DWORD *)dest | *a4;
      *(_DWORD *)dest = v240;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest = v240 | ((_DWORD)desta << 10);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1120LL);
      goto LABEL_389;
    case 177:
      desta = 0LL;
      v241 = *(_DWORD *)dest | *a4;
      *(_DWORD *)dest = v241;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest = v241 | ((_DWORD)desta << 10);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1128LL);
      goto LABEL_339;
    case 178:
      desta = 0LL;
      v242 = *(_DWORD *)dest | *a4;
      *(_DWORD *)dest = v242;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest = v242 | ((_DWORD)desta << 10);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1136LL);
LABEL_339:
      desta = 0LL;
      v243 = *(_DWORD *)(result + 36) + 1;
      if ( v243 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 1);
      }
      else
      {
        v244 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v243;
        LOBYTE(desta) = *(_BYTE *)(v244[1] + v243 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 16;
      return result;
    case 179:
    case 181:
    case 182:
    case 188:
    case 190:
    case 197:
    case 198:
    case 212:
    case 215:
    case 217:
    case 218:
    case 248:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      *((_BYTE *)dest + 2) = a4[2];
      return result;
    case 180:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      *((_BYTE *)dest + 2) = a4[2];
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1144LL);
      goto LABEL_377;
    case 183:
    case 189:
    case 214:
    case 220:
    case 242:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      v7 = *(_DWORD *)dest | (a4[1] << 10);
      *(_DWORD *)dest = v7;
      desta = 0LL;
      v8 = a4[2];
LABEL_9:
      LOBYTE(desta) = v8;
      *(_DWORD *)dest = v7 | (32 * desta);
      return result;
    case 184:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      v245 = *(_DWORD *)dest | (a4[1] << 10);
      *(_DWORD *)dest = v245;
      desta = 0LL;
      desta = a4[2];
      *(_DWORD *)dest = v245 | (32 * desta);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1152LL);
      goto LABEL_389;
    case 185:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      v246 = *(_DWORD *)dest | (32 * a4[1]);
      *(_DWORD *)dest = v246;
      desta = 0LL;
      desta = a4[2];
      *(_DWORD *)dest = v246 | ((_DWORD)desta << 16);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1160LL);
      goto LABEL_385;
    case 186:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      v247 = *(_DWORD *)dest | (32 * a4[1]);
      *(_DWORD *)dest = v247;
      desta = 0LL;
      desta = a4[2];
      *(_DWORD *)dest = v247 | ((_DWORD)desta << 16);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1168LL);
      goto LABEL_385;
    case 187:
    case 194:
    case 196:
    case 200:
    case 202:
    case 204:
    case 205:
    case 206:
    case 209:
    case 219:
    case 221:
    case 222:
    case 224:
    case 228:
    case 232:
    case 236:
    case 243:
    case 244:
    case 247:
    case 252:
    case 253:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      v5 = *(_DWORD *)dest | (32 * a4[1]);
      *(_DWORD *)dest = v5;
      desta = 0LL;
      v6 = a4[2];
LABEL_3:
      LOBYTE(desta) = v6;
      *(_DWORD *)dest = v5 | ((_DWORD)desta << 16);
      return result;
    case 191:
    case 229:
    case 237:
      desta = 0LL;
      v11 = *(_DWORD *)dest | *a4;
      *(_DWORD *)dest = v11;
      desta = 0LL;
      *(_DWORD *)dest = v11 | (a4[1] << 10);
      return result;
    case 192:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      v248 = *(_DWORD *)dest | (a4[1] << 10);
      *(_DWORD *)dest = v248;
      desta = 0LL;
      desta = a4[2];
      *(_DWORD *)dest = v248 | (32 * desta);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1176LL);
      goto LABEL_389;
    case 193:
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1184LL);
      goto LABEL_389;
    case 199:
      desta = 0LL;
      v249 = *(_DWORD *)dest | *a4;
      *(_DWORD *)dest = v249;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest = v249 | ((_DWORD)desta << 10);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1192LL);
      goto LABEL_389;
    case 201:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      v250 = *(_DWORD *)dest | (32 * a4[1]);
      *(_DWORD *)dest = v250;
      desta = 0LL;
      desta = a4[2];
      *(_DWORD *)dest = v250 | ((_DWORD)desta << 16);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1200LL);
      desta = 0LL;
      v251 = *(_DWORD *)(result + 36) + 1;
      if ( v251 >= *(_DWORD *)(result + 40) )
      {
        v388 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v388;
      }
      else
      {
        v252 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v251;
        LOBYTE(desta) = *(_BYTE *)(v252[1] + v251 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 13;
      desta = 0LL;
      v253 = *(_DWORD *)(result + 36) + 1;
      if ( v253 >= *(_DWORD *)(result + 40) )
      {
        v389 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v389;
      }
      else
      {
        v254 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v253;
        LOBYTE(desta) = *(_BYTE *)(v254[1] + v253 - 1);
      }
      v187 = *(_DWORD *)dest | ((_DWORD)desta << 10);
LABEL_354:
      *(_DWORD *)dest = v187;
LABEL_355:
      desta = 0LL;
      v255 = *(_DWORD *)(result + 36) + 1;
      if ( v255 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 1);
      }
      else
      {
        v256 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v255;
        LOBYTE(desta) = *(_BYTE *)(v256[1] + v255 - 1);
      }
LABEL_357:
      *(_DWORD *)dest |= (_DWORD)desta << 11;
      return result;
    case 203:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      v257 = *(_DWORD *)dest | (a4[1] << 10);
      *(_DWORD *)dest = v257;
      desta = 0LL;
      desta = a4[2];
      *(_DWORD *)dest = v257 | (32 * desta);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1208LL);
      goto LABEL_389;
    case 207:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1216LL);
      goto LABEL_389;
    case 208:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1224LL);
      goto LABEL_389;
    case 210:
      desta = 0LL;
      v258 = *(_DWORD *)dest | *a4;
      *(_DWORD *)dest = v258;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest = v258 | ((_DWORD)desta << 16);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1232LL);
      goto LABEL_385;
    case 211:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      *((_BYTE *)dest + 2) = a4[2];
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1240LL);
      desta = 0LL;
      v259 = *(_DWORD *)(result + 36) + 1;
      if ( v259 >= *(_DWORD *)(result + 40) )
      {
        v390 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v390;
      }
      else
      {
        v260 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v259;
        LOBYTE(desta) = *(_BYTE *)(v260[1] + v259 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 22;
      desta = 0LL;
      v261 = *(_DWORD *)(result + 36) + 1;
      if ( v261 >= *(_DWORD *)(result + 40) )
      {
        v391 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v391;
      }
      else
      {
        v262 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v261;
        LOBYTE(desta) = *(_BYTE *)(v262[1] + v261 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 11;
      goto LABEL_395;
    case 213:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= (_DWORD)desta << 16;
      *(_BYTE *)dest = a4[1];
      desta = 0LL;
      desta = a4[2];
LABEL_118:
      *(_DWORD *)dest |= 32 * desta;
      return result;
    case 216:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      v263 = *(_DWORD *)dest | (a4[1] << 10);
      *(_DWORD *)dest = v263;
      desta = 0LL;
      desta = a4[2];
      *(_DWORD *)dest = v263 | (32 * desta);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1248LL);
      goto LABEL_389;
    case 223:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1256LL);
      goto LABEL_389;
    case 225:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      *((_BYTE *)dest + 2) = a4[2];
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1264LL);
      goto LABEL_377;
    case 226:
      desta = 0LL;
      v264 = *(_DWORD *)dest | (2 * *a4);
      *(_DWORD *)dest = v264;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest = v264 | ((_DWORD)desta << 11);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1272LL);
      goto LABEL_389;
    case 227:
      desta = 0LL;
      v265 = *(_DWORD *)dest | (*a4 << 11);
      *(_DWORD *)dest = v265;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest = v265 | (2 * desta);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1280LL);
      goto LABEL_389;
    case 230:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      v266 = *(_DWORD *)dest | (32 * a4[1]);
      *(_DWORD *)dest = v266;
      desta = 0LL;
      desta = a4[2];
      *(_DWORD *)dest = v266 | ((_DWORD)desta << 16);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1288LL);
      goto LABEL_389;
    case 231:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      v267 = *(_DWORD *)dest | (a4[1] << 10);
      *(_DWORD *)dest = v267;
      desta = 0LL;
      desta = a4[2];
      *(_DWORD *)dest = v267 | (32 * desta);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1296LL);
      goto LABEL_389;
    case 234:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1304LL);
      goto LABEL_385;
    case 235:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      *((_BYTE *)dest + 2) = a4[2];
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1312LL);
LABEL_377:
      desta = 0LL;
      v268 = *(_DWORD *)(result + 36) + 1;
      if ( v268 >= *(_DWORD *)(result + 40) )
      {
        v313 = result;
        sub_14CB0((__int64 **)result, &desta, 1);
        result = v313;
      }
      else
      {
        v269 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v268;
        LOBYTE(desta) = *(_BYTE *)(v269[1] + v268 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 22;
      goto LABEL_395;
    case 238:
      desta = 0LL;
      desta = *a4;
      *(_DWORD *)dest |= (_DWORD)desta << 10;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1320LL);
      goto LABEL_389;
    case 239:
      desta = 0LL;
      v270 = *(_DWORD *)dest | *a4;
      *(_DWORD *)dest = v270;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest = v270 | ((_DWORD)desta << 10);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1328LL);
      goto LABEL_389;
    case 240:
      desta = 0LL;
      v271 = *(_DWORD *)dest | *a4;
      *(_DWORD *)dest = v271;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest = v271 | ((_DWORD)desta << 10);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1336LL);
      goto LABEL_389;
    case 241:
      desta = 0LL;
      v272 = *(_DWORD *)dest | *a4;
      *(_DWORD *)dest = v272;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest = v272 | ((_DWORD)desta << 10);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1344LL);
      goto LABEL_389;
    case 245:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1352LL);
LABEL_385:
      desta = 0LL;
      v273 = *(_DWORD *)(result + 36) + 1;
      if ( v273 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 1);
      }
      else
      {
        v274 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v273;
        LOBYTE(desta) = *(_BYTE *)(v274[1] + v273 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 12;
      return result;
    case 246:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      v275 = *(_DWORD *)dest | (a4[1] << 10);
      *(_DWORD *)dest = v275;
      desta = 0LL;
      desta = a4[2];
      *(_DWORD *)dest = v275 | (32 * desta);
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1360LL);
LABEL_389:
      desta = 0LL;
      v276 = *(_DWORD *)(result + 36) + 1;
      if ( v276 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 1);
      }
      else
      {
        v277 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v276;
        LOBYTE(desta) = *(_BYTE *)(v277[1] + v276 - 1);
      }
      *(_DWORD *)dest |= (_DWORD)desta << 15;
      return result;
    case 249:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      *((_BYTE *)dest + 2) = a4[2];
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1368LL);
      goto LABEL_395;
    case 250:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      *((_BYTE *)dest + 2) = a4[2];
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1376LL);
      goto LABEL_395;
    case 251:
      *(_BYTE *)dest = *a4;
      desta = 0LL;
      desta = a4[1];
      *(_DWORD *)dest |= 32 * desta;
      *((_BYTE *)dest + 2) = a4[2];
      result = *(_QWORD *)(*(_QWORD *)(result + 16) + 1384LL);
LABEL_395:
      desta = 0LL;
      v278 = *(_DWORD *)(result + 36) + 1;
      if ( v278 >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &desta, 1);
      }
      else
      {
        v279 = *(__int64 **)result;
        *(_DWORD *)(result + 36) = v278;
        LOBYTE(desta) = *(_BYTE *)(v279[1] + v278 - 1);
      }
LABEL_397:
      *(_DWORD *)dest |= (_DWORD)desta << 10;
      break;
    default:
      return result;
  }
  return result;
}

//----- (000000000000BCF4) ----------------------------------------------------
void __fastcall sub_BCF4(__int64 a1, __int64 a2, void *dest, unsigned int a4)
{
  char *v4; // x22
  char *v5; // x21
  _DWORD *v7; // x23
  unsigned int v9; // w8
  unsigned int v10; // w25
  unsigned __int8 *v11; // x3
  int v12; // w8
  int v13; // w10
  int v14; // w9
  _QWORD *v15; // x0
  __int64 v16; // x10
  __int64 v17; // x9

  v4 = (char *)dest + a4;
  if ( v4 > dest )
  {
    v5 = (char *)dest;
    v7 = **(_DWORD ***)(a2 + 16);
    v10 = v7[9];
    v9 = v7[10];
    while ( v5 >= v4 || v10 >= v9 )
    {
      if ( v10 >= v9 )
      {
        v14 = 0;
LABEL_15:
        v15 = *(_QWORD **)v7;
        v10 = v10 - v9 + v14;
        v16 = **(_QWORD **)v7;
        **(_QWORD **)v7 = 0x100000LL;
        for ( *(_QWORD *)v7 = v16; ; *(_QWORD *)v7 = v17 )
        {
          sub_14954(v15);
          v9 = v7[10];
          v7[9] = 0;
          if ( v10 < v9 )
            break;
          v15 = *(_QWORD **)v7;
          v10 -= v9;
          v17 = **(_QWORD **)v7;
          **(_QWORD **)v7 = 0x100000LL;
        }
      }
LABEL_3:
      v7[9] = v10;
      if ( v5 >= v4 )
        return;
    }
    do
    {
      v11 = (unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)v7 + 8LL) + v10);
      v12 = v11[3];
      if ( v12 == 255 )
      {
        sub_6D4C(a1, (int)v5, v11[2], v11);
        v9 = v7[10];
        v10 += 4;
        if ( v5 >= v4 )
          break;
      }
      else
      {
        *(_DWORD *)v5 = qword_1B27F[v11[3]];
        sub_7C24(a2, v5, v12 - 1, v11);
        v5 += 4;
        v9 = v7[10];
        v10 += 4;
        if ( v5 >= v4 )
          break;
      }
    }
    while ( v10 < v9 );
    v13 = v7[9];
    v7[4] = v13 + v7[4] - v10;
    if ( v10 < v9 )
      goto LABEL_3;
    v14 = v10 - v13;
    v10 = v13;
    goto LABEL_15;
  }
}

//----- (000000000000BE60) ----------------------------------------------------
void __fastcall sub_BE60(__int64 a1, __int64 a2, void *dest, unsigned int a4)
{
  char *v4; // x22
  __int64 v5; // x8
  char *v6; // x21
  _DWORD *v7; // x23
  unsigned int v10; // w27
  unsigned int v11; // w8
  unsigned __int8 *v12; // x8
  __int64 v13; // x28
  int v14; // w0
  int v15; // w9
  unsigned int v16; // w9
  unsigned int v17; // w0
  _QWORD *v18; // x0
  __int64 v19; // x11
  unsigned int v20; // w8
  __int64 v21; // x9

  v4 = (char *)dest + a4;
  if ( v4 > dest )
  {
    v5 = *(_QWORD *)(a2 + 16);
    v6 = (char *)dest;
    v7 = *(_DWORD **)v5;
    v10 = *(_DWORD *)(*(_QWORD *)v5 + 36LL);
    do
    {
      v11 = v7[10];
      if ( v6 >= v4 || v10 >= v11 - 4 )
      {
        v16 = v10;
      }
      else
      {
        do
        {
          v12 = (unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)v7 + 8LL) + v10);
          v13 = *v12;
          if ( (_DWORD)v13 == 255 )
          {
            v14 = sub_6D4C(a1, (int)v6, v12[1], v12 + 2);
            v15 = 2;
          }
          else
          {
            *(_DWORD *)v6 = qword_1B27F[*v12];
            sub_7C24(a2, v6, v13 - 1, v12 + 1);
            v14 = byte_1B180[v13];
            v15 = 1;
            v6 += 4;
          }
          v11 = v7[10];
          v10 += v15 + v14;
        }
        while ( v6 < v4 && v10 < v11 - 4 );
        v16 = v7[9];
      }
      v7[4] -= v10 - v16;
      if ( v10 >= v11 )
      {
        v18 = *(_QWORD **)v7;
        v10 -= v11;
        v19 = **(_QWORD **)v7;
        **(_QWORD **)v7 = 0x100000LL;
        for ( *(_QWORD *)v7 = v19; ; *(_QWORD *)v7 = v21 )
        {
          sub_14954(v18);
          v20 = v7[10];
          v7[9] = 0;
          if ( v10 < v20 )
            break;
          v18 = *(_QWORD **)v7;
          v10 -= v20;
          v21 = **(_QWORD **)v7;
          **(_QWORD **)v7 = 0x100000LL;
        }
      }
      v7[9] = v10;
      if ( v6 < v4 && v10 >= 5 )
      {
        do
        {
          v17 = sub_C020(a1, a2, v6, 0);
          v10 = v7[9];
          v6 += v17;
        }
        while ( v6 < v4 && v10 > 4 );
      }
    }
    while ( v6 < v4 );
  }
}

//----- (000000000000C020) ----------------------------------------------------
__int64 __fastcall sub_C020(__int64 a1, __int64 a2, void *dest, int a4)
{
  __int64 v6; // x21
  __int64 v7; // x8
  int v8; // w9
  __int64 v9; // x8
  int v10; // w2
  __int64 v12; // x8
  __int64 v14; // x24
  int v15; // w23
  __int64 v16; // x8
  __int64 v17; // x8
  unsigned __int8 v18; // w2
  unsigned int desta; // [xsp+8h] [xbp-48h] BYREF
  char v20[4]; // [xsp+Ch] [xbp-44h] BYREF
  __int64 v21; // [xsp+18h] [xbp-38h] BYREF

  v6 = **(_QWORD **)(a2 + 16);
  if ( a4 )
  {
    v7 = *(unsigned int *)(v6 + 36);
    v8 = v7 + 4;
    if ( (unsigned int)(v7 + 4) >= *(_DWORD *)(v6 + 40) )
    {
      sub_14CB0((__int64 **)v6, &desta, 4);
      v9 = HIBYTE(desta);
    }
    else
    {
      desta = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v6 + 8LL) + v7);
      v9 = HIBYTE(desta);
      *(_DWORD *)(v6 + 36) = v8;
    }
    v10 = v9 - 1;
    *(_DWORD *)dest = qword_1B27F[v9];
LABEL_5:
    sub_7C24(a2, dest, v10, (unsigned __int8 *)&desta);
    return 4LL;
  }
  v21 = 0LL;
  v12 = *(unsigned int *)(v6 + 36);
  if ( (unsigned int)(v12 + 1) >= *(_DWORD *)(v6 + 40) )
  {
    sub_14CB0((__int64 **)v6, &v21, 1);
    v14 = v21;
    if ( v21 == 255 )
      goto LABEL_12;
  }
  else
  {
    LOBYTE(v21) = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v6 + 8LL) + v12);
    *(_DWORD *)(v6 + 36) = v12 + 1;
    v14 = v21;
    if ( v21 == 255 )
      goto LABEL_12;
  }
  v15 = byte_1B180[v14];
  if ( byte_1B180[v14] && (v16 = *(unsigned int *)(v6 + 36), (unsigned int)(v16 + v15) < *(_DWORD *)(v6 + 40)) )
  {
    memcpy(&desta, (const void *)(*(_QWORD *)(*(_QWORD *)v6 + 8LL) + v16), byte_1B180[v14]);
    *(_DWORD *)(v6 + 36) += v15;
  }
  else
  {
    sub_14CB0((__int64 **)v6, &desta, v15);
    v14 = v21;
  }
  v10 = v14 - 1;
  *(_DWORD *)dest = qword_1B27F[v14];
  if ( (_DWORD)v14 != 255 )
    goto LABEL_5;
LABEL_12:
  v17 = *(unsigned int *)(v6 + 36);
  if ( (unsigned int)(v17 + 1) >= *(_DWORD *)(v6 + 40) )
  {
    sub_14CB0((__int64 **)v6, v20, 1);
    v18 = v20[0];
  }
  else
  {
    v18 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v6 + 8LL) + v17);
    v20[0] = v18;
    *(_DWORD *)(v6 + 36) = v17 + 1;
  }
  sub_6D4C(a1, (int)dest, v18, 0LL);
  return 0LL;
}

//----- (000000000000C1F8) ----------------------------------------------------
void __fastcall sub_C1F8(__int64 a1, __int64 a2, void *dest, unsigned int a4, int a5)
{
  if ( a5 )
    sub_BCF4(a1, a2, dest, a4);
  else
    sub_BE60(a1, a2, dest, a4);
}

//----- (000000000000C204) ----------------------------------------------------
char *__fastcall sub_C204(unsigned __int64 a1)
{
  char *v1; // x8
  int v2; // t1
  unsigned __int64 v3; // x11
  int v4; // w9
  unsigned int v5; // w10
  signed int v6; // w12
  char *i; // x9
  char *v8; // x9
  __int64 v9; // x11
  char v10; // t1
  char *v11; // x8
  char *result; // x0

  v1 = (char *)a1;
  do
    v2 = *v1++;
  while ( (v2 & 0x80000000) != 0 );
  if ( (unsigned __int64)(v1 - 1) >= a1 )
  {
    for ( i = v1 - 2; (unsigned __int64)i >= a1; --i )
      ;
  }
  v3 = 0LL;
  do
    v4 = v1[v3++];
  while ( (v4 & 0x80000000) != 0 );
  v5 = (char)(2 * v4) & 0xFFFFFF80 | (unsigned __int8)v4;
  if ( v3 >= 2 )
  {
    v8 = &v1[v3 - 2];
    v9 = v3 + 1;
    do
    {
      v10 = *v8--;
      --v9;
      v6 = v10 & 0x7F | (v5 << 7);
      v5 = v6;
    }
    while ( v9 > 2 );
  }
  else
  {
    v6 = (char)(2 * v4) & 0xFFFFFF80 | (unsigned __int8)v4;
  }
  v11 = &v1[v6];
  if ( v6 )
    result = v11;
  else
    result = 0LL;
  return result;
}

//----- (000000000000C2A0) ----------------------------------------------------
void **__fastcall sub_C2A0(void **result, __int64 a2)
{
  void **v3; // x19
  _BYTE *v4; // x8
  _BYTE *v5; // x8
  unsigned int v6; // w9
  unsigned int v7; // w10
  char v8; // w11
  unsigned int v9; // w12
  _BYTE *v10; // x8
  _BYTE *v11; // x8
  signed int v12; // w22
  _BYTE *v13; // x8
  signed int v14; // w9
  _BYTE *v15; // x8
  unsigned int v16; // w9
  unsigned int v17; // w10
  char v18; // w11
  unsigned int v19; // w12

  v3 = result;
  *(_BYTE *)*result = *(_BYTE *)a2;
  v4 = *result;
  *result = (char *)*result + 1;
  v4[1] = *(_BYTE *)(a2 + 1);
  v5 = (char *)*result + 1;
  *result = v5;
  if ( *(unsigned __int8 *)(a2 + 1) != 255 )
  {
    v6 = *(_DWORD *)(a2 + 4);
    if ( v6 >= 0x80 )
    {
      v7 = *(_DWORD *)(a2 + 4);
      do
      {
        v8 = v6 | 0x80;
        v6 = v7 >> 7;
        v9 = v7 >> 14;
        *v5++ = v8;
        v7 >>= 7;
      }
      while ( v9 );
    }
    *v5 = v6 & 0x7F;
    v10 = v5 + 1;
    *result = v10;
    v11 = &v10[*(unsigned int *)(a2 + 4)];
    *(_QWORD *)(a2 + 8) = v11;
    v12 = (((_DWORD)v11 + 3) & 0xFFFFFFFC) - (_DWORD)v11;
    result = (void **)memset(*result, 0, v12);
    v13 = (char *)*v3 - 1;
    *v3 = v13;
    if ( v12 >= 1 )
    {
      v14 = 0;
      do
      {
        ++v14;
        *v13 |= 0x80u;
        v13 = (char *)*v3 + 1;
        *v3 = v13;
      }
      while ( v14 < v12 );
    }
    *v3 = v13 + 1;
    *(_QWORD *)(a2 + 8) += v12;
    v5 = *v3;
  }
  *v5 = *(_BYTE *)(a2 + 16);
  v15 = (char *)*v3 + 1;
  *v3 = v15;
  v16 = *(_DWORD *)(a2 + 20);
  if ( v16 >= 0x80 )
  {
    v17 = *(_DWORD *)(a2 + 20);
    do
    {
      v18 = v16 | 0x80;
      v16 = v17 >> 7;
      v19 = v17 >> 14;
      *v15++ = v18;
      v17 >>= 7;
    }
    while ( v19 );
  }
  *v15 = v16 & 0x7F;
  *v3 = v15 + 1;
  return result;
}

//----- (000000000000C3F8) ----------------------------------------------------
__int64 __fastcall sub_C3F8(__int64 *a1, int a2, int a3, unsigned int *a4)
{
  __int64 result; // x0
  unsigned int v9; // w9
  _BYTE *v10; // x8
  unsigned int v11; // w10
  char v12; // w11
  unsigned int v13; // w12

  sub_C624(*a4, a1, a2, a3);
  sub_C624(a4[1], a1, a2, a3);
  result = sub_C624(a4[2], a1, a2, a3);
  v9 = a4[3];
  v10 = (_BYTE *)*a1;
  if ( v9 >= 0x80 )
  {
    v11 = a4[3];
    do
    {
      v12 = v9 | 0x80;
      v9 = v11 >> 7;
      v13 = v11 >> 14;
      *v10++ = v12;
      v11 >>= 7;
    }
    while ( v13 );
  }
  *v10 = v9 & 0x7F;
  *a1 = (__int64)(v10 + 1);
  return result;
}

//----- (000000000000C49C) ----------------------------------------------------
_BYTE **__fastcall sub_C49C(_BYTE **result, int *a2)
{
  int v2; // w9
  _BYTE *v3; // x8
  char v4; // w10
  _BYTE *v5; // x8
  int v6; // w9
  char v7; // w10

  v2 = *a2;
  v3 = *result;
  if ( (unsigned int)(*a2 + 64) >= 0x80 )
  {
    do
    {
      v4 = v2 | 0x80;
      v2 >>= 7;
      *v3++ = v4;
    }
    while ( (unsigned int)(v2 + 64) > 0x7F );
  }
  *v3 = v2 & 0x7F;
  v5 = v3 + 1;
  *result = v5;
  v6 = a2[1];
  if ( (unsigned int)(v6 + 64) >= 0x80 )
  {
    do
    {
      v7 = v6 | 0x80;
      v6 >>= 7;
      *v5++ = v7;
    }
    while ( (unsigned int)(v6 + 64) > 0x7F );
  }
  *v5 = v6 & 0x7F;
  *result = v5 + 1;
  return result;
}

//----- (000000000000C50C) ----------------------------------------------------
__int64 __fastcall sub_C50C(int a1, char *a2, int a3)
{
  __int64 result; // x0
  char *v4; // x8
  int v5; // t1

  if ( a1 == 255 )
    return 0LL;
  if ( (a1 & 7) != 0 )
  {
    if ( (a1 & 7) == 1 )
    {
      v4 = a2;
      do
        v5 = *v4++;
      while ( (v5 & 0x80000000) != 0 );
      result = (unsigned int)((_DWORD)v4 - (_DWORD)a2);
    }
    else
    {
      result = (unsigned int)(1 << ((a1 & 7) - 1));
    }
  }
  else if ( (a3 & 0xFFFFFFFD) != 0 )
  {
    result = 8 * (unsigned int)((a3 & 0xFFFFFFFD) == 1);
  }
  else
  {
    result = 4LL;
  }
  return result;
}

//----- (000000000000C56C) ----------------------------------------------------
__int64 __fastcall sub_C56C(int a1, unsigned int a2, int a3)
{
  __int64 result; // x0
  unsigned int v4; // w8
  int v5; // t1

  if ( (a1 & 7) == 1 )
  {
    if ( (a1 & 8) != 0 )
    {
      result = 1LL;
      if ( a2 + 64 >= 0x80 )
      {
        do
        {
          a2 = (int)a2 >> 7;
          result = (unsigned int)(result + 1);
        }
        while ( a2 + 64 > 0x7F );
      }
    }
    else
    {
      result = 1LL;
      if ( a2 >= 0x80 )
      {
        do
        {
          v4 = a2 >> 14;
          result = (unsigned int)(result + 1);
          a2 >>= 7;
        }
        while ( v4 );
      }
    }
  }
  else if ( a1 == 255 )
  {
    result = 0LL;
  }
  else if ( (a1 & 7) != 0 )
  {
    if ( (a1 & 7) == 1 )
    {
      result = 0LL;
      do
        v5 = *(char *)result++;
      while ( (v5 & 0x80000000) != 0 );
    }
    else
    {
      result = (unsigned int)(1 << ((a1 & 7) - 1));
    }
  }
  else if ( (a3 & 0xFFFFFFFD) != 0 )
  {
    result = 8 * (unsigned int)((a3 & 0xFFFFFFFD) == 1);
  }
  else
  {
    result = 4LL;
  }
  return result;
}

//----- (000000000000C624) ----------------------------------------------------
__int64 __fastcall sub_C624(__int64 result, __int64 *a2, int a3, int a4)
{
  __int64 v4; // x8
  __int64 v5; // x8
  _DWORD *v6; // x8
  _BYTE *v7; // x8
  unsigned int v8; // w9
  char v9; // w10
  unsigned int v10; // w11
  char v11; // w9

  if ( a3 != 255 )
  {
    if ( (a3 & 0xF0) == 80 )
    {
      v4 = 8LL * ((a4 & 0xFFFFFFFD) == 1);
      if ( (a4 & 0xFFFFFFFD) == 0 )
        v4 = 4LL;
      *a2 = (v4 + *a2 - 1) & -v4;
    }
    switch ( a3 & 0xF )
    {
      case 0:
        v6 = (_DWORD *)*a2;
        if ( (a4 & 0xFFFFFFFD) == 0 )
          goto LABEL_9;
        goto LABEL_12;
      case 1:
        v7 = (_BYTE *)*a2;
        if ( (unsigned int)result >= 0x80 )
        {
          v8 = result;
          do
          {
            v9 = result | 0x80;
            result = v8 >> 7;
            v10 = v8 >> 14;
            *v7++ = v9;
            v8 >>= 7;
          }
          while ( v10 );
        }
        goto LABEL_19;
      case 2:
      case 0xA:
        *(_WORD *)*a2 = result;
        v5 = *a2 + 2;
        goto LABEL_20;
      case 3:
      case 0xB:
        v6 = (_DWORD *)*a2;
LABEL_9:
        *v6 = result;
        v5 = *a2 + 4;
        goto LABEL_20;
      case 4:
      case 0xC:
        v6 = (_DWORD *)*a2;
LABEL_12:
        *(_QWORD *)v6 = result;
        v5 = *a2 + 8;
        goto LABEL_20;
      case 9:
        v7 = (_BYTE *)*a2;
        if ( (unsigned int)(result + 64) >= 0x80 )
        {
          do
          {
            v11 = result | 0x80;
            result = (unsigned int)((int)result >> 7);
            *v7++ = v11;
          }
          while ( (unsigned int)(result + 64) > 0x7F );
        }
LABEL_19:
        *v7 = result & 0x7F;
        v5 = (__int64)(v7 + 1);
LABEL_20:
        *a2 = v5;
        break;
      default:
        return result;
    }
  }
  return result;
}

//----- (000000000000C740) ----------------------------------------------------
__int64 __fastcall sub_C740(__int64 result, unsigned int a2)
{
  unsigned int v2; // w10
  unsigned int v3; // w13
  unsigned int v4; // w9
  int v5; // w11
  int v6; // w14
  unsigned int v7; // w12
  __int64 v8; // x13
  int v9; // w14
  __int64 v10; // x13
  int v11; // w14
  __int64 v12; // x13
  int v13; // w14
  __int64 v14; // x9
  __int64 v15; // x10
  unsigned __int64 v16; // x11
  int8x16_t v17; // q3
  __int64 v18; // x15
  int8x16_t *v19; // x13
  int8x16_t v20; // q0
  int32x4_t v21; // q1
  unsigned __int64 v22; // x14
  int32x4_t v23; // q2
  int32x4_t v24; // q3
  int32x4_t v25; // q4
  int32x4_t v26; // q5
  unsigned __int64 v27; // d6
  unsigned __int32 v28; // s5
  unsigned int v29; // v5.s[1]
  unsigned int v30; // v5.s[2]
  unsigned int v31; // v5.s[3]
  unsigned int *v32; // x11
  int v33; // w12
  __int64 v34; // x9

  v2 = a2 >> 2;
  v3 = 0;
  v4 = (a2 >> 2) - 3;
  v5 = 67108862;
  do
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(result + 4LL * v3);
      v7 = v3;
      if ( (v6 & 0xFC000000) == -1811939328 )
        *(_DWORD *)(result + 4LL * v3) = (v5 + v6) & 0x3FFFFFF | 0x94000000;
      v8 = v3 + 1;
      v9 = *(_DWORD *)(result + 4LL * (unsigned int)v8);
      if ( (v9 & 0xFC000000) == -1811939328 )
        *(_DWORD *)(result + 4 * v8) = (v5 + v9 - 1) & 0x3FFFFFF | 0x94000000;
      v10 = v7 + 2;
      v11 = *(_DWORD *)(result + 4LL * (unsigned int)v10);
      if ( (v11 & 0xFC000000) == -1811939328 )
        *(_DWORD *)(result + 4 * v10) = (v5 + v11 - 2) & 0x3FFFFFF | 0x94000000;
      v12 = v7 + 3;
      v13 = *(_DWORD *)(result + 4LL * (unsigned int)v12);
      if ( (v13 & 0xFC000000) == -1811939328 )
        break;
      v3 = v7 + 4;
      v5 -= 4;
      if ( v7 + 4 > v4 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * v12) = (v5 + v13 - 3) & 0x3FFFFFF | 0x94000000;
    v3 = v7 + 4;
    v5 -= 4;
  }
  while ( v7 + 4 <= v4 );
LABEL_12:
  if ( v3 > v2 )
    return result;
  v14 = v3;
  v15 = v2 + 1;
  v16 = v15 - v3;
  if ( v16 <= 3 )
  {
LABEL_27:
    v32 = (unsigned int *)(result + 4 * v14);
    v33 = 67108862 - v14;
    v34 = v15 - v14;
    do
    {
      if ( (*v32 & 0xFC000000) == -1811939328 )
        *v32 = (v33 + *v32) & 0x3FFFFFF | 0x94000000;
      --v33;
      --v34;
      ++v32;
    }
    while ( v34 );
    return result;
  }
  v17 = vdupq_n_s32(v3);
  v18 = v15 - v3;
  v19 = (int8x16_t *)(result + 4LL * v3);
  v20.n128_u64[0] = 0xFC000000FC000000LL;
  v20.n128_u64[1] = 0xFC000000FC000000LL;
  v21.n128_u64[0] = 0x9400000094000000LL;
  v21.n128_u64[1] = 0x9400000094000000LL;
  v14 += v16 & 0xFFFFFFFFFFFFFFFCLL;
  v22 = v18 & 0xFFFFFFFFFFFFFFFCLL;
  v23 = vdupq_n_s32(0x3FFFFFEu);
  v24 = vorrq_s8(v17, (int8x16_t)xmmword_24D0);
  v25.n128_u64[0] = 0x400000004LL;
  v25.n128_u64[1] = 0x400000004LL;
  do
  {
    v26 = vaddq_s32(vsubq_s32(*v19, v24), v23);
    v27 = vmovn_s32(vceqq_s32(vandq_s8(*v19, v20), v21)).n64_u64[0];
    v28 = v26.n128_u32[0] & 0x3FFFFFF | 0x94000000;
    v29 = v26.n128_u32[1] & 0x3FFFFFF | 0x94000000;
    v30 = v26.n128_u32[2] & 0x3FFFFFF | 0x94000000;
    v31 = v26.n128_u32[3] & 0x3FFFFFF | 0x94000000;
    if ( (v27 & 1) != 0 )
    {
      v19->n128_u32[0] = v28;
      if ( (v27 & 0x10000) == 0 )
      {
LABEL_19:
        if ( (v27 & 0x100000000LL) != 0 )
          goto LABEL_24;
        goto LABEL_20;
      }
    }
    else if ( (v27 & 0x10000) == 0 )
    {
      goto LABEL_19;
    }
    v19->n128_u32[1] = v29;
    if ( (v27 & 0x100000000LL) != 0 )
    {
LABEL_24:
      v19->n128_u32[2] = v30;
      if ( (v27 & 0x1000000000000LL) == 0 )
        goto LABEL_16;
      goto LABEL_25;
    }
LABEL_20:
    if ( (v27 & 0x1000000000000LL) == 0 )
      goto LABEL_16;
LABEL_25:
    v19->n128_u32[3] = v31;
LABEL_16:
    v24 = vaddq_s32(v24, v25);
    v22 -= 4LL;
    ++v19;
  }
  while ( v22 );
  if ( v16 != (v16 & 0xFFFFFFFFFFFFFFFCLL) )
    goto LABEL_27;
  return result;
}
// 24D0: using guessed type __int128 xmmword_24D0;

//----- (000000000000C958) ----------------------------------------------------
__int64 __fastcall sub_C958(__int64 result, unsigned int a2)
{
  int v2; // w9
  unsigned int v3; // w10
  unsigned int v4; // w10
  __int64 v5; // x11
  __int64 v6; // x12
  char v7; // w15
  char v8; // w14
  int v9; // w16

  if ( a2 >= 4 )
  {
    v2 = 0;
    v3 = 4;
    do
    {
      v5 = v2;
      v6 = v2 + 1LL;
      v7 = *(_BYTE *)(result + v6);
      if ( (v7 & 0xF8) == 240 )
      {
        v8 = *(_BYTE *)(result + v2 + 3LL);
        v9 = v8 & 0xD0;
        if ( v9 == 144 || v9 == 208 || v9 == 192 )
        {
          v2 += 2;
          v4 = 2
             * ((((v7 & 7) << 19) | ((v8 & 7) << 8)) & 0xFFF807FF | (*(unsigned __int8 *)(result + v5) << 11) | *(unsigned __int8 *)(result + v5 + 2))
             - v3;
          *(_BYTE *)(result + v6) = (v4 >> 20) & 7 | 0xF0;
          *(_BYTE *)(result + v5) = v4 >> 12;
          *(_BYTE *)(result + v5 + 3) = v8 & 0xF8 | (v4 >> 9) & 7;
          *(_BYTE *)(result + v5 + 2) = v4 >> 1;
        }
      }
      v3 = v2 + 6;
      v2 += 2;
    }
    while ( v3 <= a2 );
  }
  return result;
}

//----- (000000000000CA14) ----------------------------------------------------
__int64 __fastcall sub_CA14(__int64 result, unsigned int a2)
{
  unsigned __int64 v2; // x8
  unsigned int v3; // w17
  unsigned __int64 v4; // x10
  int v5; // w2
  unsigned __int64 v6; // x1
  int v7; // w1
  int v8; // w5
  unsigned int v9; // w5
  int v10; // w7
  char v11; // w17
  int v12; // w7

  v2 = a2 - 5;
  if ( a2 >= 5 )
  {
    v3 = 0;
    v4 = 0LL;
    v5 = -5;
    do
    {
      if ( (*(_BYTE *)(result + v4) & 0xFE) == 232 )
      {
        v7 = v4 - v5;
        if ( (unsigned int)(v4 - v5) <= 5 )
        {
          for ( ; v7; v3 = (2 * v3) & 0xEE )
            --v7;
        }
        else
        {
          v3 = 0;
        }
        v8 = *(unsigned __int8 *)(result + v4 + 4);
        if ( v8 != 255 && *(_BYTE *)(result + v4 + 4) || v3 > 0x1F || ((0xE8uLL >> ((v3 >> 1) & 7)) & 1) != 0 )
        {
          v6 = v4 + 1;
          if ( !*(_BYTE *)(result + v4 + 4) || v8 == 255 )
            v3 |= 0x11u;
          else
            v3 |= 1u;
        }
        else
        {
          v9 = -5
             - v4
             + (((v8 << 24) | (*(unsigned __int8 *)(result + v4 + 3) << 16)) & 0xFFFF00FF | (*(unsigned __int8 *)(result + v4 + 2) << 8) | *(unsigned __int8 *)(result + v4 + 1));
          if ( v3 )
          {
            v10 = 8 * dword_24E0[v3 >> 1];
            v11 = 24 - v10;
            v12 = -1 << -(char)v10;
            while ( (unsigned __int8)(v9 >> v11) == 255 || !(unsigned __int8)(v9 >> v11) )
              v9 = -5 - v4 + (v9 ^ ~v12);
          }
          v3 = 0;
          *(_BYTE *)(result + v4 + 4) = -(HIBYTE(v9) & 1);
          *(_BYTE *)(result + v4 + 3) = BYTE2(v9);
          *(_BYTE *)(result + v4 + 2) = BYTE1(v9);
          *(_BYTE *)(result + v4 + 1) = v9;
          v6 = v4 + 5;
        }
      }
      else
      {
        v6 = v4 + 1;
        LODWORD(v4) = v5;
      }
      v5 = v4;
      v4 = v6;
    }
    while ( v6 <= v2 );
  }
  return result;
}

//----- (000000000000CB84) ----------------------------------------------------
__int64 __fastcall sub_CB84(__int64 a1, __int64 a2)
{
  return a1 + ((a2 << 33 >> 63) & 0xFFFFFFFF80000000LL | a2 & 0x7FFFFFFF);
}

//----- (000000000000CB94) ----------------------------------------------------
__int64 __fastcall sub_CB94(int *a1, _DWORD *a2)
{
  int v2; // w9
  __int64 result; // x0

  v2 = *a1;
  result = (unsigned int)(*a1 - *a2);
  if ( v2 == *a2 )
    result = (unsigned int)(a1[1] - a2[1]);
  return result;
}

//----- (000000000000CBB8) ----------------------------------------------------
__int64 __fastcall sub_CBB8(_DWORD *a1, _DWORD *a2)
{
  return (unsigned int)(*a2 - *a1);
}

//----- (000000000000CBC8) ----------------------------------------------------
__int64 __fastcall sub_CBC8(__int64 a1, __int64 *a2, int a3)
{
  const void *v3; // x23
  void *v7; // x22
  __int64 v8; // x25
  __int64 result; // x0
  _BYTE *v10; // x8
  unsigned int v11; // w9
  unsigned int v12; // w10
  char v13; // w11
  unsigned int v14; // w12
  _BYTE *v15; // x8
  int v16; // w9
  char v17; // w10
  _BYTE *v18; // x8
  unsigned int v19; // w9
  unsigned int v20; // w10
  char v21; // w11
  unsigned int v22; // w12
  unsigned __int8 *v23; // x22
  __int64 v24; // x23
  char v25; // w8
  int v26; // w8

  v3 = (const void *)(a1 + 17);
  *(_BYTE *)*a2 = *(_BYTE *)(a1 + 16);
  v7 = (void *)(*a2 + 1);
  *a2 = (__int64)v7;
  v8 = (unsigned __int8)strlen((const char *)(a1 + 17));
  result = (__int64)memcpy(v7, v3, (int)v8 + 1);
  v10 = (_BYTE *)(*a2 + (unsigned int)(v8 + 1));
  *a2 = (__int64)v10;
  v11 = *(_DWORD *)(a1 + 24);
  if ( v11 >= 0x80 )
  {
    v12 = *(_DWORD *)(a1 + 24);
    do
    {
      v13 = v11 | 0x80;
      v11 = v12 >> 7;
      v14 = v12 >> 14;
      *v10++ = v13;
      v12 >>= 7;
    }
    while ( v14 );
  }
  *v10 = v11 & 0x7F;
  v15 = v10 + 1;
  *a2 = (__int64)v15;
  v16 = *(_DWORD *)(a1 + 28);
  if ( (unsigned int)(v16 + 64) >= 0x80 )
  {
    do
    {
      v17 = v16 | 0x80;
      v16 >>= 7;
      *v15++ = v17;
    }
    while ( (unsigned int)(v16 + 64) > 0x7F );
  }
  *v15 = v16 & 0x7F;
  *a2 = (__int64)(v15 + 1);
  v15[1] = *(_BYTE *)(a1 + 32);
  v18 = (_BYTE *)(*a2 + 1);
  *a2 = (__int64)v18;
  if ( (_DWORD)v8 )
  {
    v19 = *(_DWORD *)(a1 + 36);
    if ( v19 >= 0x80 )
    {
      v20 = *(_DWORD *)(a1 + 36);
      do
      {
        v21 = v19 | 0x80;
        v19 = v20 >> 7;
        v22 = v20 >> 14;
        *v18++ = v21;
        v20 >>= 7;
      }
      while ( v22 );
    }
    *v18 = v19 & 0x7F;
    *a2 = (__int64)(v18 + 1);
    if ( (unsigned int)v8 >= 2 )
    {
      v23 = (unsigned __int8 *)(a1 + 18);
      v24 = v8 - 1;
      while ( 1 )
      {
        v26 = *v23;
        if ( v26 == 82 )
          break;
        if ( v26 == 80 )
        {
          *(_BYTE *)(*a2)++ = *(_BYTE *)(a1 + 41);
          result = sub_C624(*(_QWORD *)(a1 + 48), a2, *(unsigned __int8 *)(a1 + 41), a3);
          goto LABEL_14;
        }
        if ( v26 == 76 )
        {
          v25 = *(_BYTE *)(a1 + 40);
          goto LABEL_13;
        }
LABEL_14:
        --v24;
        ++v23;
        if ( !v24 )
          return result;
      }
      v25 = *(_BYTE *)(a1 + 56);
LABEL_13:
      *(_BYTE *)(*a2)++ = v25;
      goto LABEL_14;
    }
  }
  return result;
}

//----- (000000000000CD84) ----------------------------------------------------
__int64 __fastcall sub_CD84(__int64 a1, __int64 *a2, int a3)
{
  unsigned __int64 v3; // x9
  int v5; // w10
  _DWORD *v8; // x8
  __int64 result; // x0
  _BYTE *v10; // x8
  unsigned int v11; // w9
  unsigned int v12; // w10
  char v13; // w11
  unsigned int v14; // w12

  v3 = *(_QWORD *)a1;
  if ( *(_QWORD *)a1 > 0xFFFFFFFEuLL )
    v5 = -1;
  else
    v5 = *(_QWORD *)a1;
  *(_DWORD *)*a2 = v5;
  v8 = (_DWORD *)(*a2 + 4);
  *a2 = (__int64)v8;
  if ( v3 >= 0xFFFFFFFF )
  {
    *(_QWORD *)v8 = *(_QWORD *)a1;
    v8 = (_DWORD *)*a2;
  }
  *v8 = *(_DWORD *)(a1 + 8);
  *a2 += 4LL;
  if ( !*(_DWORD *)(a1 + 8) )
    return sub_CBC8(a1, a2, a3);
  result = sub_C624(*(_QWORD *)(a1 + 24), a2, *(unsigned __int8 *)(a1 + 17), a3);
  *(_DWORD *)*a2 = *(_DWORD *)(a1 + 32);
  v10 = (_BYTE *)(*a2 + 4);
  *a2 = (__int64)v10;
  if ( (*(_BYTE *)(a1 + 16) & 1) != 0 )
  {
    v11 = *(_DWORD *)(a1 + 36);
    if ( v11 >= 0x80 )
    {
      v12 = *(_DWORD *)(a1 + 36);
      do
      {
        v13 = v11 | 0x80;
        v11 = v12 >> 7;
        v14 = v12 >> 14;
        *v10++ = v13;
        v12 >>= 7;
      }
      while ( v14 );
    }
    *v10 = v11 & 0x7F;
    *a2 = (__int64)(v10 + 1);
    if ( (*(_BYTE *)(a1 + 16) & 2) != 0 )
      result = sub_C624(*(_QWORD *)(a1 + 48), a2, *(unsigned __int8 *)(a1 + 40), a3);
  }
  return result;
}

//----- (000000000000CEA0) ----------------------------------------------------
__int64 sub_CEA0()
{
  __int64 v0; // x19

  v0 = sub_1810C(34912LL);
  sub_11920(v0, "hermes_driver", "hbc", 0LL, 1LL, (__int64)&unk_1BA78);
  sub_118DC(v0);
  return v0;
}

//----- (000000000000CEE8) ----------------------------------------------------
__int64 sub_CEE8()
{
  return 0LL;
}

//----- (000000000000CEF0) ----------------------------------------------------
__int64 __fastcall sub_CEF0(__int64 *a1)
{
  __int64 v1; // x9
  __int64 v3; // x0
  _OWORD *v4; // x1
  __int64 v5; // x8
  __int128 *v6; // x8
  __int128 v7; // q0
  __int128 v8; // q2
  __int128 v9; // q3
  __int128 v10; // q0
  __int128 v11; // q2
  __int128 v12; // q3
  __int64 result; // x0
  __int64 v14; // x8
  __int64 v15; // x10
  __int64 v16; // x9
  __int64 v17; // x10
  __int64 v18; // x9
  __int64 v19; // x10
  __int64 v20; // x9
  __int64 v21; // x10
  __int64 v22; // x9
  __int64 v23; // x10
  __int64 v24; // x9
  __int64 v25; // x10
  __int64 v26; // x9
  __int64 v27; // x10
  __int64 v28; // x9
  __int64 v29; // x10
  __int64 v30; // x9
  __int64 v31; // x10
  __int64 v32; // x9
  __int64 v33; // x10
  __int64 v34; // x9
  __int64 v35; // x10

  v1 = *a1;
  v3 = *(_QWORD *)a1[1];
  v4 = *(_OWORD **)(v1 + 8);
  v5 = *(unsigned int *)(v3 + 36);
  if ( (unsigned int)(v5 + 128) >= *(_DWORD *)(v3 + 40) )
  {
    sub_14CB0((__int64 **)v3, v4, 128);
  }
  else
  {
    v6 = (__int128 *)(*(_QWORD *)(*(_QWORD *)v3 + 8LL) + v5);
    v7 = v6[7];
    v8 = v6[4];
    v9 = v6[5];
    v4[6] = v6[6];
    v4[7] = v7;
    v4[4] = v8;
    v4[5] = v9;
    v10 = v6[3];
    v12 = *v6;
    v11 = v6[1];
    v4[2] = v6[2];
    v4[3] = v10;
    *v4 = v12;
    v4[1] = v11;
    *(_DWORD *)(v3 + 36) += 128;
  }
  result = *a1;
  v14 = *(_QWORD *)(*a1 + 8);
  *(_DWORD *)(result + 32) = 128;
  *(_QWORD *)(result + 24) = v14;
  *(_QWORD *)(result + 40) = v14 + 128;
  v15 = *(unsigned int *)(v14 + 40);
  v16 = v14 + 128 + 16 * v15;
  *(_DWORD *)(result + 48) = v15;
  *(_QWORD *)(result + 56) = v16;
  v17 = *(unsigned int *)(v14 + 44);
  v18 = v16 + 4 * v17;
  *(_DWORD *)(result + 64) = v17;
  *(_QWORD *)(result + 72) = v18;
  v19 = *(unsigned int *)(v14 + 48);
  v20 = v18 + 4 * v19;
  *(_DWORD *)(result + 80) = v19;
  *(_QWORD *)(result + 88) = v20;
  v21 = *(unsigned int *)(v14 + 52);
  v22 = v20 + 4 * v21;
  *(_DWORD *)(result + 96) = v21;
  *(_QWORD *)(result + 104) = v22;
  v23 = *(unsigned int *)(v14 + 56);
  v24 = v22 + 8 * v23;
  *(_DWORD *)(result + 112) = v23;
  *(_QWORD *)(result + 120) = v24;
  v25 = *(unsigned int *)(v14 + 60);
  v26 = v24 + v25;
  *(_DWORD *)(result + 128) = v25;
  *(_QWORD *)(result + 136) = v26;
  v27 = *(unsigned int *)(v14 + 72);
  v28 = v26 + v27;
  *(_DWORD *)(result + 144) = v27;
  *(_QWORD *)(result + 152) = v28;
  v29 = *(unsigned int *)(v14 + 76);
  v30 = v28 + v29;
  *(_DWORD *)(result + 160) = v29;
  *(_QWORD *)(result + 168) = v30;
  v31 = *(unsigned int *)(v14 + 80);
  v32 = v30 + v31;
  *(_DWORD *)(result + 176) = v31;
  *(_QWORD *)(result + 184) = v32;
  v33 = *(unsigned int *)(v14 + 64);
  v34 = v32 + 8 * v33;
  *(_DWORD *)(result + 192) = v33;
  *(_QWORD *)(result + 200) = v34;
  v35 = *(unsigned int *)(v14 + 68);
  *(_DWORD *)(result + 208) = v35;
  *(_DWORD *)(result + 232) = *(_DWORD *)(v14 + 84);
  *(_DWORD *)(result + 236) = *(_DWORD *)(v14 + 88);
  if ( (*(_BYTE *)(v14 + 96) & 2) != 0 )
  {
    *(_QWORD *)(result + 216) = 0LL;
    *(_QWORD *)(result + 224) = v34 + v35;
  }
  else
  {
    *(_QWORD *)(result + 216) = v34 + v35;
    *(_QWORD *)(result + 224) = 0LL;
  }
  return result;
}

//----- (000000000000CF6C) ----------------------------------------------------
__int64 __fastcall sub_CF6C(__int64 a1, void *dest, unsigned int *a3, unsigned int *a4, int a5)
{
  unsigned int *v6; // x0
  __int64 v7; // x24
  __int64 v8; // x8
  unsigned __int8 v12; // w26
  char v13; // w19
  unsigned __int16 *v14; // x25
  __int64 result; // x0
  int v16; // w28
  unsigned int v17; // w0
  int v18; // w8
  unsigned int v19; // w26
  unsigned __int16 v20; // w0
  unsigned int *v21; // x0
  __int64 v22; // x8
  unsigned int v24; // [xsp+14h] [xbp-46Ch] BYREF
  char v25[512]; // [xsp+18h] [xbp-468h] BYREF
  unsigned int v26; // [xsp+218h] [xbp-268h] BYREF
  char v27[512]; // [xsp+21Ch] [xbp-264h] BYREF
  char desta[4]; // [xsp+41Ch] [xbp-64h] BYREF

  v26 = 0;
  v24 = 0;
  v6 = **(unsigned int ***)(a1 + 16);
  if ( a5 )
    v7 = 3LL;
  else
    v7 = 0LL;
  v8 = v6[9];
  if ( (int)v8 + (int)v7 + 1 >= v6[10] )
  {
    sub_14BB4((__int64)v6, v27, 1, v7);
    v12 = v27[0];
  }
  else
  {
    v12 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v6 + 8LL) + v8 + (unsigned int)v7);
    v27[0] = v12;
  }
  v13 = v12 - 1;
  LODWORD(v14) = (_DWORD)dest;
  if ( ((v12 - 1) & 0xFE) != 158 )
  {
    v16 = 0;
    v14 = (unsigned __int16 *)dest;
    do
    {
      while ( 1 )
      {
        v17 = sub_10934(0, a1, v14, a5);
        v18 = v12 - 43;
        v19 = v17;
        switch ( v18 )
        {
          case 0:
          case 1:
          case 9:
            if ( v26 <= 0xFE )
            {
              if ( v13 == 43 )
                v20 = (unsigned __int8)v14[2];
              else
                v20 = v14[2];
              sub_10C38(v20, (__int64)v27, &v26);
            }
            break;
          case 3:
            if ( v24 <= 0xFE )
              sub_10C38(v14[2], (__int64)v25, &v24);
            break;
          case 7:
            v16 += *(unsigned __int16 *)((char *)v14 + 3);
            *(unsigned __int16 *)((char *)v14 + 3) = v16;
            break;
          default:
            break;
        }
        v14 = (unsigned __int16 *)((char *)v14 + v19);
        v21 = **(unsigned int ***)(a1 + 16);
        v22 = v21[9];
        if ( (int)v22 + (int)v7 + 1 >= v21[10] )
          break;
        desta[0] = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v21 + 8LL) + v7 + v22);
        v12 = desta[0];
        v13 = desta[0] - 1;
        if ( ((desta[0] - 1) & 0xFE) == 158 )
          goto LABEL_7;
      }
      sub_14BB4((__int64)v21, desta, 1, v7);
      v12 = desta[0];
      v13 = desta[0] - 1;
    }
    while ( ((desta[0] - 1) & 0xFE) != 158 );
  }
LABEL_7:
  result = (unsigned int)((_DWORD)v14 - (_DWORD)dest);
  *a3 = v26;
  *a4 = v24;
  return result;
}

//----- (000000000000D154) ----------------------------------------------------
__int64 __fastcall sub_D154(__int64 result)
{
  __int64 *v1; // x28
  _QWORD *v2; // x19
  __int64 v3; // x29
  unsigned __int64 v4; // x20
  char *v5; // x15
  int *v6; // x16
  unsigned __int8 *v7; // x17
  __int64 v8; // x0
  __int64 v9; // x21
  __int64 v10; // x8
  int v11; // w9
  char v12; // w8
  __int64 v13; // x0
  __int64 v14; // x8
  __int64 v15; // x0
  __int64 v16; // x8
  __int64 v17; // x0
  __int64 v18; // x8
  __int64 v19; // x0
  __int64 v20; // x8
  __int64 v21; // x0
  __int64 v22; // x8
  __int64 v23; // x0
  __int64 v24; // x8
  __int64 v25; // x0
  __int64 v26; // x8
  __int64 v27; // x0
  __int64 v28; // x8
  __int64 v29; // x8
  __int64 v30; // x8
  __int64 v31; // x9
  unsigned int v32; // w11
  unsigned __int16 v33; // w13
  unsigned __int16 v34; // w14
  unsigned __int64 v35; // x12
  unsigned __int64 v36; // x10
  unsigned __int64 v37; // x10
  unsigned __int64 v38; // x10
  unsigned __int64 v39; // x11
  unsigned __int64 v40; // x11
  unsigned __int64 v41; // x13
  __int64 v42; // x12
  unsigned __int64 v43; // x12
  unsigned __int8 *v44; // [xsp+8h] [xbp-98h]
  unsigned __int8 *v45; // [xsp+8h] [xbp-98h]
  unsigned __int8 *v46; // [xsp+8h] [xbp-98h]
  unsigned __int8 *v47; // [xsp+8h] [xbp-98h]
  unsigned __int8 *v48; // [xsp+8h] [xbp-98h]
  unsigned __int8 *v49; // [xsp+8h] [xbp-98h]
  unsigned __int8 *v50; // [xsp+8h] [xbp-98h]
  unsigned __int8 *v51; // [xsp+8h] [xbp-98h]
  unsigned __int8 *v52; // [xsp+8h] [xbp-98h]
  unsigned __int8 *v53; // [xsp+8h] [xbp-98h]
  int *v54; // [xsp+10h] [xbp-90h]
  int *v55; // [xsp+10h] [xbp-90h]
  int *v56; // [xsp+10h] [xbp-90h]
  int *v57; // [xsp+10h] [xbp-90h]
  int *v58; // [xsp+10h] [xbp-90h]
  int *v59; // [xsp+10h] [xbp-90h]
  int *v60; // [xsp+10h] [xbp-90h]
  int *v61; // [xsp+10h] [xbp-90h]
  int *v62; // [xsp+10h] [xbp-90h]
  int *v63; // [xsp+10h] [xbp-90h]
  char *v64; // [xsp+18h] [xbp-88h]
  char *v65; // [xsp+18h] [xbp-88h]
  char *v66; // [xsp+18h] [xbp-88h]
  char *v67; // [xsp+18h] [xbp-88h]
  char *v68; // [xsp+18h] [xbp-88h]
  char *v69; // [xsp+18h] [xbp-88h]
  char *v70; // [xsp+18h] [xbp-88h]
  char *v71; // [xsp+18h] [xbp-88h]
  char *v72; // [xsp+18h] [xbp-88h]
  char *v73; // [xsp+18h] [xbp-88h]
  int dest; // [xsp+20h] [xbp-80h] BYREF
  int v75; // [xsp+24h] [xbp-7Ch] BYREF
  int v76; // [xsp+28h] [xbp-78h] BYREF
  unsigned int v77; // [xsp+2Ch] [xbp-74h] BYREF
  int v78; // [xsp+30h] [xbp-70h] BYREF
  int v79; // [xsp+34h] [xbp-6Ch] BYREF
  int v80; // [xsp+38h] [xbp-68h] BYREF
  unsigned __int8 v81; // [xsp+3Ch] [xbp-64h] BYREF
  char v82; // [xsp+3Dh] [xbp-63h] BYREF
  char v83; // [xsp+3Eh] [xbp-62h] BYREF

  v1 = *(__int64 **)result;
  if ( *(_DWORD *)(*(_QWORD *)result + 48LL) )
  {
    v2 = *(_QWORD **)(result + 8);
    v3 = 0LL;
    v4 = 0LL;
    v5 = &v83;
    v6 = &v76;
    v7 = &v81;
    do
    {
      v8 = v2[10];
      v9 = v1[5];
      v10 = *(unsigned int *)(v8 + 36);
      v11 = v10 + 1;
      if ( (unsigned int)(v10 + 1) >= *(_DWORD *)(v8 + 40) )
      {
        v54 = v6;
        v64 = v5;
        v44 = v7;
        sub_14CB0((__int64 **)v8, v5, 1);
        v7 = v44;
        v6 = v54;
        v5 = v64;
        if ( (v83 & 0x20) != 0 )
        {
LABEL_5:
          v13 = v2[1];
          v14 = *(unsigned int *)(v13 + 36);
          if ( (unsigned int)(v14 + 4) >= *(_DWORD *)(v13 + 40) )
          {
            v60 = v6;
            v70 = v5;
            v50 = v7;
            sub_14CB0((__int64 **)v13, &dest, 4);
            v7 = v50;
            v6 = v60;
            v5 = v70;
          }
          else
          {
            dest = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v13 + 8LL) + v14);
            *(_DWORD *)(v13 + 36) = v14 + 4;
          }
          v15 = v2[3];
          v16 = *(unsigned int *)(v15 + 36);
          if ( (unsigned int)(v16 + 4) >= *(_DWORD *)(v15 + 40) )
          {
            v61 = v6;
            v71 = v5;
            v51 = v7;
            sub_14CB0((__int64 **)v15, v6, 4);
            v7 = v51;
            v6 = v61;
            v5 = v71;
          }
          else
          {
            v76 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v15 + 8LL) + v16);
            *(_DWORD *)(v15 + 36) = v16 + 4;
          }
          v17 = v2[8];
          v18 = *(unsigned int *)(v17 + 36);
          if ( (unsigned int)(v18 + 1) >= *(_DWORD *)(v17 + 40) )
          {
            v62 = v6;
            v72 = v5;
            v52 = v7;
            sub_14CB0((__int64 **)v17, v7, 1);
            v7 = v52;
            v6 = v62;
            v5 = v72;
          }
          else
          {
            v81 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v17 + 8LL) + v18);
            *(_DWORD *)(v17 + 36) = v18 + 1;
          }
          v19 = v2[9];
          v20 = *(unsigned int *)(v19 + 36);
          if ( (unsigned int)(v20 + 1) >= *(_DWORD *)(v19 + 40) )
          {
            v63 = v6;
            v73 = v5;
            v53 = v7;
            sub_14CB0((__int64 **)v19, &v82, 1);
            v7 = v53;
            v6 = v63;
            v5 = v73;
          }
          else
          {
            v82 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v19 + 8LL) + v20);
            *(_DWORD *)(v19 + 36) = v20 + 1;
          }
          goto LABEL_13;
        }
      }
      else
      {
        v12 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v8 + 8LL) + v10);
        v83 = v12;
        *(_DWORD *)(v8 + 36) = v11;
        if ( (v12 & 0x20) != 0 )
          goto LABEL_5;
      }
LABEL_13:
      v21 = v2[2];
      v22 = *(unsigned int *)(v21 + 36);
      if ( (unsigned int)(v22 + 4) >= *(_DWORD *)(v21 + 40) )
      {
        v55 = v6;
        v65 = v5;
        v45 = v7;
        sub_14CB0((__int64 **)v21, &v75, 4);
        v7 = v45;
        v6 = v55;
        v5 = v65;
      }
      else
      {
        v75 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v21 + 8LL) + v22);
        *(_DWORD *)(v21 + 36) = v22 + 4;
      }
      v23 = v2[4];
      v24 = *(unsigned int *)(v23 + 36);
      if ( (unsigned int)(v24 + 4) >= *(_DWORD *)(v23 + 40) )
      {
        v56 = v6;
        v66 = v5;
        v46 = v7;
        sub_14CB0((__int64 **)v23, &v77, 4);
        v7 = v46;
        v6 = v56;
        v5 = v66;
      }
      else
      {
        v77 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v23 + 8LL) + v24);
        *(_DWORD *)(v23 + 36) = v24 + 4;
      }
      v25 = v2[5];
      v26 = *(unsigned int *)(v25 + 36);
      if ( (unsigned int)(v26 + 4) >= *(_DWORD *)(v25 + 40) )
      {
        v57 = v6;
        v67 = v5;
        v47 = v7;
        sub_14CB0((__int64 **)v25, &v78, 4);
        v7 = v47;
        v6 = v57;
        v5 = v67;
      }
      else
      {
        v78 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8LL) + v26);
        *(_DWORD *)(v25 + 36) = v26 + 4;
      }
      v27 = v2[6];
      v28 = *(unsigned int *)(v27 + 36);
      if ( (unsigned int)(v28 + 4) >= *(_DWORD *)(v27 + 40) )
      {
        v58 = v6;
        v68 = v5;
        v48 = v7;
        sub_14CB0((__int64 **)v27, &v79, 4);
        v7 = v48;
        v6 = v58;
        v5 = v68;
      }
      else
      {
        v79 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v27 + 8LL) + v28);
        *(_DWORD *)(v27 + 36) = v28 + 4;
      }
      result = v2[7];
      v29 = *(unsigned int *)(result + 36);
      if ( (unsigned int)(v29 + 4) >= *(_DWORD *)(result + 40) )
      {
        v59 = v6;
        v69 = v5;
        v49 = v7;
        result = sub_14CB0((__int64 **)result, &v80, 4);
        v7 = v49;
        v6 = v59;
        v5 = v69;
      }
      else
      {
        v80 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)result + 8LL) + v29);
        *(_DWORD *)(result + 36) = v29 + 4;
      }
      v30 = v9 + v3;
      v31 = v9 + v3 + 8;
      v32 = *(_DWORD *)v31;
      v33 = *(unsigned __int8 *)(v9 + v3 + 14);
      ++v4;
      v34 = *(_WORD *)(v9 + v3 + 12);
      v35 = *(_QWORD *)(v9 + v3) & 0xFFFFFFFFFE000000LL | dest & 0x1FFFFFF;
      *(_QWORD *)v30 = v35;
      v36 = v35 & 0xFFFFFFFF01FFFFFFLL | (unsigned int)(v75 << 25);
      *(_QWORD *)v30 = v36;
      v3 += 16LL;
      v37 = v36 & 0xFFFF8000FFFFFFFFLL | ((unsigned __int64)(v76 & 0x7FFF) << 32);
      *(_QWORD *)v30 = v37;
      v38 = v37 & 0x7FFFFFFFFFFFLL | ((unsigned __int64)v77 << 47);
      *(_QWORD *)v30 = v38;
      LODWORD(v35) = v78;
      *(_QWORD *)v30 = v38;
      v39 = (v32 | ((unsigned __int64)(v34 | (v33 << 16)) << 32)) & 0xFFFFFFFFFE000000LL | v35 & 0x1FFFFFF;
      *(_DWORD *)v31 = v39;
      *(_WORD *)(v31 + 4) = WORD2(v39);
      LOBYTE(v33) = v79;
      *(_WORD *)(v31 + 4) = WORD2(v39);
      *(_QWORD *)v30 = v38;
      v40 = v39 & 0xFFFFFFFF01FFFFFFLL | ((unsigned __int64)(v33 & 0x7F) << 25);
      *(_DWORD *)v31 = v40;
      LOBYTE(v35) = v80;
      *(_DWORD *)v31 = v40;
      *(_QWORD *)v30 = v38;
      v41 = v40 & 0xFFFFFF00FFFFFFFFLL | ((unsigned __int64)(unsigned __int8)v35 << 32);
      *(_WORD *)(v31 + 4) = WORD2(v41);
      v42 = v81;
      *(_DWORD *)v31 = v40;
      *(_QWORD *)v30 = v38;
      v43 = (v41 & 0xFFFF00FFFFFFFFFFLL | (v42 << 40)) >> 32;
      *(_WORD *)(v31 + 4) = v43;
      LOBYTE(v41) = v82;
      *(_DWORD *)v31 = v40;
      *(_WORD *)(v31 + 4) = v43;
      *(_QWORD *)v30 = v38;
      *(_BYTE *)(v30 + 14) = v41;
      *(_BYTE *)(v30 + 15) = v83;
    }
    while ( v4 < *((unsigned int *)v1 + 12) );
  }
  return result;
}

//----- (000000000000D5AC) ----------------------------------------------------
__int64 __fastcall sub_D5AC(__int64 *a1)
{
  _QWORD *v1; // x19
  __int64 v2; // x20
  __int64 result; // x0
  __int64 v4; // x9
  unsigned __int64 v5; // x21
  int v6; // w23
  int v7; // w22
  unsigned int v8; // w9
  __int64 v9; // x0
  __int64 v10; // x24
  __int64 v11; // x8
  __int64 v12; // x8
  int v13; // w26
  __int64 v14; // x8
  int v15; // w9
  int v16; // w8
  int v17; // w8
  unsigned int v18; // w10
  _DWORD *v19; // x9
  int dest; // [xsp+Ch] [xbp-54h] BYREF
  unsigned int v21; // [xsp+18h] [xbp-48h] BYREF
  int v22; // [xsp+1Ch] [xbp-44h] BYREF

  v1 = (_QWORD *)a1[1];
  v2 = *a1;
  result = v1[13];
  v4 = *(unsigned int *)(result + 36);
  if ( (unsigned int)(v4 + 4) >= *(_DWORD *)(result + 40) )
  {
    result = sub_14CB0((__int64 **)result, &v22, 4);
    if ( !*(_DWORD *)(v2 + 96) )
      return result;
  }
  else
  {
    v22 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)result + 8LL) + v4);
    *(_DWORD *)(result + 36) = v4 + 4;
    if ( !*(_DWORD *)(v2 + 96) )
      return result;
  }
  v5 = 0LL;
  v6 = 0;
  v7 = 0;
  do
  {
    v9 = v1[11];
    v10 = *(_QWORD *)(v2 + 88);
    v11 = *(unsigned int *)(v9 + 36);
    if ( (unsigned int)(v11 + 4) >= *(_DWORD *)(v9 + 40) )
    {
      sub_14CB0((__int64 **)v9, &dest, 4);
    }
    else
    {
      dest = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v9 + 8LL) + v11);
      *(_DWORD *)(v9 + 36) = v11 + 4;
    }
    result = v1[12];
    v12 = *(unsigned int *)(result + 36);
    if ( (unsigned int)(v12 + 4) >= *(_DWORD *)(result + 40) )
    {
      result = sub_14CB0((__int64 **)result, &v21, 4);
    }
    else
    {
      v21 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)result + 8LL) + v12);
      *(_DWORD *)(result + 36) = v12 + 4;
    }
    v13 = dest;
    if ( v5 == v22 )
    {
      *(_DWORD *)(v10 + 4 * v5) |= 1u;
      result = v1[13];
      v14 = *(unsigned int *)(result + 36);
      v15 = v14 + 4;
      if ( (unsigned int)(v14 + 4) >= *(_DWORD *)(result + 40) )
      {
        result = sub_14CB0((__int64 **)result, &v22, 4);
        v16 = v22;
      }
      else
      {
        v16 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)result + 8LL) + v14);
        v22 = v16;
        *(_DWORD *)(result + 36) = v15;
      }
      v22 = v5 + v16;
    }
    v17 = v13 + v6;
    if ( v21 < 0xFF )
    {
      v8 = *(_DWORD *)(v10 + 4 * v5) & 0xFF000001 | (2 * (v17 & 0x7FFFFF));
      *(_DWORD *)(v10 + 4 * v5) = v8;
      *(_DWORD *)(v10 + 4 * v5) = v8 & 0xFFFFFF | ((unsigned __int8)v21 << 24);
    }
    else
    {
      v18 = v7 & 0x7FFFFF;
      *(_DWORD *)(v10 + 4 * v5) = *(_DWORD *)(v10 + 4 * v5) & 1 | (2 * v7++) | 0xFF000000;
      v19 = (_DWORD *)(*(_QWORD *)(v2 + 104) + 8LL * v18);
      *v19 = v17;
      v19[1] = v21;
    }
    ++v5;
    v6 = v21 + v17;
  }
  while ( v5 < *(unsigned int *)(v2 + 96) );
  return result;
}

//----- (000000000000D788) ----------------------------------------------------
void *__fastcall sub_D788(_QWORD *a1)
{
  unsigned int *v1; // x19
  size_t v2; // w20
  __int64 v3; // x9
  void *result; // x0

  v1 = *(unsigned int **)(a1[1] + 200LL);
  v2 = *(_DWORD *)(*a1 + 128LL);
  if ( !v2 )
    return (void *)sub_14CB0(*(__int64 ***)(a1[1] + 200LL), *(void **)(*a1 + 120LL), *(_DWORD *)(*a1 + 128LL));
  v3 = v1[9];
  if ( (unsigned int)v3 + v2 >= v1[10] )
    return (void *)sub_14CB0(*(__int64 ***)(a1[1] + 200LL), *(void **)(*a1 + 120LL), *(_DWORD *)(*a1 + 128LL));
  result = memcpy(*(void **)(*a1 + 120LL), (const void *)(*(_QWORD *)(*(_QWORD *)v1 + 8LL) + v3), v2);
  v1[9] += v2;
  return result;
}

//----- (000000000000D7FC) ----------------------------------------------------
__int64 __fastcall sub_D7FC(__int64 result)
{
  __int64 v1; // x19
  unsigned int v2; // w9
  __int64 v3; // x8
  unsigned __int64 v4; // x22
  int v5; // w23
  int v6; // w24
  int v7; // w10
  int v8; // w10
  unsigned __int64 v9; // x25
  unsigned __int64 v10; // x10
  unsigned int v11; // w28
  unsigned int v12; // w21
  int v13; // w1
  unsigned __int16 *v14; // x0

  v1 = *(_QWORD *)result;
  v2 = *(_DWORD *)(*(_QWORD *)result + 64LL);
  if ( v2 )
  {
    v3 = *(_QWORD *)(v1 + 56);
    v4 = 0LL;
    v5 = 0;
    v6 = 0;
    do
    {
      v8 = *(_DWORD *)(v3 + 4 * v4);
      if ( (v8 & 0x80000000) != 0 )
      {
        if ( (v8 & 0x7FFFFFFF) != 0 )
        {
          v9 = 0LL;
          do
          {
            v11 = v6 + v9;
            v12 = sub_E680(v1, v5 + (int)v9);
            v13 = sub_E6AC(v1, v5 + (int)v9);
            v14 = (unsigned __int16 *)(*(_QWORD *)(v1 + 120) + v12);
            if ( (*(_DWORD *)(*(_QWORD *)(v1 + 88) + 4LL * (unsigned int)(v5 + v9)) & 1) != 0 )
              result = sub_E704(v14, v13);
            else
              result = sub_E6D8((unsigned __int8 *)v14, v13);
            ++v9;
            *(_DWORD *)(*(_QWORD *)(v1 + 72) + 4LL * v11) = result;
            v3 = *(_QWORD *)(v1 + 56);
            v10 = *(_DWORD *)(v3 + 4 * v4) & 0x7FFFFFFF;
          }
          while ( v9 < v10 );
          v2 = *(_DWORD *)(v1 + 64);
        }
        else
        {
          LODWORD(v10) = 0;
        }
        v6 += v10;
      }
      v7 = *(_DWORD *)(v3 + 4 * v4++);
      v5 += v7 & 0x7FFFFFFF;
    }
    while ( v4 < v2 );
  }
  return result;
}

//----- (000000000000D900) ----------------------------------------------------
__int64 __fastcall sub_D900(__int64 a1, int a2)
{
  __int64 **v3; // x21
  int v4; // w9
  int v6; // w8
  unsigned int v7; // w10
  unsigned int v8; // w22
  _QWORD *v9; // x0
  __int64 *v10; // x10
  unsigned int v11; // w8
  _QWORD *v12; // x0
  __int64 *v13; // x9
  __int64 v14; // x0
  __int64 v15; // x8
  int v16; // w9
  char v17; // w8
  unsigned __int8 v18; // w8
  __int64 v19; // x0
  __int64 v20; // x9
  char dest[4]; // [xsp+Ch] [xbp-44h] BYREF
  __int64 v23; // [xsp+10h] [xbp-40h] BYREF
  _BOOL4 v24; // [xsp+18h] [xbp-38h]

  v3 = *(__int64 ***)(*(_QWORD *)(a1 + 8) + 112LL);
  if ( *(_DWORD *)(a1 + 32) )
    v4 = 3;
  else
    v4 = 0;
  v6 = *((_DWORD *)v3 + 9);
  v7 = *((_DWORD *)v3 + 10);
  v8 = v6 + v4;
  *((_DWORD *)v3 + 4) -= v4;
  if ( v6 + v4 >= v7 )
  {
    v9 = *v3;
    v8 = v6 - v7 + v4;
    v10 = (__int64 *)**v3;
    *v9 = 0x100000LL;
    *v3 = v10;
    sub_14954(v9);
    v11 = *((_DWORD *)v3 + 10);
    for ( *((_DWORD *)v3 + 9) = 0; v8 >= v11; *((_DWORD *)v3 + 9) = 0 )
    {
      v12 = *v3;
      v8 -= v11;
      v13 = (__int64 *)**v3;
      *v12 = 0x100000LL;
      *v3 = v13;
      sub_14954(v12);
      v11 = *((_DWORD *)v3 + 10);
    }
  }
  *((_DWORD *)v3 + 9) = v8;
  v14 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 112LL);
  v15 = *(unsigned int *)(v14 + 36);
  v16 = v15 + 1;
  if ( (unsigned int)(v15 + 1) >= *(_DWORD *)(v14 + 40) )
  {
    sub_14CB0((__int64 **)v14, dest, 1);
    v17 = dest[0];
  }
  else
  {
    v17 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v14 + 8LL) + v15);
    dest[0] = v17;
    *(_DWORD *)(v14 + 36) = v16;
  }
  v18 = v17 - 1;
  dest[0] = v18;
  v19 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 120LL);
  v20 = *(unsigned int *)(v19 + 36);
  if ( (unsigned int)(v20 + 4) >= *(_DWORD *)(v19 + 40) )
  {
    sub_14CB0((__int64 **)v19, &v23, 4);
    v18 = dest[0];
  }
  else
  {
    LODWORD(v23) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v19 + 8LL) + v20);
    *(_DWORD *)(v19 + 36) = v20 + 4;
  }
  HIDWORD(v23) = a2 - *(_DWORD *)(*(_QWORD *)a1 + 8LL);
  v24 = v18 != 158;
  return v23;
}

//----- (000000000000DA68) ----------------------------------------------------
void __fastcall sub_DA68(_QWORD *a1)
{
  unsigned int **v1; // x24
  __int64 v3; // x25
  unsigned int *v4; // x0
  __int64 v5; // x8
  unsigned int *v6; // x0
  __int64 v7; // x8
  unsigned int *v8; // x0
  __int64 v9; // x8
  unsigned int *v10; // x0
  __int64 v11; // x8
  __int64 v12; // x0
  unsigned int *v13; // x8
  _DWORD *v14; // x20
  __int64 v15; // x9
  unsigned int *v16; // x0
  __int64 v17; // x8
  char *v18; // x21
  int v19; // w26
  int v20; // w27
  int v21; // w28
  unsigned int *v22; // x0
  __int64 v23; // x8
  unsigned int *v24; // x0
  __int64 v25; // x8
  size_t v26; // w22
  unsigned int *v27; // x23
  __int64 v28; // x8
  unsigned int v29; // w22
  unsigned int *v30; // x0
  __int64 v31; // x8
  unsigned int *v32; // x0
  __int64 v33; // x8
  unsigned int v34; // w9
  int v35; // w8
  __int64 v36; // x0
  int v37; // w1
  int v38; // w11
  int v39; // w8
  unsigned int *v40; // x0
  __int64 v41; // x8
  unsigned int *v42; // x0
  __int64 v43; // x8
  unsigned int v44; // w9
  int v45; // w8
  unsigned int *v46; // x0
  __int64 v47; // x8
  unsigned int *v48; // x0
  __int64 v49; // x8
  unsigned int v50; // w9
  int v51; // w8
  __int64 v52; // x8
  unsigned int v53; // w11
  unsigned __int16 v54; // w13
  unsigned __int16 v55; // w14
  unsigned __int64 v56; // x12
  unsigned __int64 v57; // x12
  __int64 v58; // x9
  unsigned __int64 v59; // x9
  __int64 v60; // x8
  char v61[4]; // [xsp+Ch] [xbp-A4h] BYREF
  size_t n; // [xsp+10h] [xbp-A0h] BYREF
  int v63; // [xsp+14h] [xbp-9Ch]
  int v64; // [xsp+18h] [xbp-98h]
  unsigned int v65; // [xsp+1Ch] [xbp-94h]
  unsigned int v66; // [xsp+20h] [xbp-90h]
  int dest; // [xsp+28h] [xbp-88h] BYREF
  int v68; // [xsp+2Ch] [xbp-84h] BYREF
  int v69; // [xsp+30h] [xbp-80h] BYREF
  int v70; // [xsp+34h] [xbp-7Ch] BYREF
  int v71; // [xsp+38h] [xbp-78h] BYREF
  unsigned int v72; // [xsp+3Ch] [xbp-74h] BYREF
  int v73; // [xsp+40h] [xbp-70h] BYREF
  int v74; // [xsp+44h] [xbp-6Ch] BYREF
  int v75; // [xsp+48h] [xbp-68h] BYREF
  unsigned int v76; // [xsp+4Ch] [xbp-64h] BYREF

  v1 = (unsigned int **)a1[1];
  v3 = *a1;
  v4 = *v1;
  v5 = (*v1)[9];
  if ( (int)v5 + 4 >= (*v1)[10] )
  {
    sub_14CB0((__int64 **)v4, &v76, 4);
  }
  else
  {
    v76 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v4 + 8LL) + v5);
    v4[9] = v5 + 4;
  }
  v6 = *v1;
  v7 = (*v1)[9];
  if ( (int)v7 + 4 >= (*v1)[10] )
  {
    sub_14CB0((__int64 **)v6, &v75, 4);
  }
  else
  {
    v75 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v6 + 8LL) + v7);
    v6[9] = v7 + 4;
  }
  v8 = v1[17];
  v9 = v8[9];
  if ( (int)v9 + 4 >= v8[10] )
  {
    sub_14CB0((__int64 **)v8, &v74, 4);
  }
  else
  {
    v74 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v8 + 8LL) + v9);
    v8[9] = v9 + 4;
  }
  v10 = v1[18];
  v11 = v10[9];
  if ( (int)v11 + 4 >= v10[10] )
  {
    sub_14CB0((__int64 **)v10, &v73, 4);
  }
  else
  {
    v73 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v10 + 8LL) + v11);
    v10[9] = v11 + 4;
  }
  v72 = 0;
  v12 = sub_1810C(20LL * v76);
  v13 = v1[20];
  v14 = (_DWORD *)v12;
  v15 = v13[9];
  if ( (int)v15 + 4 >= v13[10] )
  {
    sub_14CB0((__int64 **)v1[20], &v71, 4);
  }
  else
  {
    v71 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v13 + 8LL) + v15);
    v13[9] = v15 + 4;
  }
  v16 = v1[22];
  v17 = v16[9];
  if ( (int)v17 + 4 >= v16[10] )
  {
    sub_14CB0((__int64 **)v16, &v70, 4);
  }
  else
  {
    v70 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v16 + 8LL) + v17);
    v16[9] = v17 + 4;
  }
  v18 = (char *)(*(_QWORD *)(v3 + 200) + *(unsigned int *)(v3 + 208));
  if ( (*(_DWORD *)(v3 + 48) & 0x7FFFFFFF) != 0 )
  {
    v19 = 0;
    v20 = 0;
    v21 = 0;
    while ( v72 )
    {
LABEL_27:
      v68 = 0;
      v69 = 0;
      v29 = sub_CF6C(*(_QWORD *)v3, v18, (unsigned int *)&v69, (unsigned int *)&v68, *((_DWORD *)a1 + 8));
      if ( v21 == v73 )
      {
        v30 = v1[19];
        v31 = v30[9];
        if ( (int)v31 + 4 >= v30[10] )
        {
          sub_14CB0((__int64 **)v30, &n, 4);
        }
        else
        {
          n = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v30 + 8LL) + v31);
          v30[9] = v31 + 4;
        }
        v32 = v1[18];
        v33 = v32[9];
        v34 = v33 + 4;
        if ( (int)v33 + 4 >= v32[10] )
        {
          sub_14CB0((__int64 **)v32, &dest, 4);
          v35 = dest;
        }
        else
        {
          v35 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v32 + 8LL) + v33);
          dest = v35;
          v32[9] = v34;
        }
        v29 -= n;
        v73 += v35;
      }
      if ( v29 )
      {
        sub_E64C(v29, v69, v68, (__int64)v14, v72);
        v18 += v29;
      }
      v36 = sub_D900((__int64)a1, (int)v18);
      if ( v37 )
      {
        sub_E5D8(v36, v14, &v72, (__int64)&n);
        if ( v65 >= 0xFF )
          v38 = 255;
        else
          v38 = v65;
        if ( v66 >= 0xFF )
          v39 = 255;
        else
          v39 = v66;
        v65 = v38;
        v66 = v39;
        if ( v20 == v71 )
        {
          v40 = v1[21];
          v41 = v40[9];
          if ( (int)v41 + 1 >= v40[10] )
          {
            sub_14CB0((__int64 **)v40, v61, 1);
          }
          else
          {
            v61[0] = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v40 + 8LL) + v41);
            v40[9] = v41 + 1;
          }
          v42 = v1[20];
          v43 = v42[9];
          v44 = v43 + 4;
          if ( (int)v43 + 4 >= v42[10] )
          {
            sub_14CB0((__int64 **)v42, &dest, 4);
            v45 = dest;
          }
          else
          {
            v45 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v42 + 8LL) + v43);
            dest = v45;
            v42[9] = v44;
          }
          v65 += (unsigned __int8)v61[0];
          v71 += v45;
        }
        if ( v20 == v70 )
        {
          v46 = v1[23];
          v47 = v46[9];
          if ( (int)v47 + 1 >= v46[10] )
          {
            sub_14CB0((__int64 **)v46, v61, 1);
          }
          else
          {
            v61[0] = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v46 + 8LL) + v47);
            v46[9] = v47 + 1;
          }
          v48 = v1[22];
          v49 = v48[9];
          v50 = v49 + 4;
          if ( (int)v49 + 4 >= v48[10] )
          {
            sub_14CB0((__int64 **)v48, &dest, 4);
            v51 = dest;
          }
          else
          {
            v51 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v48 + 8LL) + v49);
            dest = v51;
            v48[9] = v50;
          }
          v66 += (unsigned __int8)v61[0];
          v70 += v51;
        }
        ++v20;
        v52 = *(_QWORD *)(*a1 + 40LL) + 16LL * n;
        if ( (*(_BYTE *)(v52 + 15) & 0x20) != 0 )
        {
          v60 = *(_QWORD *)(*a1 + 8LL) + (*(_DWORD *)v52 & 0x1FFFFFF | (*(_DWORD *)(v52 + 8) << 16));
          *(_DWORD *)v60 = v63;
          *(_DWORD *)(v60 + 8) = v64;
          *(_BYTE *)(v60 + 28) = v65;
          *(_BYTE *)(v60 + 29) = v66;
        }
        else
        {
          v53 = *(_DWORD *)(v52 + 8);
          v54 = *(unsigned __int8 *)(v52 + 14);
          v55 = *(_WORD *)(v52 + 12);
          v56 = *(_QWORD *)v52 & 0xFFFFFFFFFE000000LL | v63 & 0x1FFFFFF;
          *(_QWORD *)v52 = v56;
          v57 = v56 & 0xFFFF8000FFFFFFFFLL | ((unsigned __int64)(v64 & 0x7FFF) << 32);
          *(_QWORD *)v52 = v57;
          v58 = (unsigned __int8)v65;
          *(_QWORD *)v52 = v57;
          *(_DWORD *)(v52 + 8) = v53;
          v59 = ((v53 | ((unsigned __int64)(v55 | (v54 << 16)) << 32)) & 0xFFFF00FFFFFFFFFFLL | (v58 << 40)) >> 32;
          *(_WORD *)(v52 + 12) = v59;
          LOBYTE(v54) = v66;
          *(_QWORD *)v52 = v57;
          *(_WORD *)(v52 + 12) = v59;
          *(_DWORD *)(v52 + 8) = v53;
          *(_BYTE *)(v52 + 14) = v54;
        }
      }
      else
      {
        sub_E5B4(v36, SHIDWORD(v36), (__int64)v14, &v72);
      }
      if ( ++v21 >= (unsigned int)(2 * *(_DWORD *)(v3 + 48)) )
        goto LABEL_66;
    }
    if ( v19 != v74 )
    {
LABEL_26:
      ++v19;
      goto LABEL_27;
    }
    v22 = v1[16];
    v23 = v22[9];
    if ( (int)v23 + 4 >= v22[10] )
    {
      sub_14CB0((__int64 **)v22, &n, 4);
    }
    else
    {
      n = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v22 + 8LL) + v23);
      v22[9] = v23 + 4;
    }
    v24 = v1[17];
    v25 = v24[9];
    if ( (int)v25 + 4 >= v24[10] )
    {
      sub_14CB0((__int64 **)v24, &v74, 4);
      v26 = n;
      v27 = *v1;
      if ( !n )
        goto LABEL_65;
    }
    else
    {
      v74 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v24 + 8LL) + v25);
      v24[9] = v25 + 4;
      v26 = n;
      v27 = *v1;
      if ( !n )
        goto LABEL_65;
    }
    v28 = v27[9];
    if ( (unsigned int)v28 + v26 < v27[10] )
    {
      memcpy(v18, (const void *)(*(_QWORD *)(*(_QWORD *)v27 + 8LL) + v28), v26);
      v27[9] += v26;
LABEL_25:
      v18 += n;
      goto LABEL_26;
    }
LABEL_65:
    sub_14CB0((__int64 **)v27, v18, v26);
    goto LABEL_25;
  }
LABEL_66:
  j__free(v14);
  a1[3] = v18;
}
// DD4C: variable 'v37' is possibly undefined

//----- (000000000000E068) ----------------------------------------------------
void *__fastcall sub_E068(_QWORD *a1)
{
  unsigned int *v1; // x20
  int v2; // w19
  __int64 v3; // x9
  void *result; // x0

  v1 = *(unsigned int **)(a1[1] + 192LL);
  v2 = 4 * *(_DWORD *)(*a1 + 64LL);
  if ( !v2 )
    return (void *)sub_14CB0(*(__int64 ***)(a1[1] + 192LL), *(void **)(*a1 + 56LL), v2);
  v3 = v1[9];
  if ( (int)v3 + v2 >= v1[10] )
    return (void *)sub_14CB0(*(__int64 ***)(a1[1] + 192LL), *(void **)(*a1 + 56LL), v2);
  result = memcpy(*(void **)(*a1 + 56LL), (const void *)(*(_QWORD *)(*(_QWORD *)v1 + 8LL) + v3), v2);
  v1[9] += v2;
  return result;
}

//----- (000000000000E0E0) ----------------------------------------------------
void *__fastcall sub_E0E0(__int64 ****a1)
{
  unsigned int *v1; // x20
  int v2; // w19
  __int64 v3; // x9
  void *result; // x0

  v1 = (unsigned int *)*a1[1];
  v2 = 8 * *((_DWORD *)*a1 + 48);
  if ( !v2 )
    return (void *)sub_14CB0(*a1[1], (*a1)[23], v2);
  v3 = v1[9];
  if ( (int)v3 + v2 >= v1[10] )
    return (void *)sub_14CB0(*a1[1], (*a1)[23], v2);
  result = memcpy((*a1)[23], (const void *)(*(_QWORD *)(*(_QWORD *)v1 + 8LL) + v3), v2);
  v1[9] += v2;
  return result;
}

//----- (000000000000E158) ----------------------------------------------------
void *__fastcall sub_E158(__int64 ****a1)
{
  unsigned int *v1; // x19
  size_t v2; // w20
  __int64 v3; // x9
  void *result; // x0

  v1 = (unsigned int *)*a1[1];
  v2 = *((_DWORD *)*a1 + 36);
  if ( !v2 )
    return (void *)sub_14CB0(*a1[1], (*a1)[17], *((_DWORD *)*a1 + 36));
  v3 = v1[9];
  if ( (unsigned int)v3 + v2 >= v1[10] )
    return (void *)sub_14CB0(*a1[1], (*a1)[17], *((_DWORD *)*a1 + 36));
  result = memcpy((*a1)[17], (const void *)(*(_QWORD *)(*(_QWORD *)v1 + 8LL) + v3), v2);
  v1[9] += v2;
  return result;
}

//----- (000000000000E1CC) ----------------------------------------------------
void *__fastcall sub_E1CC(__int64 ****a1)
{
  unsigned int *v1; // x19
  size_t v2; // w20
  __int64 v3; // x9
  void *result; // x0

  v1 = (unsigned int *)*a1[1];
  v2 = *((_DWORD *)*a1 + 40);
  if ( !v2 )
    return (void *)sub_14CB0(*a1[1], (*a1)[19], *((_DWORD *)*a1 + 40));
  v3 = v1[9];
  if ( (unsigned int)v3 + v2 >= v1[10] )
    return (void *)sub_14CB0(*a1[1], (*a1)[19], *((_DWORD *)*a1 + 40));
  result = memcpy((*a1)[19], (const void *)(*(_QWORD *)(*(_QWORD *)v1 + 8LL) + v3), v2);
  v1[9] += v2;
  return result;
}

//----- (000000000000E240) ----------------------------------------------------
void *__fastcall sub_E240(__int64 ****a1)
{
  unsigned int *v1; // x19
  size_t v2; // w20
  __int64 v3; // x9
  void *result; // x0

  v1 = (unsigned int *)*a1[1];
  v2 = *((_DWORD *)*a1 + 44);
  if ( !v2 )
    return (void *)sub_14CB0(*a1[1], (*a1)[21], *((_DWORD *)*a1 + 44));
  v3 = v1[9];
  if ( (unsigned int)v3 + v2 >= v1[10] )
    return (void *)sub_14CB0(*a1[1], (*a1)[21], *((_DWORD *)*a1 + 44));
  result = memcpy((*a1)[21], (const void *)(*(_QWORD *)(*(_QWORD *)v1 + 8LL) + v3), v2);
  v1[9] += v2;
  return result;
}

//----- (000000000000E2B4) ----------------------------------------------------
void *__fastcall sub_E2B4(__int64 ****a1)
{
  unsigned int *v1; // x19
  size_t v2; // w20
  __int64 v3; // x9
  void *result; // x0

  v1 = (unsigned int *)*a1[1];
  v2 = *((_DWORD *)*a1 + 52);
  if ( !v2 )
    return (void *)sub_14CB0(*a1[1], (*a1)[25], *((_DWORD *)*a1 + 52));
  v3 = v1[9];
  if ( (unsigned int)v3 + v2 >= v1[10] )
    return (void *)sub_14CB0(*a1[1], (*a1)[25], *((_DWORD *)*a1 + 52));
  result = memcpy((*a1)[25], (const void *)(*(_QWORD *)(*(_QWORD *)v1 + 8LL) + v3), v2);
  v1[9] += v2;
  return result;
}

//----- (000000000000E328) ----------------------------------------------------
void *__fastcall sub_E328(_QWORD *a1)
{
  __int64 v1; // x8
  __int64 v3; // x20
  __int64 v4; // x9
  __int64 v5; // x8
  __int64 **v6; // x19
  size_t v7; // w20
  __int64 v8; // x9
  void *result; // x0
  __int64 v10[3]; // [xsp+8h] [xbp-268h] BYREF
  void *dest; // [xsp+20h] [xbp-250h]
  int v12; // [xsp+28h] [xbp-248h]
  __int64 v13[12]; // [xsp+30h] [xbp-240h] BYREF
  int v14[2]; // [xsp+90h] [xbp-1E0h] BYREF
  __int64 v15; // [xsp+98h] [xbp-1D8h]
  __int64 v16; // [xsp+A0h] [xbp-1D0h]
  __int64 v17; // [xsp+A8h] [xbp-1C8h]
  __int64 v18; // [xsp+B0h] [xbp-1C0h]
  __int64 v19; // [xsp+B8h] [xbp-1B8h]
  __int64 v20; // [xsp+C0h] [xbp-1B0h]
  __int64 v21; // [xsp+C8h] [xbp-1A8h]
  __int64 v22; // [xsp+D0h] [xbp-1A0h]
  __int64 v23; // [xsp+D8h] [xbp-198h]
  __int64 v24; // [xsp+E0h] [xbp-190h]
  __int64 v25; // [xsp+E8h] [xbp-188h]
  __int64 v26; // [xsp+F0h] [xbp-180h]
  __int64 v27; // [xsp+F8h] [xbp-178h]
  __int64 v28; // [xsp+100h] [xbp-170h]
  __int64 v29; // [xsp+108h] [xbp-168h]
  __int64 v30; // [xsp+110h] [xbp-160h]
  __int64 v31; // [xsp+118h] [xbp-158h]
  __int64 v32; // [xsp+120h] [xbp-150h]
  __int64 v33; // [xsp+128h] [xbp-148h]
  __int64 v34; // [xsp+130h] [xbp-140h]
  __int64 v35; // [xsp+138h] [xbp-138h]
  __int64 v36; // [xsp+140h] [xbp-130h]
  __int64 v37; // [xsp+148h] [xbp-128h]
  __int64 v38; // [xsp+150h] [xbp-120h]
  __int64 v39; // [xsp+158h] [xbp-118h]
  __int64 v40; // [xsp+160h] [xbp-110h] BYREF
  __int64 v41; // [xsp+168h] [xbp-108h]
  int v42; // [xsp+170h] [xbp-100h]

  v1 = a1[4];
  *(_QWORD *)v14 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16400LL);
  v15 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16408LL);
  v16 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16416LL);
  v17 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16416LL);
  v18 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16424LL);
  v19 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16432LL);
  v20 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16416LL);
  v21 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16416LL);
  v22 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16512LL);
  v23 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16520LL);
  v24 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16440LL);
  v25 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16528LL);
  v26 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16528LL);
  v27 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16536LL);
  v28 = **(_QWORD **)(v1 + 16);
  v29 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16448LL);
  v30 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16456LL);
  v31 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16464LL);
  v32 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16472LL);
  v33 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16472LL);
  v34 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16480LL);
  v35 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16488LL);
  v36 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16496LL);
  v37 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16504LL);
  v38 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16544LL);
  v4 = *(_QWORD *)(*(_QWORD *)(v1 + 16) + 16552LL);
  v5 = a1[4];
  v3 = a1[1];
  v39 = v4;
  v40 = v5;
  v41 = sub_183A8(v3);
  v13[0] = (__int64)sub_CEF0;
  v13[1] = (__int64)sub_D154;
  v13[2] = (__int64)sub_DA68;
  v13[3] = (__int64)sub_E068;
  v13[8] = (__int64)sub_E1CC;
  v13[9] = (__int64)sub_E240;
  v10[0] = (__int64)&v40;
  v10[1] = (__int64)v14;
  v42 = sub_183A0(v3);
  v13[4] = (__int64)sub_D5AC;
  v13[5] = (__int64)sub_D788;
  v13[6] = (__int64)sub_D7FC;
  v13[7] = (__int64)sub_E158;
  v13[10] = (__int64)sub_E0E0;
  v13[11] = (__int64)sub_E2B4;
  v10[2] = (__int64)v13;
  v12 = *(_DWORD *)(a1[6] + 4LL);
  sub_10C8C((__int64)v10);
  v6 = *(__int64 ***)v14;
  v7 = v41 + v42 - (_DWORD)dest;
  if ( !v7 )
    return (void *)sub_14CB0(*(__int64 ***)v14, dest, v7);
  v8 = *(unsigned int *)(*(_QWORD *)v14 + 36LL);
  if ( (unsigned int)v8 + v7 >= *(_DWORD *)(*(_QWORD *)v14 + 40LL) )
    return (void *)sub_14CB0(*(__int64 ***)v14, dest, v7);
  result = memcpy(dest, (const void *)(*(_QWORD *)(**(_QWORD **)v14 + 8LL) + v8), v7);
  *((_DWORD *)v6 + 9) += v7;
  return result;
}

//----- (000000000000E5B4) ----------------------------------------------------
__int64 __fastcall sub_E5B4(__int64 result, int a2, __int64 a3, _DWORD *a4)
{
  __int64 v4; // x8
  int v5; // w10
  __int64 v6; // x8

  v4 = (unsigned int)*a4;
  v5 = v4 + 1;
  v6 = a3 + 20 * v4;
  *a4 = v5;
  *(_DWORD *)v6 = result;
  *(_DWORD *)(v6 + 4) = a2;
  *(_QWORD *)(v6 + 8) = 0LL;
  *(_DWORD *)(v6 + 16) = 0;
  return result;
}

//----- (000000000000E5D8) ----------------------------------------------------
long double __usercall sub_E5D8@<Q0>(int a1@<W0>, _DWORD *a2@<X1>, unsigned int *a3@<X2>, __int64 a4@<X8>)
{
  unsigned __int64 v4; // x10
  unsigned __int64 v5; // x9
  _DWORD *v6; // x11
  unsigned int v7; // w10
  long double *v8; // x9
  long double v9; // q0
  long double *v10; // x11
  long double result; // q0

  v4 = *a3;
  if ( (_DWORD)v4 )
  {
    v5 = 0LL;
    v6 = a2;
    do
    {
      if ( *v6 == a1 )
        break;
      ++v5;
      v6 += 5;
    }
    while ( v5 < v4 );
    v7 = v4 - 1;
  }
  else
  {
    LODWORD(v5) = 0;
    v7 = -1;
  }
  v8 = (long double *)&a2[5 * (unsigned int)v5];
  v9 = *v8;
  v10 = (long double *)&a2[5 * v7];
  *(_DWORD *)(a4 + 16) = *((_DWORD *)v8 + 4);
  *(long double *)a4 = v9;
  *a3 = v7;
  result = *v10;
  *((_DWORD *)v8 + 4) = *((_DWORD *)v10 + 4);
  *v8 = result;
  return result;
}

//----- (000000000000E64C) ----------------------------------------------------
__int64 __fastcall sub_E64C(__int64 result, int a2, int a3, __int64 a4, unsigned int a5)
{
  __int64 v5; // x8
  _DWORD *v6; // x9
  int v7; // w11
  int v8; // w12

  if ( a5 )
  {
    v5 = a5;
    v6 = (_DWORD *)(a4 + 16);
    do
    {
      --v5;
      v7 = *(v6 - 1) + a2;
      v8 = *v6 + a3;
      *(v6 - 2) += result;
      *(v6 - 1) = v7;
      *v6 = v8;
      v6 += 5;
    }
    while ( v5 );
  }
  return result;
}

//----- (000000000000E680) ----------------------------------------------------
__int64 __fastcall sub_E680(__int64 a1, unsigned int a2)
{
  unsigned __int64 v2; // x8

  v2 = ((unsigned __int64)*(unsigned int *)(*(_QWORD *)(a1 + 88) + 4LL * a2) >> 1) & 0x7FFFFF;
  if ( (unsigned __int8)HIBYTE(*(_DWORD *)(*(_QWORD *)(a1 + 88) + 4LL * a2)) == 255 )
    LODWORD(v2) = *(_DWORD *)(*(_QWORD *)(a1 + 104) + 8 * v2);
  return (unsigned int)v2;
}

//----- (000000000000E6AC) ----------------------------------------------------
__int64 __fastcall sub_E6AC(__int64 a1, unsigned int a2)
{
  unsigned __int64 v3; // x9
  __int64 result; // x0

  v3 = *(unsigned int *)(*(_QWORD *)(a1 + 88) + 4LL * a2);
  result = (unsigned __int8)HIBYTE(*(_DWORD *)(*(_QWORD *)(a1 + 88) + 4LL * a2));
  if ( (unsigned int)result >= 0xFF )
    result = *(unsigned int *)(*(_QWORD *)(a1 + 104) + 8 * ((v3 >> 1) & 0x7FFFFF) + 4);
  return result;
}

//----- (000000000000E6D8) ----------------------------------------------------
__int64 __fastcall sub_E6D8(unsigned __int8 *a1, int a2)
{
  unsigned int v2; // w8
  unsigned __int8 *v3; // x9
  int v4; // t1

  v2 = 0;
  if ( a2 )
  {
    v3 = &a1[a2];
    do
    {
      v4 = *a1++;
      v2 = (1025 * (v2 + v4)) ^ ((1025 * (v2 + v4)) >> 6);
    }
    while ( a1 < v3 );
  }
  return v2;
}

//----- (000000000000E704) ----------------------------------------------------
__int64 __fastcall sub_E704(unsigned __int16 *a1, int a2)
{
  unsigned int v2; // w8
  unsigned __int16 *v3; // x9
  int v4; // t1

  v2 = 0;
  if ( a2 )
  {
    v3 = &a1[a2];
    do
    {
      v4 = *a1++;
      v2 = (1025 * (v2 + v4)) ^ ((1025 * (v2 + v4)) >> 6);
    }
    while ( a1 < v3 );
  }
  return v2;
}

//----- (000000000000E730) ----------------------------------------------------
__int64 __fastcall sub_E730(__int64 a1, void *dest, int a3, unsigned __int8 *a4)
{
  unsigned int v4; // w19
  _BYTE *v6; // x20
  unsigned __int8 v7; // w8
  __int64 v8; // x0
  unsigned int v9; // w8
  __int64 *v10; // x9
  unsigned int v11; // w8
  __int64 v12; // x0
  unsigned int v13; // w8
  __int64 *v14; // x9
  __int64 v15; // x8
  __int64 *v16; // x8
  unsigned int v17; // w9
  __int64 v18; // x10
  __int64 v19; // x8
  __int64 *v20; // x8
  unsigned int v21; // w9
  __int64 v22; // x10
  __int64 v23; // x8
  __int64 *v24; // x8
  unsigned int v25; // w9
  __int64 v26; // x10
  __int64 v27; // x8
  __int64 v28; // x0
  unsigned int v29; // w8
  __int64 *v30; // x9
  __int64 v31; // x8
  __int64 *v32; // x8
  unsigned int v33; // w9
  __int64 v34; // x10
  __int64 v35; // x8
  __int64 *v36; // x8
  unsigned int v37; // w9
  __int64 v38; // x10
  __int64 v39; // x8
  __int64 *v40; // x8
  unsigned int v41; // w9
  __int64 v42; // x10
  __int64 v43; // x8
  __int64 v44; // x0
  unsigned int v45; // w8
  __int64 *v46; // x9
  __int64 v47; // x8
  __int64 v48; // x0
  __int64 v49; // x0
  unsigned int v50; // w8
  __int64 *v51; // x9
  __int64 v52; // x8
  __int64 *v53; // x8
  unsigned int v54; // w9
  __int64 v55; // x10
  __int64 v56; // x8
  __int64 *v57; // x8
  unsigned int v58; // w9
  __int64 v59; // x10
  __int64 v60; // x8
  __int64 v61; // x0
  unsigned int v62; // w8
  __int64 *v63; // x9
  __int64 v64; // x8
  unsigned int v65; // w8
  __int64 *v66; // x9
  __int64 v67; // x8
  __int64 v68; // x0
  _BYTE *v69; // x1
  __int64 *v70; // x8
  unsigned int v71; // w9
  __int64 v72; // x10
  _BYTE *v73; // x1
  unsigned int v74; // w8
  __int64 *v75; // x9
  _BYTE *v76; // x1
  __int64 *v77; // x8
  unsigned int v78; // w9
  __int64 v79; // x10
  _BYTE *v80; // x1
  __int64 *v81; // x8
  unsigned int v82; // w9
  __int64 v83; // x10
  __int64 v84; // x0
  unsigned int v85; // w8
  __int64 *v86; // x9
  __int64 v87; // x8
  __int64 v88; // x0
  __int64 *v89; // x8
  unsigned int v90; // w9
  __int64 v91; // x10
  __int64 v92; // x8
  __int64 *v93; // x8
  unsigned int v94; // w9
  __int64 v95; // x10
  __int64 v96; // x8
  __int64 v97; // x0
  unsigned int v98; // w8
  __int64 *v99; // x9
  __int64 v100; // x8
  unsigned int v101; // w8
  __int64 *v102; // x9
  __int64 v103; // x8
  __int64 v104; // x0
  unsigned int v105; // w8
  __int64 *v106; // x9
  __int64 v107; // x8
  __int64 v108; // x0
  unsigned int v109; // w8
  __int64 *v110; // x9
  __int64 v111; // x8
  char v112; // w9
  char v113; // w10
  char v114; // w11
  __int64 *v115; // x8
  unsigned int v116; // w9
  __int64 v117; // x10
  __int64 v118; // x8
  __int64 v119; // x21
  unsigned int v120; // w8
  __int64 *v121; // x9
  __int64 v122; // x8
  unsigned int v123; // w8
  __int64 *v124; // x9
  unsigned __int64 v125; // x8
  _BYTE *v126; // x1
  unsigned __int64 v127; // x10
  char v128; // w14
  char v129; // w15
  unsigned __int64 v130; // x11
  char v131; // w13
  char v132; // w15
  char v133; // w9
  char v134; // w12
  unsigned int v135; // w13
  __int64 v136; // x8
  unsigned int v137; // w9
  __int64 *v138; // x10
  __int64 v139; // x0
  unsigned int v140; // w8
  __int64 *v141; // x9
  __int64 v142; // x8
  _BYTE *v143; // x1
  __int64 *v144; // x8
  unsigned int v145; // w9
  __int64 v146; // x10
  __int64 v147; // x0
  _BYTE *v148; // x1
  __int64 *v149; // x8
  unsigned int v150; // w9
  __int64 v151; // x10
  _BYTE *v152; // x1
  __int64 *v153; // x8
  unsigned int v154; // w9
  __int64 v155; // x10
  __int64 v156; // x0
  __int64 v157; // x0
  _BYTE *v158; // x1
  __int64 *v159; // x8
  unsigned int v160; // w9
  __int64 v161; // x10
  unsigned int v162; // w8
  __int64 *v163; // x9
  __int64 v164; // x8
  __int64 v165; // x0
  unsigned int v166; // w8
  __int64 *v167; // x9
  __int64 v168; // x8
  __int64 v169; // x0
  __int64 v170; // x0
  _BYTE *v171; // x1
  unsigned int v172; // w8
  __int64 *v173; // x9
  __int64 v174; // x0
  unsigned int v175; // w8
  __int64 *v176; // x9
  __int64 v177; // x8
  unsigned int v178; // w8
  __int64 *v179; // x9
  __int64 v180; // x8
  unsigned __int64 v181; // x8
  char v182; // w10
  char v183; // w11
  char v184; // w12
  char v185; // w13
  char v186; // w9
  char v187; // w10
  char v188; // w11
  __int64 *v189; // x9
  __int64 v190; // x0
  unsigned int v191; // w8
  __int64 *v192; // x9
  __int64 v193; // x8
  _BYTE *v194; // x1
  __int64 v195; // x0
  unsigned int v196; // w8
  __int64 *v197; // x9
  __int64 v198; // x0
  unsigned int v199; // w8
  __int64 *v200; // x9
  __int64 v201; // x8
  unsigned int v202; // w8
  __int64 *v203; // x9
  __int64 v204; // x8
  unsigned int v205; // w8
  __int64 *v206; // x9
  __int64 v207; // x8
  _BYTE *v208; // x1
  unsigned int v209; // w8
  __int64 *v210; // x9
  __int64 v212; // x0
  unsigned int v213; // w8
  __int64 *v214; // x9
  __int64 v215; // x8
  __int64 v216; // x0
  unsigned int v217; // w8
  __int64 *v218; // x9
  __int64 v219; // x8
  unsigned __int64 v220; // x8
  char v221; // w10
  char v222; // w11
  char v223; // w12
  char v224; // w13
  char v225; // w9
  char v226; // w10
  char v227; // w11
  __int64 v228; // x0
  unsigned int v229; // w8
  __int64 *v230; // x9
  __int64 v231; // x8
  __int64 v232; // x0
  unsigned int v233; // w8
  __int64 *v234; // x9
  unsigned __int64 v235; // x8
  char v236; // w10
  char v237; // w11
  char v238; // w12
  char v239; // w13
  char v240; // w9
  char v241; // w10
  char v242; // w11
  unsigned int v243; // w8
  __int64 *v244; // x9
  unsigned __int64 v245; // x8
  char v246; // w10
  char v247; // w11
  char v248; // w12
  char v249; // w13
  char v250; // w9
  char v251; // w10
  char v252; // w11
  __int64 v253; // x0
  unsigned int v254; // w8
  __int64 *v255; // x9
  __int64 v256; // x8
  unsigned __int64 v257; // x8
  char v258; // w11
  char v259; // w12
  char v260; // w13
  char v261; // w10
  char v262; // w14
  char v263; // w9
  char v264; // w10
  char v265; // w12
  char v266; // w9
  unsigned __int64 v267; // x10
  char v268; // w11
  char v269; // w13
  char v270; // w14
  char v271; // w15
  char v272; // w12
  __int64 v273; // x0
  unsigned int v274; // w8
  __int64 *v275; // x9
  unsigned __int64 v276; // x8
  char v277; // w10
  char v278; // w11
  char v279; // w12
  char v280; // w13
  char v281; // w9
  char v282; // w10
  char v283; // w11
  unsigned int v284; // w8
  __int64 *v285; // x9
  char v286; // w13
  char v287; // w14
  char v288; // w15
  char v289; // w16
  unsigned __int64 v290; // x17
  unsigned __int64 v291; // x0
  unsigned __int64 v292; // x1
  char v293; // w10
  char v294; // w11
  char v295; // w12
  unsigned __int64 v296; // x8
  char v297; // w9
  char v298; // w10
  char v299; // w11
  unsigned __int64 v300; // x12
  char v301; // w13
  char v302; // w14
  char v303; // w15
  char v304; // w16
  unsigned __int64 v305; // x17
  char v306; // w10
  unsigned __int64 v307; // x0
  char v308; // w9
  char v309; // w13
  char v310; // w14
  char v311; // w16
  char v312; // w11
  _BYTE *v313; // x1
  __int64 *v314; // x8
  unsigned int v315; // w9
  __int64 v316; // x10
  _BYTE *v317; // x1
  __int64 *v318; // x8
  unsigned int v319; // w9
  __int64 v320; // x10
  _BYTE *v321; // x1
  __int64 *v322; // x8
  unsigned int v323; // w9
  __int64 v324; // x10
  _BYTE *v325; // x1
  __int64 *v326; // x8
  unsigned int v327; // w9
  __int64 v328; // x10
  char v329; // w9
  char v330; // w9
  char v331; // w10
  char v332; // w11
  char v333; // w9
  char v334; // w9
  char v335; // w9
  char v336; // w9
  char v337; // w10
  char v338; // w11
  char v339; // w9
  char v340; // w10
  char v341; // w11
  __int64 v342; // x21
  char v343; // w9
  __int64 v344; // x21
  char v345; // w9
  __int64 v346; // x21
  char v347; // w9
  char v348; // w9
  __int64 v349; // x21
  char v350; // w9
  __int64 v351; // x21
  char v352; // w9
  __int64 v353; // x21
  char v354; // w9
  char v355; // w10
  char v356; // w11
  char v357; // w9
  char v358; // w10
  char v359; // w11
  __int64 v360; // x21
  char v361; // w9
  __int64 v362; // x21
  char v363; // w9
  char v364; // w9
  char v365; // w10
  char v366; // w11
  __int64 v367; // x21
  __int64 v368; // x21
  __int64 v369; // x21
  char v370; // w9
  __int64 v371; // x21
  char v372; // w9
  char v373; // w10
  char v374; // w11
  __int64 v375; // x21
  char v376; // w9
  char v377; // w10
  char v378; // w11
  char v379; // w9
  char v380; // w9
  char v381; // w10
  char v382; // w11
  char v383; // w8
  char v384; // w9
  char v385; // w11
  char v386; // w10
  unsigned __int8 v387; // w9
  unsigned __int8 v388; // w11
  __int64 v389; // x21
  char v390; // w9
  char v391; // w10
  char v392; // w11
  char v393; // w9
  char v394; // w10
  char v395; // w11
  char v396; // w9
  __int64 v397; // x21
  __int64 v398; // x21
  __int64 v399; // x21
  __int64 v400; // x21
  char v401; // w9
  char v402; // w9
  unsigned __int8 v403; // w9
  unsigned __int8 v404; // w11
  char v405; // w9
  char v406; // w9
  char v407; // w9
  char v408; // w10
  char v409; // w11
  unsigned __int8 v410; // w9
  unsigned __int8 v411; // w9
  __int64 v412; // x21
  __int64 v413; // x21
  __int64 v414; // x21
  __int64 v415; // x21
  __int64 v416; // [xsp+0h] [xbp-30h]
  __int64 v417; // [xsp+0h] [xbp-30h]
  __int64 v418; // [xsp+0h] [xbp-30h]
  __int64 v419; // [xsp+0h] [xbp-30h]
  __int64 v420; // [xsp+0h] [xbp-30h]
  __int64 v421; // [xsp+0h] [xbp-30h]
  int8x8_t desta; // [xsp+8h] [xbp-28h] BYREF

  v4 = dword_1C658[a3 + 1];
  v6 = dest;
  switch ( a3 )
  {
    case -1:
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8LL);
      v9 = *(_DWORD *)(v8 + 36) + 1;
      if ( v9 >= *(_DWORD *)(v8 + 40) )
        goto LABEL_211;
      v10 = *(__int64 **)v8;
      *(_DWORD *)(v8 + 36) = v9;
      *(_BYTE *)dest = *(_BYTE *)(v10[1] + v9 - 1);
      return v4;
    case 0:
      dest = (char *)dest + 1;
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 16LL);
      v11 = *(_DWORD *)(v8 + 36) + 1;
      if ( v11 < *(_DWORD *)(v8 + 40) )
        goto LABEL_132;
      goto LABEL_211;
    case 1:
      v12 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24LL);
      v13 = *(_DWORD *)(v12 + 36) + 4;
      if ( v13 >= *(_DWORD *)(v12 + 40) )
      {
        sub_14CB0((__int64 **)v12, (char *)dest + 1, 4);
        v339 = v6[1];
        v340 = v6[3];
        v341 = v6[2];
        v6[1] = v6[4];
        v6[4] = v339;
        v6[2] = v340;
        v6[3] = v341;
      }
      else
      {
        v14 = *(__int64 **)v12;
        *(_DWORD *)(v12 + 36) = v13;
        v15 = v14[1] + v13;
        *((_BYTE *)dest + 1) = *(_BYTE *)(v15 - 1);
        *((_BYTE *)dest + 2) = *(_BYTE *)(v15 - 2);
        *((_BYTE *)dest + 3) = *(_BYTE *)(v15 - 3);
        *((_BYTE *)dest + 4) = *(_BYTE *)(v15 - 4);
      }
      return v4;
    case 5:
      *((_BYTE *)dest + 1) = *a4;
      v16 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 32LL);
      v17 = *((_DWORD *)v16 + 9) + 2;
      if ( v17 >= *((_DWORD *)v16 + 10) )
      {
        v342 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 32LL), (char *)dest + 2, 2);
        v343 = v6[2];
        a1 = v342;
        v6[2] = v6[3];
        v6[3] = v343;
      }
      else
      {
        v18 = *v16;
        *((_DWORD *)v16 + 9) = v17;
        v19 = *(_QWORD *)(v18 + 8) + v17;
        *((_BYTE *)dest + 2) = *(_BYTE *)(v19 - 1);
        *((_BYTE *)dest + 3) = *(_BYTE *)(v19 - 2);
      }
      v20 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 40LL);
      v21 = *((_DWORD *)v20 + 9) + 2;
      if ( v21 >= *((_DWORD *)v20 + 10) )
      {
        v344 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 40LL), v6 + 4, 2);
        v345 = v6[4];
        a1 = v344;
        v6[4] = v6[5];
        v6[5] = v345;
      }
      else
      {
        v22 = *v20;
        *((_DWORD *)v20 + 9) = v21;
        v23 = *(_QWORD *)(v22 + 8) + v21;
        v6[4] = *(_BYTE *)(v23 - 1);
        v6[5] = *(_BYTE *)(v23 - 2);
      }
      v24 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 48LL);
      v25 = *((_DWORD *)v24 + 9) + 2;
      if ( v25 >= *((_DWORD *)v24 + 10) )
      {
        v346 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 48LL), v6 + 6, 2);
        v347 = v6[6];
        a1 = v346;
        v6[6] = v6[7];
        v6[7] = v347;
      }
      else
      {
        v26 = *v24;
        *((_DWORD *)v24 + 9) = v25;
        v27 = *(_QWORD *)(v26 + 8) + v25;
        v6[6] = *(_BYTE *)(v27 - 1);
        v6[7] = *(_BYTE *)(v27 - 2);
      }
      v28 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56LL);
      v29 = *(_DWORD *)(v28 + 36) + 2;
      if ( v29 >= *(_DWORD *)(v28 + 40) )
      {
        sub_14CB0((__int64 **)v28, v6 + 8, 2);
        v348 = v6[8];
        v6[8] = v6[9];
        v6[9] = v348;
      }
      else
      {
        v30 = *(__int64 **)v28;
        *(_DWORD *)(v28 + 36) = v29;
        v31 = v30[1] + v29;
        v6[8] = *(_BYTE *)(v31 - 1);
        v6[9] = *(_BYTE *)(v31 - 2);
      }
      return v4;
    case 6:
      *((_BYTE *)dest + 1) = *a4;
      v32 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 64LL);
      v33 = *((_DWORD *)v32 + 9) + 2;
      if ( v33 >= *((_DWORD *)v32 + 10) )
      {
        v349 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 64LL), (char *)dest + 2, 2);
        v350 = v6[2];
        a1 = v349;
        v6[2] = v6[3];
        v6[3] = v350;
      }
      else
      {
        v34 = *v32;
        *((_DWORD *)v32 + 9) = v33;
        v35 = *(_QWORD *)(v34 + 8) + v33;
        *((_BYTE *)dest + 2) = *(_BYTE *)(v35 - 1);
        *((_BYTE *)dest + 3) = *(_BYTE *)(v35 - 2);
      }
      v36 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 72LL);
      v37 = *((_DWORD *)v36 + 9) + 2;
      if ( v37 >= *((_DWORD *)v36 + 10) )
      {
        v351 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 72LL), v6 + 4, 2);
        v352 = v6[4];
        a1 = v351;
        v6[4] = v6[5];
        v6[5] = v352;
      }
      else
      {
        v38 = *v36;
        *((_DWORD *)v36 + 9) = v37;
        v39 = *(_QWORD *)(v38 + 8) + v37;
        v6[4] = *(_BYTE *)(v39 - 1);
        v6[5] = *(_BYTE *)(v39 - 2);
      }
      v40 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 80LL);
      v41 = *((_DWORD *)v40 + 9) + 4;
      if ( v41 >= *((_DWORD *)v40 + 10) )
      {
        v353 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 80LL), v6 + 6, 4);
        v354 = v6[6];
        v355 = v6[8];
        v356 = v6[7];
        a1 = v353;
        v6[6] = v6[9];
        v6[9] = v354;
        v6[7] = v355;
        v6[8] = v356;
      }
      else
      {
        v42 = *v40;
        *((_DWORD *)v40 + 9) = v41;
        v43 = *(_QWORD *)(v42 + 8) + v41;
        v6[6] = *(_BYTE *)(v43 - 1);
        v6[7] = *(_BYTE *)(v43 - 2);
        v6[8] = *(_BYTE *)(v43 - 3);
        v6[9] = *(_BYTE *)(v43 - 4);
      }
      v44 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 88LL);
      v45 = *(_DWORD *)(v44 + 36) + 4;
      if ( v45 >= *(_DWORD *)(v44 + 40) )
      {
        sub_14CB0((__int64 **)v44, v6 + 10, 4);
        v357 = v6[10];
        v358 = v6[12];
        v359 = v6[11];
        v6[10] = v6[13];
        v6[13] = v357;
        v6[11] = v358;
        v6[12] = v359;
      }
      else
      {
        v46 = *(__int64 **)v44;
        *(_DWORD *)(v44 + 36) = v45;
        v47 = v46[1] + v45;
        v6[10] = *(_BYTE *)(v47 - 1);
        v6[11] = *(_BYTE *)(v47 - 2);
        v6[12] = *(_BYTE *)(v47 - 3);
        v6[13] = *(_BYTE *)(v47 - 4);
      }
      return v4;
    case 7:
      *((_BYTE *)dest + 1) = *a4;
      v48 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 96LL);
      goto LABEL_44;
    case 8:
      *((_BYTE *)dest + 1) = *a4;
      v49 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 104LL);
      goto LABEL_32;
    case 9:
      *((_BYTE *)dest + 1) = *a4;
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 112LL);
      goto LABEL_35;
    case 10:
      *((_BYTE *)dest + 1) = *a4;
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 120LL);
      goto LABEL_35;
    case 11:
      *((_BYTE *)dest + 1) = *a4;
      v49 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 128LL);
LABEL_32:
      v50 = *(_DWORD *)(v49 + 36) + 2;
      if ( v50 >= *(_DWORD *)(v49 + 40) )
      {
        sub_14CB0((__int64 **)v49, (char *)dest + 2, 2);
        v335 = v6[2];
        v6[2] = v6[3];
        v6[3] = v335;
      }
      else
      {
        v51 = *(__int64 **)v49;
        *(_DWORD *)(v49 + 36) = v50;
        v52 = v51[1] + v50;
        *((_BYTE *)dest + 2) = *(_BYTE *)(v52 - 1);
        v7 = *(_BYTE *)(v52 - 2);
LABEL_182:
        v6[3] = v7;
      }
      return v4;
    case 12:
    case 13:
    case 15:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 28:
    case 32:
    case 33:
    case 35:
    case 39:
      *((_BYTE *)dest + 1) = *a4;
      return v4;
    case 14:
      *((_BYTE *)dest + 1) = *a4;
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 136LL);
LABEL_35:
      dest = (char *)dest + 2;
      v11 = *(_DWORD *)(v8 + 36) + 1;
      if ( v11 >= *(_DWORD *)(v8 + 40) )
        goto LABEL_211;
      goto LABEL_132;
    case 16:
      *((_BYTE *)dest + 1) = *a4;
      v53 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 144LL);
      v54 = *((_DWORD *)v53 + 9) + 2;
      if ( v54 >= *((_DWORD *)v53 + 10) )
      {
        v360 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 144LL), (char *)dest + 2, 2);
        v361 = v6[2];
        a1 = v360;
        v6[2] = v6[3];
        v6[3] = v361;
      }
      else
      {
        v55 = *v53;
        *((_DWORD *)v53 + 9) = v54;
        v56 = *(_QWORD *)(v55 + 8) + v54;
        *((_BYTE *)dest + 2) = *(_BYTE *)(v56 - 1);
        *((_BYTE *)dest + 3) = *(_BYTE *)(v56 - 2);
      }
      v57 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 152LL);
      v58 = *((_DWORD *)v57 + 9) + 2;
      if ( v58 >= *((_DWORD *)v57 + 10) )
      {
        v362 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 152LL), v6 + 4, 2);
        v363 = v6[4];
        a1 = v362;
        v6[4] = v6[5];
        v6[5] = v363;
      }
      else
      {
        v59 = *v57;
        *((_DWORD *)v57 + 9) = v58;
        v60 = *(_QWORD *)(v59 + 8) + v58;
        v6[4] = *(_BYTE *)(v60 - 1);
        v6[5] = *(_BYTE *)(v60 - 2);
      }
      v61 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 160LL);
      v62 = *(_DWORD *)(v61 + 36) + 4;
      if ( v62 >= *(_DWORD *)(v61 + 40) )
      {
        sub_14CB0((__int64 **)v61, v6 + 6, 4);
        v364 = v6[6];
        v365 = v6[8];
        v366 = v6[7];
        v6[6] = v6[9];
        v6[9] = v364;
        v6[7] = v365;
        v6[8] = v366;
      }
      else
      {
        v63 = *(__int64 **)v61;
        *(_DWORD *)(v61 + 36) = v62;
        v64 = v63[1] + v62;
        v6[6] = *(_BYTE *)(v64 - 1);
        v6[7] = *(_BYTE *)(v64 - 2);
        v6[8] = *(_BYTE *)(v64 - 3);
        v6[9] = *(_BYTE *)(v64 - 4);
      }
      return v4;
    case 17:
      *((_BYTE *)dest + 1) = *a4;
      v48 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 168LL);
LABEL_44:
      v65 = *(_DWORD *)(v48 + 36) + 4;
      if ( v65 >= *(_DWORD *)(v48 + 40) )
      {
        sub_14CB0((__int64 **)v48, (char *)dest + 2, 4);
        v336 = v6[2];
        v337 = v6[4];
        v338 = v6[3];
        v6[2] = v6[5];
        v6[5] = v336;
        v6[3] = v337;
        v6[4] = v338;
      }
      else
      {
        v66 = *(__int64 **)v48;
        *(_DWORD *)(v48 + 36) = v65;
        v67 = v66[1] + v65;
        *((_BYTE *)dest + 2) = *(_BYTE *)(v67 - 1);
        *((_BYTE *)dest + 3) = *(_BYTE *)(v67 - 2);
        *((_BYTE *)dest + 4) = *(_BYTE *)(v67 - 3);
        *((_BYTE *)dest + 5) = *(_BYTE *)(v67 - 4);
      }
      return v4;
    case 18:
      v68 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 176LL);
      goto LABEL_52;
    case 19:
      v69 = (char *)dest + 2;
      v6[1] = *a4;
      v70 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 184LL);
      v71 = *((_DWORD *)v70 + 9) + 1;
      if ( v71 >= *((_DWORD *)v70 + 10) )
      {
        v367 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 184LL), v69, 1);
        a1 = v367;
      }
      else
      {
        v72 = *v70;
        *((_DWORD *)v70 + 9) = v71;
        *v69 = *(_BYTE *)(*(_QWORD *)(v72 + 8) + v71 - 1LL);
      }
      dest = v6 + 3;
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 192LL);
      v11 = *(_DWORD *)(v8 + 36) + 1;
      if ( v11 >= *(_DWORD *)(v8 + 40) )
        goto LABEL_211;
      goto LABEL_132;
    case 20:
      v68 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 200LL);
LABEL_52:
      v73 = (char *)dest + 1;
      v74 = *(_DWORD *)(v68 + 36) + 1;
      if ( v74 < *(_DWORD *)(v68 + 40) )
        goto LABEL_53;
      goto LABEL_77;
    case 26:
      v76 = (char *)dest + 2;
      v6[1] = *a4;
      v77 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 208LL);
      v78 = *((_DWORD *)v77 + 9) + 1;
      if ( v78 >= *((_DWORD *)v77 + 10) )
      {
        v368 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 208LL), v76, 1);
        a1 = v368;
      }
      else
      {
        v79 = *v77;
        *((_DWORD *)v77 + 9) = v78;
        *v76 = *(_BYTE *)(*(_QWORD *)(v79 + 8) + v78 - 1LL);
      }
      v80 = v6 + 4;
      v81 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 216LL);
      v82 = *((_DWORD *)v81 + 9) + 1;
      if ( v82 >= *((_DWORD *)v81 + 10) )
      {
        v369 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 216LL), v80, 1);
        a1 = v369;
      }
      else
      {
        v83 = *v81;
        *((_DWORD *)v81 + 9) = v82;
        *v80 = *(_BYTE *)(*(_QWORD *)(v83 + 8) + v82 - 1LL);
      }
      v84 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 224LL);
      v85 = *(_DWORD *)(v84 + 36) + 2;
      if ( v85 >= *(_DWORD *)(v84 + 40) )
      {
        sub_14CB0((__int64 **)v84, v6 + 6, 2);
        v370 = v6[6];
        v6[6] = v6[7];
        v6[7] = v370;
      }
      else
      {
        v86 = *(__int64 **)v84;
        *(_DWORD *)(v84 + 36) = v85;
        v87 = v86[1] + v85;
        v6[6] = *(_BYTE *)(v87 - 1);
        v6[7] = *(_BYTE *)(v87 - 2);
      }
      return v4;
    case 27:
      v88 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 232LL);
      goto LABEL_69;
    case 29:
      *((_BYTE *)dest + 1) = *a4;
      v89 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 240LL);
      v90 = *((_DWORD *)v89 + 9) + 4;
      if ( v90 >= *((_DWORD *)v89 + 10) )
      {
        v371 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 240LL), (char *)dest + 2, 4);
        v372 = v6[2];
        v373 = v6[4];
        v374 = v6[3];
        a1 = v371;
        v6[2] = v6[5];
        v6[5] = v372;
        v6[3] = v373;
        v6[4] = v374;
      }
      else
      {
        v91 = *v89;
        *((_DWORD *)v89 + 9) = v90;
        v92 = *(_QWORD *)(v91 + 8) + v90;
        *((_BYTE *)dest + 2) = *(_BYTE *)(v92 - 1);
        *((_BYTE *)dest + 3) = *(_BYTE *)(v92 - 2);
        *((_BYTE *)dest + 4) = *(_BYTE *)(v92 - 3);
        *((_BYTE *)dest + 5) = *(_BYTE *)(v92 - 4);
      }
      v93 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 248LL);
      v94 = *((_DWORD *)v93 + 9) + 4;
      if ( v94 >= *((_DWORD *)v93 + 10) )
      {
        v375 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 248LL), v6 + 6, 4);
        v376 = v6[6];
        v377 = v6[8];
        v378 = v6[7];
        a1 = v375;
        v6[6] = v6[9];
        v6[9] = v376;
        v6[7] = v377;
        v6[8] = v378;
      }
      else
      {
        v95 = *v93;
        *((_DWORD *)v93 + 9) = v94;
        v96 = *(_QWORD *)(v95 + 8) + v94;
        v6[6] = *(_BYTE *)(v96 - 1);
        v6[7] = *(_BYTE *)(v96 - 2);
        v6[8] = *(_BYTE *)(v96 - 3);
        v6[9] = *(_BYTE *)(v96 - 4);
      }
      v97 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 256LL);
      v98 = *(_DWORD *)(v97 + 36) + 2;
      if ( v98 >= *(_DWORD *)(v97 + 40) )
      {
        sub_14CB0((__int64 **)v97, v6 + 10, 2);
        v379 = v6[10];
        v6[10] = v6[11];
        v6[11] = v379;
      }
      else
      {
        v99 = *(__int64 **)v97;
        *(_DWORD *)(v97 + 36) = v98;
        v100 = v99[1] + v98;
        v6[10] = *(_BYTE *)(v100 - 1);
        v6[11] = *(_BYTE *)(v100 - 2);
      }
      return v4;
    case 30:
      v88 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 264LL);
LABEL_69:
      v101 = *(_DWORD *)(v88 + 36) + 4;
      if ( v101 < *(_DWORD *)(v88 + 40) )
        goto LABEL_70;
      goto LABEL_81;
    case 31:
      *((_BYTE *)dest + 1) = *a4;
      v104 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 272LL);
      v105 = *(_DWORD *)(v104 + 36) + 8;
      if ( v105 >= *(_DWORD *)(v104 + 40) )
      {
        sub_14CB0((__int64 **)v104, (char *)dest + 2, 8);
        v380 = v6[2];
        v381 = v6[3];
        v382 = v6[8];
        v6[2] = v6[9];
        v383 = v6[4];
        v6[9] = v380;
        v384 = v6[7];
        v6[3] = v382;
        v385 = v6[6];
        v6[8] = v381;
        v386 = v6[5];
        v6[4] = v384;
        v6[7] = v383;
        v6[5] = v385;
        v6[6] = v386;
      }
      else
      {
        v106 = *(__int64 **)v104;
        *(_DWORD *)(v104 + 36) = v105;
        v107 = v106[1] + v105;
        *((_BYTE *)dest + 2) = *(_BYTE *)(v107 - 1);
        *((_BYTE *)dest + 3) = *(_BYTE *)(v107 - 2);
        *((_BYTE *)dest + 4) = *(_BYTE *)(v107 - 3);
        *((_BYTE *)dest + 5) = *(_BYTE *)(v107 - 4);
        *((_BYTE *)dest + 6) = *(_BYTE *)(v107 - 5);
        *((_BYTE *)dest + 7) = *(_BYTE *)(v107 - 6);
        *((_BYTE *)dest + 8) = *(_BYTE *)(v107 - 7);
        *((_BYTE *)dest + 9) = *(_BYTE *)(v107 - 8);
      }
      return v4;
    case 34:
      *((_BYTE *)dest + 1) = *a4;
      v108 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 280LL);
      desta.n64_u64[0] = 0LL;
      v109 = *(_DWORD *)(v108 + 36) + 4;
      if ( v109 >= *(_DWORD *)(v108 + 40) )
      {
        sub_14CB0((__int64 **)v108, &desta, 4);
        v387 = desta.n64_u8[0];
        v388 = desta.n64_u8[1];
        desta.n64_u8[0] = desta.n64_u8[3];
        desta.n64_u8[3] = v387;
        desta.n64_u8[1] = desta.n64_u8[2];
        desta.n64_u8[2] = v388;
      }
      else
      {
        v110 = *(__int64 **)v108;
        *(_DWORD *)(v108 + 36) = v109;
        v111 = v110[1] + v109;
        desta.n64_u8[0] = *(_BYTE *)(v111 - 1);
        desta.n64_u8[1] = *(_BYTE *)(v111 - 2);
        desta.n64_u8[2] = *(_BYTE *)(v111 - 3);
        desta.n64_u8[3] = *(_BYTE *)(v111 - 4);
      }
      *(int8x8_t *)(v6 + 2) = vorr_s8(*(int8x8_t *)(v6 + 2), desta);
      return v4;
    case 36:
      v73 = (char *)dest + 1;
      v68 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 288LL);
      v74 = *(_DWORD *)(v68 + 36) + 1;
      if ( v74 < *(_DWORD *)(v68 + 40) )
      {
LABEL_53:
        v75 = *(__int64 **)v68;
        *(_DWORD *)(v68 + 36) = v74;
        *v73 = *(_BYTE *)(v75[1] + v74 - 1);
      }
      else
      {
LABEL_77:
        sub_14CB0((__int64 **)v68, v73, 1);
      }
      v6[2] = *a4;
      return v4;
    case 37:
      dest = (char *)dest + 2;
      v6[1] = *a4;
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 296LL);
      v11 = *(_DWORD *)(v8 + 36) + 1;
      if ( v11 >= *(_DWORD *)(v8 + 40) )
        goto LABEL_211;
      goto LABEL_132;
    case 38:
      v88 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 304LL);
      v101 = *(_DWORD *)(v88 + 36) + 4;
      if ( v101 < *(_DWORD *)(v88 + 40) )
      {
LABEL_70:
        v102 = *(__int64 **)v88;
        *(_DWORD *)(v88 + 36) = v101;
        v103 = v102[1] + v101;
        *((_BYTE *)dest + 1) = *(_BYTE *)(v103 - 1);
        *((_BYTE *)dest + 2) = *(_BYTE *)(v103 - 2);
        *((_BYTE *)dest + 3) = *(_BYTE *)(v103 - 3);
        *((_BYTE *)dest + 4) = *(_BYTE *)(v103 - 4);
      }
      else
      {
LABEL_81:
        sub_14CB0((__int64 **)v88, (char *)dest + 1, 4);
        v112 = v6[1];
        v113 = v6[3];
        v114 = v6[2];
        v6[1] = v6[4];
        v6[4] = v112;
        v6[2] = v113;
        v6[3] = v114;
      }
      goto LABEL_198;
    case 40:
      *((_BYTE *)dest + 1) = *a4;
      v115 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 312LL);
      v116 = *((_DWORD *)v115 + 9) + 4;
      if ( v116 >= *((_DWORD *)v115 + 10) )
      {
        v389 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 312LL), (char *)dest + 2, 4);
        v390 = v6[2];
        v391 = v6[4];
        v392 = v6[3];
        a1 = v389;
        v6[2] = v6[5];
        v6[5] = v390;
        v6[3] = v391;
        v6[4] = v392;
      }
      else
      {
        v117 = *v115;
        *((_DWORD *)v115 + 9) = v116;
        v118 = *(_QWORD *)(v117 + 8) + v116;
        *((_BYTE *)dest + 2) = *(_BYTE *)(v118 - 1);
        *((_BYTE *)dest + 3) = *(_BYTE *)(v118 - 2);
        *((_BYTE *)dest + 4) = *(_BYTE *)(v118 - 3);
        *((_BYTE *)dest + 5) = *(_BYTE *)(v118 - 4);
      }
      v119 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 320LL);
      v120 = *(_DWORD *)(v119 + 36) + 4;
      if ( v120 >= *(_DWORD *)(v119 + 40) )
      {
        v416 = a1;
        sub_14CB0((__int64 **)v119, v6 + 6, 4);
        v393 = v6[6];
        v394 = v6[8];
        v395 = v6[7];
        a1 = v416;
        v6[6] = v6[9];
        v6[9] = v393;
        v6[7] = v394;
        v6[8] = v395;
      }
      else
      {
        v121 = *(__int64 **)v119;
        *(_DWORD *)(v119 + 36) = v120;
        v122 = v121[1] + v120;
        v6[6] = *(_BYTE *)(v122 - 1);
        v6[7] = *(_BYTE *)(v122 - 2);
        v6[8] = *(_BYTE *)(v122 - 3);
        v6[9] = *(_BYTE *)(v122 - 4);
      }
      desta.n64_u64[0] = 0LL;
      v123 = *(_DWORD *)(v119 + 36) + 1;
      if ( v123 >= *(_DWORD *)(v119 + 40) )
      {
        v417 = a1;
        sub_14CB0((__int64 **)v119, &desta, 1);
        a1 = v417;
      }
      else
      {
        v124 = *(__int64 **)v119;
        *(_DWORD *)(v119 + 36) = v123;
        desta.n64_u8[0] = *(_BYTE *)(v124[1] + v123 - 1);
      }
      v125 = desta.n64_u64[0];
      v126 = v6 + 10;
      v127 = desta.n64_u64[0] >> 31;
      v128 = v6[11];
      v129 = v6[12];
      v130 = desta.n64_u64[0] >> 39;
      v131 = v6[7];
      v6[10] |= desta.n64_u32[0] >> 23;
      LOBYTE(v130) = v129 | v130;
      v132 = v6[9];
      v133 = v6[13] | (v125 >> 47);
      v134 = v131 | (2 * v125);
      v135 = (unsigned __int8)v6[8] | ((unsigned int)v125 >> 7);
      v6[7] = v134;
      v6[8] = v135;
      v6[9] = v132 | ((unsigned int)v125 >> 15);
      v6[11] = v128 | v127;
      v6[12] = v130;
      v6[13] = v133;
      v6[14] |= v125 >> 55;
      v136 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 328LL);
      v137 = *(_DWORD *)(v136 + 36) + 1;
      if ( v137 >= *(_DWORD *)(v136 + 40) )
      {
        v418 = a1;
        sub_14CB0((__int64 **)v136, v126, 1);
        a1 = v418;
      }
      else
      {
        v138 = *(__int64 **)v136;
        *(_DWORD *)(v136 + 36) = v137;
        *v126 = *(_BYTE *)(v138[1] + v137 - 1);
      }
      v139 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 336LL);
      v140 = *(_DWORD *)(v139 + 36) + 2;
      if ( v140 >= *(_DWORD *)(v139 + 40) )
      {
        sub_14CB0((__int64 **)v139, v6 + 14, 2);
        v396 = v6[14];
        v6[14] = v6[15];
        v6[15] = v396;
      }
      else
      {
        v141 = *(__int64 **)v139;
        *(_DWORD *)(v139 + 36) = v140;
        v142 = v141[1] + v140;
        v6[14] = *(_BYTE *)(v142 - 1);
        v6[15] = *(_BYTE *)(v142 - 2);
      }
      return v4;
    case 41:
      *((_BYTE *)dest + 1) = *a4;
      *((_BYTE *)dest + 2) = a4[1];
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 344LL);
      goto LABEL_131;
    case 42:
      v143 = (char *)dest + 3;
      v6[1] = *a4;
      v6[2] = a4[1];
      v144 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 352LL);
      v145 = *((_DWORD *)v144 + 9) + 1;
      if ( v145 >= *((_DWORD *)v144 + 10) )
      {
        v397 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 352LL), v143, 1);
        a1 = v397;
      }
      else
      {
        v146 = *v144;
        *((_DWORD *)v144 + 9) = v145;
        *v143 = *(_BYTE *)(*(_QWORD *)(v146 + 8) + v145 - 1LL);
      }
      v147 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 360LL);
      goto LABEL_110;
    case 43:
      v148 = (char *)dest + 3;
      v6[1] = *a4;
      v6[2] = a4[1];
      v149 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 368LL);
      v150 = *((_DWORD *)v149 + 9) + 1;
      if ( v150 >= *((_DWORD *)v149 + 10) )
      {
        v398 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 368LL), v148, 1);
        a1 = v398;
      }
      else
      {
        v151 = *v149;
        *((_DWORD *)v149 + 9) = v150;
        *v148 = *(_BYTE *)(*(_QWORD *)(v151 + 8) + v150 - 1LL);
      }
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 376LL);
      goto LABEL_210;
    case 44:
      *((_BYTE *)dest + 1) = *a4;
      *((_BYTE *)dest + 2) = a4[1];
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 384LL);
      goto LABEL_131;
    case 45:
      v152 = (char *)dest + 3;
      v6[1] = *a4;
      v6[2] = a4[1];
      v153 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 392LL);
      v154 = *((_DWORD *)v153 + 9) + 1;
      if ( v154 >= *((_DWORD *)v153 + 10) )
      {
        v399 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 392LL), v152, 1);
        a1 = v399;
      }
      else
      {
        v155 = *v153;
        *((_DWORD *)v153 + 9) = v154;
        *v152 = *(_BYTE *)(*(_QWORD *)(v155 + 8) + v154 - 1LL);
      }
      v147 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 400LL);
      goto LABEL_110;
    case 46:
      *((_BYTE *)dest + 1) = *a4;
      *((_BYTE *)dest + 2) = a4[1];
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 408LL);
      goto LABEL_131;
    case 47:
      *((_BYTE *)dest + 1) = *a4;
      *((_BYTE *)dest + 2) = a4[1];
      v156 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 416LL);
      goto LABEL_161;
    case 48:
      *((_BYTE *)dest + 1) = *a4;
      v157 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 424LL);
      goto LABEL_119;
    case 49:
      *((_BYTE *)dest + 1) = *a4;
      *((_BYTE *)dest + 2) = a4[1];
      v156 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 432LL);
      goto LABEL_161;
    case 50:
    case 67:
    case 70:
    case 71:
    case 77:
    case 80:
    case 83:
    case 85:
    case 88:
    case 96:
    case 114:
      *((_BYTE *)dest + 1) = *a4;
      *((_BYTE *)dest + 2) = a4[1];
      return v4;
    case 51:
      v158 = (char *)dest + 3;
      v6[1] = *a4;
      v6[2] = a4[1];
      v159 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 440LL);
      v160 = *((_DWORD *)v159 + 9) + 1;
      if ( v160 >= *((_DWORD *)v159 + 10) )
      {
        v400 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 440LL), v158, 1);
        a1 = v400;
      }
      else
      {
        v161 = *v159;
        *((_DWORD *)v159 + 9) = v160;
        *v158 = *(_BYTE *)(*(_QWORD *)(v161 + 8) + v160 - 1LL);
      }
      v147 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 448LL);
LABEL_110:
      v162 = *(_DWORD *)(v147 + 36) + 2;
      if ( v162 >= *(_DWORD *)(v147 + 40) )
      {
        sub_14CB0((__int64 **)v147, v6 + 4, 2);
        v333 = v6[4];
        v6[4] = v6[5];
        v6[5] = v333;
      }
      else
      {
        v163 = *(__int64 **)v147;
        *(_DWORD *)(v147 + 36) = v162;
        v164 = v163[1] + v162;
        v6[4] = *(_BYTE *)(v164 - 1);
        v6[5] = *(_BYTE *)(v164 - 2);
      }
      return v4;
    case 52:
      *((_BYTE *)dest + 1) = a4[1];
      *((_BYTE *)dest + 2) = *a4;
      v165 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 456LL);
      v166 = *(_DWORD *)(v165 + 36) + 2;
      if ( v166 >= *(_DWORD *)(v165 + 40) )
      {
        sub_14CB0((__int64 **)v165, (char *)dest + 5, 2);
        v401 = v6[5];
        v6[5] = v6[6];
        v6[6] = v401;
      }
      else
      {
        v167 = *(__int64 **)v165;
        *(_DWORD *)(v165 + 36) = v166;
        v168 = v167[1] + v166;
        *((_BYTE *)dest + 5) = *(_BYTE *)(v168 - 1);
        *((_BYTE *)dest + 6) = *(_BYTE *)(v168 - 2);
      }
      return v4;
    case 53:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 464LL);
      goto LABEL_178;
    case 54:
      *((_BYTE *)dest + 1) = *a4;
      *((_BYTE *)dest + 2) = a4[1];
      v156 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 472LL);
      goto LABEL_161;
    case 55:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 480LL);
      goto LABEL_178;
    case 56:
      v170 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 488LL);
      goto LABEL_173;
    case 57:
      *((_BYTE *)dest + 1) = *a4;
      v157 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 496LL);
LABEL_119:
      v171 = (char *)dest + 2;
      v172 = *(_DWORD *)(v157 + 36) + 1;
      if ( v172 >= *(_DWORD *)(v157 + 40) )
      {
        sub_14CB0((__int64 **)v157, v171, 1);
      }
      else
      {
        v173 = *(__int64 **)v157;
        *(_DWORD *)(v157 + 36) = v172;
        *v171 = *(_BYTE *)(v173[1] + v172 - 1);
      }
      goto LABEL_181;
    case 58:
      *((_BYTE *)dest + 1) = *a4;
      *((_BYTE *)dest + 2) = a4[1];
      v156 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 504LL);
      goto LABEL_161;
    case 59:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 512LL);
      goto LABEL_178;
    case 60:
      v174 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 520LL);
      v175 = *(_DWORD *)(v174 + 36) + 2;
      if ( v175 >= *(_DWORD *)(v174 + 40) )
      {
        v419 = v174;
        sub_14CB0((__int64 **)v174, (char *)dest + 1, 2);
        v402 = v6[1];
        v174 = v419;
        v6[1] = v6[2];
        v6[2] = v402;
      }
      else
      {
        v176 = *(__int64 **)v174;
        *(_DWORD *)(v174 + 36) = v175;
        v177 = v176[1] + v175;
        *((_BYTE *)dest + 1) = *(_BYTE *)(v177 - 1);
        *((_BYTE *)dest + 2) = *(_BYTE *)(v177 - 2);
      }
      desta.n64_u64[0] = 0LL;
      v178 = *(_DWORD *)(v174 + 36) + 4;
      if ( v178 >= *(_DWORD *)(v174 + 40) )
      {
        sub_14CB0((__int64 **)v174, &desta, 4);
        v403 = desta.n64_u8[0];
        v404 = desta.n64_u8[1];
        desta.n64_u8[0] = desta.n64_u8[3];
        desta.n64_u8[3] = v403;
        desta.n64_u8[1] = desta.n64_u8[2];
        desta.n64_u8[2] = v404;
      }
      else
      {
        v179 = *(__int64 **)v174;
        *(_DWORD *)(v174 + 36) = v178;
        v180 = v179[1] + v178;
        desta.n64_u8[0] = *(_BYTE *)(v180 - 1);
        desta.n64_u8[1] = *(_BYTE *)(v180 - 2);
        desta.n64_u8[2] = *(_BYTE *)(v180 - 3);
        desta.n64_u8[3] = *(_BYTE *)(v180 - 4);
      }
      v181 = desta.n64_u64[0];
      v182 = v6[3];
      v183 = v6[4];
      v184 = v6[5];
      v185 = v6[6];
      v6[2] |= 32 * desta.n64_u8[0];
      v186 = v6[7];
      v6[3] = v182 | ((unsigned int)v181 >> 3);
      v187 = v6[8];
      v6[4] = v183 | ((unsigned int)v181 >> 11);
      v188 = v6[9];
      v6[5] = v184 | ((unsigned int)v181 >> 19);
      v6[6] = v185 | (v181 >> 27);
      v6[7] = v186 | (v181 >> 35);
      v6[8] = v187 | (v181 >> 43);
      v6[9] = v188 | (v181 >> 51);
      goto LABEL_175;
    case 61:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 528LL);
      goto LABEL_178;
    case 62:
      *((_BYTE *)dest + 1) = *a4;
      *((_BYTE *)dest + 2) = a4[1];
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 536LL);
      goto LABEL_131;
    case 63:
      *((_BYTE *)dest + 1) = *a4;
      *((_BYTE *)dest + 2) = a4[1];
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 544LL);
LABEL_131:
      dest = (char *)dest + 3;
      v11 = *(_DWORD *)(v8 + 36) + 1;
      if ( v11 < *(_DWORD *)(v8 + 40) )
        goto LABEL_132;
      goto LABEL_211;
    case 64:
      *((_BYTE *)dest + 1) = *a4;
      v190 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 552LL);
      v191 = *(_DWORD *)(v190 + 36) + 2;
      if ( v191 >= *(_DWORD *)(v190 + 40) )
      {
        sub_14CB0((__int64 **)v190, (char *)dest + 2, 2);
        v405 = v6[2];
        v6[2] = v6[3];
        v6[3] = v405;
      }
      else
      {
        v192 = *(__int64 **)v190;
        *(_DWORD *)(v190 + 36) = v191;
        v193 = v192[1] + v191;
        *((_BYTE *)dest + 2) = *(_BYTE *)(v193 - 1);
        *((_BYTE *)dest + 3) = *(_BYTE *)(v193 - 2);
      }
      goto LABEL_143;
    case 65:
      v170 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 560LL);
      goto LABEL_173;
    case 66:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 568LL);
      goto LABEL_178;
    case 68:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 576LL);
      goto LABEL_178;
    case 69:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 584LL);
      goto LABEL_178;
    case 72:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 592LL);
      goto LABEL_178;
    case 73:
      *((_BYTE *)dest + 1) = *a4;
      *((_BYTE *)dest + 2) = a4[1];
      v156 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 600LL);
      goto LABEL_161;
    case 74:
      v194 = (char *)dest + 2;
      v6[1] = *a4;
      v195 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 608LL);
      v196 = *(_DWORD *)(v195 + 36) + 1;
      if ( v196 >= *(_DWORD *)(v195 + 40) )
      {
        sub_14CB0((__int64 **)v195, v194, 1);
      }
      else
      {
        v197 = *(__int64 **)v195;
        *(_DWORD *)(v195 + 36) = v196;
        *v194 = *(_BYTE *)(v197[1] + v196 - 1);
      }
LABEL_143:
      v6[4] = a4[1];
      return v4;
    case 75:
      v170 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 616LL);
      goto LABEL_173;
    case 76:
      v170 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 624LL);
      goto LABEL_173;
    case 78:
      v198 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 632LL);
      goto LABEL_170;
    case 79:
      *((_BYTE *)dest + 1) = *a4;
      *((_BYTE *)dest + 2) = a4[1];
      v156 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 640LL);
      goto LABEL_161;
    case 81:
      v156 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 648LL);
      goto LABEL_161;
    case 82:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 656LL);
      goto LABEL_178;
    case 84:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 664LL);
      goto LABEL_178;
    case 86:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 672LL);
      goto LABEL_178;
    case 87:
      *((_BYTE *)dest + 1) = *a4;
      *((_BYTE *)dest + 2) = a4[1];
      v156 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 680LL);
      goto LABEL_161;
    case 89:
      v170 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 688LL);
      goto LABEL_173;
    case 90:
      v156 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 696LL);
      goto LABEL_161;
    case 91:
      v198 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 704LL);
      goto LABEL_170;
    case 92:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 712LL);
      goto LABEL_178;
    case 93:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 720LL);
      goto LABEL_178;
    case 94:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 728LL);
      goto LABEL_178;
    case 95:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 736LL);
      goto LABEL_178;
    case 97:
      *((_BYTE *)dest + 1) = *a4;
      *((_BYTE *)dest + 2) = a4[1];
      v156 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 744LL);
LABEL_161:
      v199 = *(_DWORD *)(v156 + 36) + 2;
      if ( v199 >= *(_DWORD *)(v156 + 40) )
      {
        sub_14CB0((__int64 **)v156, (char *)dest + 3, 2);
        v329 = v6[3];
        v6[3] = v6[4];
        v6[4] = v329;
      }
      else
      {
        v200 = *(__int64 **)v156;
        *(_DWORD *)(v156 + 36) = v199;
        v201 = v200[1] + v199;
        *((_BYTE *)dest + 3) = *(_BYTE *)(v201 - 1);
        *((_BYTE *)dest + 4) = *(_BYTE *)(v201 - 2);
      }
      return v4;
    case 98:
      v170 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 752LL);
      goto LABEL_173;
    case 99:
      v170 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 760LL);
      goto LABEL_173;
    case 100:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 768LL);
      goto LABEL_178;
    case 101:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 776LL);
      goto LABEL_178;
    case 102:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 784LL);
      goto LABEL_178;
    case 103:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 792LL);
      goto LABEL_178;
    case 104:
      v198 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 800LL);
LABEL_170:
      v202 = *(_DWORD *)(v198 + 36) + 2;
      if ( v202 >= *(_DWORD *)(v198 + 40) )
      {
        sub_14CB0((__int64 **)v198, (char *)dest + 1, 2);
        v334 = v6[1];
        v6[1] = v6[2];
        v6[2] = v334;
      }
      else
      {
        v203 = *(__int64 **)v198;
        *(_DWORD *)(v198 + 36) = v202;
        v204 = v203[1] + v202;
        *((_BYTE *)dest + 1) = *(_BYTE *)(v204 - 1);
        *((_BYTE *)dest + 2) = *(_BYTE *)(v204 - 2);
      }
      goto LABEL_175;
    case 105:
      v170 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 808LL);
LABEL_173:
      v205 = *(_DWORD *)(v170 + 36) + 4;
      if ( v205 >= *(_DWORD *)(v170 + 40) )
      {
        sub_14CB0((__int64 **)v170, (char *)dest + 1, 4);
        v330 = v6[1];
        v331 = v6[3];
        v332 = v6[2];
        v6[1] = v6[4];
        v6[4] = v330;
        v6[2] = v331;
        v6[3] = v332;
      }
      else
      {
        v206 = *(__int64 **)v170;
        *(_DWORD *)(v170 + 36) = v205;
        v207 = v206[1] + v205;
        *((_BYTE *)dest + 1) = *(_BYTE *)(v207 - 1);
        *((_BYTE *)dest + 2) = *(_BYTE *)(v207 - 2);
        *((_BYTE *)dest + 3) = *(_BYTE *)(v207 - 3);
        *((_BYTE *)dest + 4) = *(_BYTE *)(v207 - 4);
      }
      goto LABEL_175;
    case 106:
      v169 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 816LL);
LABEL_178:
      v208 = (char *)dest + 1;
      v209 = *(_DWORD *)(v169 + 36) + 1;
      if ( v209 >= *(_DWORD *)(v169 + 40) )
      {
        sub_14CB0((__int64 **)v169, v208, 1);
      }
      else
      {
        v210 = *(__int64 **)v169;
        *(_DWORD *)(v169 + 36) = v209;
        *v208 = *(_BYTE *)(v210[1] + v209 - 1);
      }
      v6[2] = *a4;
LABEL_181:
      v7 = a4[1];
      goto LABEL_182;
    case 107:
      v212 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 824LL);
      v213 = *(_DWORD *)(v212 + 36) + 2;
      if ( v213 >= *(_DWORD *)(v212 + 40) )
      {
        sub_14CB0((__int64 **)v212, (char *)dest + 1, 2);
        v406 = v6[1];
        v6[1] = v6[2];
        v6[2] = v406;
      }
      else
      {
        v214 = *(__int64 **)v212;
        *(_DWORD *)(v212 + 36) = v213;
        v215 = v214[1] + v213;
        *((_BYTE *)dest + 1) = *(_BYTE *)(v215 - 1);
        *((_BYTE *)dest + 2) = *(_BYTE *)(v215 - 2);
      }
      v6[5] = *a4;
      desta.n64_u64[0] = 0LL;
      *(int8x8_t *)(v6 + 6) = vorr_s8(*(int8x8_t *)(v6 + 6), (int8x8_t)a4[1]);
      return v4;
    case 108:
      v216 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 832LL);
      v217 = *(_DWORD *)(v216 + 36) + 4;
      if ( v217 >= *(_DWORD *)(v216 + 40) )
      {
        sub_14CB0((__int64 **)v216, (char *)dest + 1, 4);
        v407 = v6[1];
        v408 = v6[3];
        v409 = v6[2];
        v6[1] = v6[4];
        v6[4] = v407;
        v6[2] = v408;
        v6[3] = v409;
      }
      else
      {
        v218 = *(__int64 **)v216;
        *(_DWORD *)(v216 + 36) = v217;
        v219 = v218[1] + v217;
        *((_BYTE *)dest + 1) = *(_BYTE *)(v219 - 1);
        *((_BYTE *)dest + 2) = *(_BYTE *)(v219 - 2);
        *((_BYTE *)dest + 3) = *(_BYTE *)(v219 - 3);
        *((_BYTE *)dest + 4) = *(_BYTE *)(v219 - 4);
      }
      desta.n64_u64[0] = 0LL;
      desta.n64_u64[0] = *a4;
      v220 = desta.n64_u64[0];
      v221 = v6[6];
      v222 = v6[7];
      v223 = v6[8];
      v224 = v6[9];
      v6[5] |= 2 * desta.n64_u8[0];
      v225 = v6[10];
      v6[6] = v221 | ((unsigned int)v220 >> 7);
      v226 = v6[11];
      v6[7] = v222 | ((unsigned int)v220 >> 15);
      v227 = v6[12];
      v6[8] = v223 | ((unsigned int)v220 >> 23);
      v6[9] = v224 | (v220 >> 31);
      v6[10] = v225 | (v220 >> 39);
      v6[11] = v226 | (v220 >> 47);
      v6[12] = v227 | (v220 >> 55);
      goto LABEL_176;
    case 109:
      v228 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 840LL);
      desta.n64_u64[0] = 0LL;
      v229 = *(_DWORD *)(v228 + 36) + 2;
      if ( v229 >= *(_DWORD *)(v228 + 40) )
      {
        sub_14CB0((__int64 **)v228, &desta, 2);
        v410 = desta.n64_u8[0];
        desta.n64_u8[0] = desta.n64_u8[1];
        desta.n64_u8[1] = v410;
      }
      else
      {
        v230 = *(__int64 **)v228;
        *(_DWORD *)(v228 + 36) = v229;
        v231 = v230[1] + v229;
        desta.n64_u8[0] = *(_BYTE *)(v231 - 1);
        desta.n64_u8[1] = *(_BYTE *)(v231 - 2);
      }
      *(int8x8_t *)(v6 + 1) = vorr_s8(*(int8x8_t *)(v6 + 1), desta);
LABEL_175:
      v6[5] = *a4;
LABEL_176:
      v6[6] = a4[1];
      return v4;
    case 110:
      v232 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 848LL);
      desta.n64_u64[0] = 0LL;
      v233 = *(_DWORD *)(v232 + 36) + 1;
      if ( v233 >= *(_DWORD *)(v232 + 40) )
      {
        v420 = v232;
        sub_14CB0((__int64 **)v232, &desta, 1);
        v232 = v420;
      }
      else
      {
        v234 = *(__int64 **)v232;
        *(_DWORD *)(v232 + 36) = v233;
        desta.n64_u8[0] = *(_BYTE *)(v234[1] + v233 - 1);
      }
      v235 = desta.n64_u64[0];
      v236 = v6[7];
      v237 = v6[8];
      v238 = v6[9];
      v239 = v6[10];
      v6[6] |= 4 * desta.n64_u8[0];
      v240 = v6[11];
      v6[7] = v236 | ((unsigned int)v235 >> 6);
      v241 = v6[12];
      v6[8] = v237 | ((unsigned int)v235 >> 14);
      v242 = v6[13];
      v6[9] = v238 | ((unsigned int)v235 >> 22);
      v6[10] = v239 | (v235 >> 30);
      v6[11] = v240 | (v235 >> 38);
      v6[12] = v241 | (v235 >> 46);
      v6[13] = v242 | (v235 >> 54);
      desta.n64_u64[0] = 0LL;
      v243 = *(_DWORD *)(v232 + 36) + 1;
      if ( v243 >= *(_DWORD *)(v232 + 40) )
      {
        sub_14CB0((__int64 **)v232, &desta, 1);
      }
      else
      {
        v244 = *(__int64 **)v232;
        *(_DWORD *)(v232 + 36) = v243;
        desta.n64_u8[0] = *(_BYTE *)(v244[1] + v243 - 1);
      }
      v245 = desta.n64_u64[0];
      v246 = v6[2];
      v247 = v6[3];
      v248 = v6[4];
      v249 = v6[5];
      v6[1] |= 8 * desta.n64_u8[0];
      v250 = v6[6];
      v6[2] = v246 | ((unsigned int)v245 >> 5);
      v251 = v6[7];
      v6[3] = v247 | ((unsigned int)v245 >> 13);
      v252 = v6[8];
      v6[4] = v248 | ((unsigned int)v245 >> 21);
      v6[5] = v249 | (v245 >> 29);
      v6[6] = v250 | (v245 >> 37);
      v6[7] = v251 | (v245 >> 45);
      v6[8] = v252 | (v245 >> 53);
LABEL_198:
      v6[5] = *a4;
      return v4;
    case 112:
      v253 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 856LL);
      desta.n64_u64[0] = 0LL;
      v254 = *(_DWORD *)(v253 + 36) + 2;
      if ( v254 >= *(_DWORD *)(v253 + 40) )
      {
        sub_14CB0((__int64 **)v253, &desta, 2);
        v411 = desta.n64_u8[0];
        desta.n64_u8[0] = desta.n64_u8[1];
        desta.n64_u8[1] = v411;
      }
      else
      {
        v255 = *(__int64 **)v253;
        *(_DWORD *)(v253 + 36) = v254;
        v256 = v255[1] + v254;
        desta.n64_u8[0] = *(_BYTE *)(v256 - 1);
        desta.n64_u8[1] = *(_BYTE *)(v256 - 2);
      }
      v257 = desta.n64_u64[0];
      v258 = v6[3];
      v259 = v6[4];
      v260 = v6[5];
      v261 = v6[2] | desta.n64_u8[1];
      v262 = v6[6];
      v6[1] |= desta.n64_u8[0];
      v263 = v6[7];
      v6[2] = v261;
      v264 = v6[8];
      v6[3] = v258 | BYTE2(v257);
      v6[4] = v259 | BYTE3(v257);
      v265 = v262 | BYTE5(v257);
      v266 = v263 | BYTE6(v257);
      LOBYTE(v257) = v264 | HIBYTE(v257);
      v6[5] = v260 | BYTE4(v257);
      v6[6] = v262 | BYTE5(v257);
      v6[7] = v266;
      v6[8] = v264 | HIBYTE(v257);
      v6[5] = *a4;
      desta.n64_u64[0] = 0LL;
      desta.n64_u64[0] = a4[1];
      v267 = desta.n64_u64[0];
      v268 = v6[9];
      v269 = v6[10];
      v270 = v6[11];
      v271 = v6[12];
      v6[6] = v265 | desta.n64_u8[0];
      v272 = v6[13];
      v6[7] = v266 | BYTE1(v267);
      v6[8] = v257 | BYTE2(v267);
      v6[9] = v268 | BYTE3(v267);
      v6[10] = v269 | BYTE4(v267);
      v6[11] = v270 | BYTE5(v267);
      v6[12] = v271 | BYTE6(v267);
      v6[13] = v272 | HIBYTE(v267);
      return v4;
    case 113:
      v273 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 864LL);
      desta.n64_u64[0] = 0LL;
      v274 = *(_DWORD *)(v273 + 36) + 1;
      if ( v274 >= *(_DWORD *)(v273 + 40) )
      {
        v421 = v273;
        sub_14CB0((__int64 **)v273, &desta, 1);
        v273 = v421;
      }
      else
      {
        v275 = *(__int64 **)v273;
        *(_DWORD *)(v273 + 36) = v274;
        desta.n64_u8[0] = *(_BYTE *)(v275[1] + v274 - 1);
      }
      v276 = desta.n64_u64[0];
      v277 = v6[6];
      v278 = v6[7];
      v279 = v6[8];
      v280 = v6[9];
      v6[5] |= 16 * desta.n64_u8[0];
      v281 = v6[10];
      v6[6] = v277 | ((unsigned int)v276 >> 4);
      v282 = v6[11];
      v6[7] = v278 | ((unsigned int)v276 >> 12);
      v283 = v6[12];
      v6[8] = v279 | ((unsigned int)v276 >> 20);
      v6[9] = v280 | (v276 >> 28);
      v6[10] = v281 | (v276 >> 36);
      v6[11] = v282 | (v276 >> 44);
      v6[12] = v283 | (v276 >> 52);
      desta.n64_u64[0] = 0LL;
      v284 = *(_DWORD *)(v273 + 36) + 1;
      if ( v284 >= *(_DWORD *)(v273 + 40) )
      {
        sub_14CB0((__int64 **)v273, &desta, 1);
      }
      else
      {
        v285 = *(__int64 **)v273;
        *(_DWORD *)(v273 + 36) = v284;
        desta.n64_u8[0] = *(_BYTE *)(v285[1] + v284 - 1);
      }
      v286 = v6[5];
      v287 = v6[6];
      v288 = v6[7];
      v289 = v6[8];
      v290 = HIDWORD(desta.n64_u64[0]);
      v291 = desta.n64_u64[0] >> 40;
      v292 = HIWORD(desta.n64_u64[0]);
      v293 = v6[2] | desta.n64_u8[1];
      v294 = v6[3] | desta.n64_u8[2];
      v295 = v6[4] | desta.n64_u8[3];
      v296 = HIBYTE(desta.n64_u64[0]);
      v6[1] |= desta.n64_u8[0];
      v6[2] = v293;
      v6[3] = v294;
      v297 = v286 | v290;
      v298 = v287 | v291;
      v299 = v288 | v292;
      LOBYTE(v296) = v289 | v296;
      v6[4] = v295;
      v6[5] = v286 | v290;
      v6[6] = v287 | v291;
      v6[7] = v288 | v292;
      v6[8] = v296;
      desta.n64_u64[0] = 0LL;
      desta.n64_u64[0] = *a4;
      v300 = desta.n64_u64[0];
      v301 = v6[9];
      v302 = v6[10];
      v303 = v6[11];
      v304 = v6[12];
      v305 = desta.n64_u64[0] >> 7;
      v6[5] = v297 | (2 * desta.n64_u8[0]);
      v306 = v298 | v305;
      v307 = v300 >> 47;
      v308 = v301 | (v300 >> 31);
      v309 = v302 | (v300 >> 39);
      v310 = v303 | (v300 >> 47);
      LOBYTE(v300) = v304 | (v300 >> 55);
      v6[6] = v306;
      v6[7] = v299;
      v6[8] = v296;
      v6[9] = v308;
      v6[10] = v309;
      v6[11] = v303 | v307;
      v6[12] = v300;
      desta.n64_u64[0] = 0LL;
      desta.n64_u64[0] = a4[1];
      v311 = v6[13];
      v312 = v299 | (desta.n64_u32[0] >> 7);
      v6[6] = v306 | (2 * desta.n64_u8[0]);
      v6[7] = v312;
      v6[8] = v296;
      v6[9] = v308;
      v6[10] = v309;
      v6[11] = v310;
      v6[12] = v300;
      v6[13] = v311;
      return v4;
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 150:
    case 151:
      *((_BYTE *)dest + 1) = *a4;
      *((_BYTE *)dest + 2) = a4[1];
      v7 = a4[2];
      goto LABEL_182;
    case 152:
      *((_BYTE *)dest + 1) = *a4;
      *((_BYTE *)dest + 2) = a4[1];
      *((_BYTE *)dest + 3) = a4[2];
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 872LL);
      goto LABEL_210;
    case 153:
      *((_BYTE *)dest + 1) = *a4;
      *((_BYTE *)dest + 2) = a4[1];
      *((_BYTE *)dest + 3) = a4[2];
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 880LL);
      goto LABEL_210;
    case 154:
      *((_BYTE *)dest + 1) = *a4;
      *((_BYTE *)dest + 2) = a4[1];
      *((_BYTE *)dest + 3) = a4[2];
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 888LL);
LABEL_210:
      dest = v6 + 4;
      v11 = *(_DWORD *)(v8 + 36) + 1;
      if ( v11 >= *(_DWORD *)(v8 + 40) )
        goto LABEL_211;
      goto LABEL_132;
    case 155:
      v313 = (char *)dest + 4;
      v6[1] = *a4;
      v6[2] = a4[1];
      v6[3] = a4[2];
      v314 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 896LL);
      v315 = *((_DWORD *)v314 + 9) + 1;
      if ( v315 >= *((_DWORD *)v314 + 10) )
      {
        v412 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 896LL), v313, 1);
        a1 = v412;
      }
      else
      {
        v316 = *v314;
        *((_DWORD *)v314 + 9) = v315;
        *v313 = *(_BYTE *)(*(_QWORD *)(v316 + 8) + v315 - 1LL);
      }
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 904LL);
      goto LABEL_218;
    case 156:
      v317 = (char *)dest + 4;
      v6[1] = *a4;
      v6[2] = a4[1];
      v6[3] = a4[2];
      v318 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 912LL);
      v319 = *((_DWORD *)v318 + 9) + 1;
      if ( v319 >= *((_DWORD *)v318 + 10) )
      {
        v413 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 912LL), v317, 1);
        a1 = v413;
      }
      else
      {
        v320 = *v318;
        *((_DWORD *)v318 + 9) = v319;
        *v317 = *(_BYTE *)(*(_QWORD *)(v320 + 8) + v319 - 1LL);
      }
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 920LL);
LABEL_218:
      dest = v6 + 5;
      v11 = *(_DWORD *)(v8 + 36) + 1;
      if ( v11 >= *(_DWORD *)(v8 + 40) )
        goto LABEL_211;
      goto LABEL_132;
    case 157:
      v321 = (char *)dest + 4;
      v6[1] = *a4;
      v6[2] = a4[1];
      v6[3] = a4[2];
      v322 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 928LL);
      v323 = *((_DWORD *)v322 + 9) + 1;
      if ( v323 >= *((_DWORD *)v322 + 10) )
      {
        v414 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 928LL), v321, 1);
        a1 = v414;
      }
      else
      {
        v324 = *v322;
        *((_DWORD *)v322 + 9) = v323;
        *v321 = *(_BYTE *)(*(_QWORD *)(v324 + 8) + v323 - 1LL);
      }
      v325 = v6 + 5;
      v326 = *(__int64 **)(*(_QWORD *)(a1 + 16) + 936LL);
      v327 = *((_DWORD *)v326 + 9) + 1;
      if ( v327 >= *((_DWORD *)v326 + 10) )
      {
        v415 = a1;
        sub_14CB0(*(__int64 ***)(*(_QWORD *)(a1 + 16) + 936LL), v325, 1);
        a1 = v415;
      }
      else
      {
        v328 = *v326;
        *((_DWORD *)v326 + 9) = v327;
        *v325 = *(_BYTE *)(*(_QWORD *)(v328 + 8) + v327 - 1LL);
      }
      dest = v6 + 6;
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 944LL);
      v11 = *(_DWORD *)(v8 + 36) + 1;
      if ( v11 < *(_DWORD *)(v8 + 40) )
      {
LABEL_132:
        v189 = *(__int64 **)v8;
        *(_DWORD *)(v8 + 36) = v11;
        *(_BYTE *)dest = *(_BYTE *)(v189[1] + v11 - 1);
      }
      else
      {
LABEL_211:
        sub_14CB0((__int64 **)v8, dest, 1);
      }
      break;
    default:
      return v4;
  }
  return v4;
}

//----- (0000000000010934) ----------------------------------------------------
__int64 __fastcall sub_10934(int a1, __int64 a2, void *dest, int a4)
{
  __int64 v6; // x21
  __int64 v7; // x8
  int v8; // w9
  unsigned int v9; // w8
  unsigned int v10; // w22
  size_t v11; // w21
  __int64 v12; // x8
  __int64 v13; // x24
  int v14; // w23
  __int64 v15; // x8
  __int64 v16; // x8
  unsigned int desta; // [xsp+8h] [xbp-48h] BYREF
  char v19[4]; // [xsp+Ch] [xbp-44h] BYREF
  __int64 v20; // [xsp+18h] [xbp-38h] BYREF

  v6 = **(_QWORD **)(a2 + 16);
  if ( a4 )
  {
    v7 = *(unsigned int *)(v6 + 36);
    v8 = v7 + 4;
    if ( (unsigned int)(v7 + 4) >= *(_DWORD *)(v6 + 40) )
    {
      sub_14CB0((__int64 **)v6, &desta, 4);
      v10 = HIBYTE(desta);
    }
    else
    {
      v9 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v6 + 8LL) + v7);
      v10 = HIBYTE(v9);
      desta = v9;
      *(_DWORD *)(v6 + 36) = v8;
    }
    v11 = dword_1C658[v10];
    memcpy(dest, (char *)&unk_1BB27 + 18 * v10, v11);
    sub_E730(a2, dest, v10 - 1, (unsigned __int8 *)&desta);
    return v11;
  }
  v20 = 0LL;
  v12 = *(unsigned int *)(v6 + 36);
  if ( (unsigned int)(v12 + 1) >= *(_DWORD *)(v6 + 40) )
  {
    sub_14CB0((__int64 **)v6, &v20, 1);
    v13 = v20;
    if ( v20 != 255 )
      goto LABEL_7;
  }
  else
  {
    LOBYTE(v20) = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v6 + 8LL) + v12);
    *(_DWORD *)(v6 + 36) = v12 + 1;
    v13 = v20;
    if ( v20 != 255 )
    {
LABEL_7:
      v14 = byte_1BA88[v13];
      if ( byte_1BA88[v13] && (v15 = *(unsigned int *)(v6 + 36), (unsigned int)(v15 + v14) < *(_DWORD *)(v6 + 40)) )
      {
        memcpy(&desta, (const void *)(*(_QWORD *)(*(_QWORD *)v6 + 8LL) + v15), byte_1BA88[v13]);
        *(_DWORD *)(v6 + 36) += v14;
      }
      else
      {
        sub_14CB0((__int64 **)v6, &desta, v14);
        v13 = v20;
      }
      memcpy(dest, (char *)&unk_1BB27 + 18 * v13, dword_1C658[v13]);
      if ( (_DWORD)v13 != 255 )
        return (unsigned int)sub_E730(a2, dest, (int)v13 - 1, (unsigned __int8 *)&desta);
      goto LABEL_11;
    }
  }
LABEL_11:
  v16 = *(unsigned int *)(v6 + 36);
  if ( (unsigned int)(v16 + 1) >= *(_DWORD *)(v6 + 40) )
  {
    sub_14CB0((__int64 **)v6, v19, 1);
  }
  else
  {
    v19[0] = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)v6 + 8LL) + v16);
    *(_DWORD *)(v6 + 36) = v16 + 1;
  }
  sub_CEE8();
  return 0;
}

//----- (0000000000010C38) ----------------------------------------------------
__int64 __fastcall sub_10C38(unsigned __int16 a1, __int64 a2, _DWORD *a3)
{
  __int64 v3; // x8
  __int64 v4; // x9
  __int64 result; // x0

  v3 = (unsigned int)*a3;
  if ( (_DWORD)v3 )
  {
    v4 = 0LL;
    while ( *(unsigned __int16 *)(a2 + 2 * v4) != a1 )
    {
      if ( v3 == ++v4 )
        goto LABEL_8;
    }
  }
  else
  {
    LODWORD(v4) = 0;
  }
  if ( (_DWORD)v4 != (_DWORD)v3 )
    return 0LL;
LABEL_8:
  *(_WORD *)(a2 + 2 * v3) = a1;
  result = 1LL;
  ++*a3;
  return result;
}

//----- (0000000000010C8C) ----------------------------------------------------
__int64 __fastcall sub_10C8C(__int64 a1)
{
  (**(void (***)(void))(a1 + 16))();
  (*(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 8LL))(a1);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 16LL))(a1);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 24LL))(a1);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 32LL))(a1);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 40LL))(a1);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 48LL))(a1);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 56LL))(a1);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 64LL))(a1);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 72LL))(a1);
  (*(void (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 80LL))(a1);
  return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(a1 + 16) + 88LL))(a1);
}

//----- (0000000000010D54) ----------------------------------------------------
__int64 sub_10D54()
{
  __int64 v0; // x19

  v0 = sub_1810C(34912LL);
  sub_11920(v0, "anon_driver", "anon", 0LL, 2LL, (__int64)&unk_1C8D8);
  sub_118DC(v0);
  return v0;
}

//----- (0000000000010D9C) ----------------------------------------------------
void *__fastcall sub_10D9C(__int64 a1)
{
  __int64 v1; // x21
  void *v3; // x19
  size_t v4; // w0
  __int64 v5; // x8
  size_t v6; // w20
  __int64 v7; // x21
  __int64 v8; // x8
  void *result; // x0

  v1 = *(_QWORD *)(a1 + 8);
  v3 = (void *)sub_183A8(v1);
  v4 = sub_183A0(v1);
  v5 = *(_QWORD *)(a1 + 32);
  v6 = v4;
  v7 = *(_QWORD *)(*(_QWORD *)(v5 + 16) + 16400LL);
  if ( !v4 )
    return (void *)sub_14CB0((__int64 **)v7, v3, v4);
  v8 = *(unsigned int *)(v7 + 36);
  if ( (unsigned int)v8 + v4 >= *(_DWORD *)(v7 + 40) )
    return (void *)sub_14CB0((__int64 **)v7, v3, v4);
  result = memcpy(v3, (const void *)(*(_QWORD *)(*(_QWORD *)v7 + 8LL) + v8), v4);
  *(_DWORD *)(v7 + 36) += v6;
  return result;
}

//----- (0000000000010E2C) ----------------------------------------------------
_QWORD *sub_10E2C()
{
  unsigned __int64 v0; // x0
  _QWORD *v1; // x19
  _QWORD *result; // x0
  unsigned __int64 v3; // x0
  unsigned __int64 v4; // x20

  v0 = sub_1810C(64LL);
  if ( v0 )
  {
    v1 = (_QWORD *)v0;
    *(_OWORD *)(v0 + 32) = 0u;
    *(_OWORD *)(v0 + 48) = 0u;
    *(_OWORD *)v0 = 0u;
    *(_OWORD *)(v0 + 16) = 0u;
    *(_DWORD *)(v0 + 24) = 30;
    if ( v0 > 0x13 )
      goto LABEL_7;
  }
  else
  {
    v1 = (_QWORD *)&byte_5;
  }
  if ( (_DWORD)v1 )
    return v1;
LABEL_7:
  v3 = sub_14A5C(0x903uLL);
  v4 = v3;
  if ( v3 <= 0x13 && (_DWORD)v3 )
  {
    j__free(v1);
    result = (_QWORD *)v4;
  }
  else
  {
    v1[2] = v3;
    result = v1;
  }
  return result;
}
// 5: using guessed type char byte_5;

//----- (0000000000010ECC) ----------------------------------------------------
__int64 __fastcall sub_10ECC(FILE *a1, __int64 a2)
{
  __int64 v3; // x0
  FILE *v4; // x19
  FILE *v5; // x22
  unsigned int v6; // w0
  __int64 v7; // x21
  unsigned __int64 v9; // x0
  __int64 *v10; // x20
  unsigned int v11; // w25
  __int64 *v12; // x8
  __int64 v13; // x0
  unsigned int v14; // w26
  const char *v15; // x24
  __int64 v16; // x23
  char *v17; // x24
  unsigned __int64 v18; // x0
  unsigned __int64 v19; // x0
  __int64 v20; // x22
  __int64 *i; // x0
  __int64 v22; // x8
  void (__fastcall ***v23)(_QWORD); // x0
  void *v24; // x0
  __int64 v25; // [xsp+0h] [xbp-60h] BYREF
  unsigned int v26; // [xsp+8h] [xbp-58h]
  unsigned int v27; // [xsp+Ch] [xbp-54h]
  _DWORD *v28; // [xsp+18h] [xbp-48h] BYREF

  v3 = sub_11BE4((const char *)a2, (__int64)a1, &v28);
  if ( v3 )
  {
    v4 = (FILE *)v3;
    if ( *v28 )
      v5 = a1;
    else
      v5 = (FILE *)v3;
    if ( fread(&v25, 0x10u, 1u, v5) != 1LL )
    {
      v7 = 6LL;
      goto LABEL_10;
    }
    v6 = sub_11898(&v25);
    if ( v6 )
    {
      v7 = v6;
LABEL_10:
      fclose(v4);
      return v7;
    }
    v7 = 8LL;
    if ( (unsigned __int16)v26 > 0x1Eu || HIWORD(v26) )
      goto LABEL_10;
    v9 = sub_1810C(64LL);
    if ( v9 )
    {
      v10 = (__int64 *)v9;
      *(_OWORD *)(v9 + 32) = 0u;
      *(_OWORD *)(v9 + 48) = 0u;
      *(_OWORD *)v9 = 0u;
      *(_OWORD *)(v9 + 16) = 0u;
      *(_DWORD *)(v9 + 24) = 30;
      if ( v9 > 0x13 )
        goto LABEL_19;
    }
    else
    {
      v10 = (_QWORD *)&byte_5;
    }
    v7 = (__int64)v10;
    if ( (_DWORD)v10 )
      goto LABEL_10;
LABEL_19:
    if ( fread(v10 + 7, 8u, 1u, v5) == 1LL )
    {
      if ( v27 )
      {
        v11 = 0;
        v7 = 5LL;
        do
        {
          v13 = sub_1810C(160LL);
          if ( !v13 )
            goto LABEL_48;
          *(_QWORD *)v13 = 0LL;
          v14 = v26;
          *(_OWORD *)(v13 + 8) = 0u;
          v15 = (const char *)(v13 + 8);
          v16 = v13;
          *(_DWORD *)(v13 + 152) = 0;
          *(_OWORD *)(v13 + 120) = 0u;
          *(_OWORD *)(v13 + 136) = 0u;
          *(_OWORD *)(v13 + 88) = 0u;
          *(_OWORD *)(v13 + 104) = 0u;
          *(_OWORD *)(v13 + 56) = 0u;
          *(_OWORD *)(v13 + 72) = 0u;
          *(_OWORD *)(v13 + 24) = 0u;
          *(_OWORD *)(v13 + 40) = 0u;
          if ( fread((void *)(v13 + 8), 0x80u, 1u, v5) != 1LL )
            goto LABEL_38;
          if ( v14 )
          {
            if ( fread((void *)(v16 + 136), 8u, 1u, v5) != 1LL )
              goto LABEL_38;
          }
          else
          {
            v17 = sub_18710(v15);
            if ( strnlen(v17, 9u) > 7uLL )
            {
              v7 = 3LL;
              goto LABEL_39;
            }
            strcpy((char *)(v16 + 136), v17);
          }
          if ( fread((void *)(v16 + 144), 4u, 1u, v5) != 1LL || fread((void *)(v16 + 148), 8u, 1u, v5) != 1LL )
          {
LABEL_38:
            v7 = 6LL;
LABEL_39:
            j__free((void *)v16);
            goto LABEL_48;
          }
          if ( *v10 )
            v12 = (__int64 *)v10[1];
          else
            v12 = v10;
          *v12 = v16;
          v10[1] = v16;
          ++v11;
        }
        while ( v11 < v27 );
      }
      if ( *v28 )
        v18 = sub_14DB4(v4);
      else
        v18 = sub_14DE4(v4);
      v7 = v18;
      if ( v18 > 0x13 || !(_DWORD)v18 )
      {
        v19 = sub_11CBC(v18, v26);
        v20 = v19;
        if ( v19 > 0x13 || !(_DWORD)v19 )
        {
          v10[2] = v19;
          v7 = (__int64)v10;
          *((_DWORD *)v10 + 6) = v26;
          goto LABEL_10;
        }
        if ( v7 )
          (**(void (__fastcall ***)(__int64))v7)(v7);
        v7 = v20;
      }
    }
    else
    {
      v7 = 6LL;
    }
LABEL_48:
    for ( i = (__int64 *)*v10; *v10; i = (__int64 *)*v10 )
    {
      v22 = *i;
      *i = 0x100000LL;
      *v10 = v22;
      j__free(i);
    }
    v23 = (void (__fastcall ***)(_QWORD))v10[2];
    if ( v23 )
      (**v23)(v23);
    v24 = (void *)v10[6];
    if ( v24 )
      j__free(v24);
    j__free(v10);
    goto LABEL_10;
  }
  return 6LL;
}
// 5: using guessed type char byte_5;

//----- (00000000000111F0) ----------------------------------------------------
void __fastcall sub_111F0(void *ptr)
{
  __int64 *v2; // x0
  __int64 v3; // x8
  void (__fastcall ***v4)(_QWORD); // x0
  void *v5; // x0

  v2 = *(__int64 **)ptr;
  if ( v2 )
  {
    do
    {
      v3 = *v2;
      *v2 = 0x100000LL;
      *(_QWORD *)ptr = v3;
      j__free(v2);
      v2 = *(__int64 **)ptr;
    }
    while ( *(_QWORD *)ptr );
  }
  v4 = (void (__fastcall ***)(_QWORD))*((_QWORD *)ptr + 2);
  if ( v4 )
    (**v4)(v4);
  v5 = (void *)*((_QWORD *)ptr + 6);
  if ( v5 )
    j__free(v5);
  j__free(ptr);
}

//----- (0000000000011250) ----------------------------------------------------
__int64 __fastcall sub_11250(__int64 a1, int a2, const void *a3, __int64 a4)
{
  size_t v6; // w20
  void *v7; // x0
  void *v8; // x22
  void *v9; // x0
  __int64 result; // x0

  if ( !a1 )
    return 1LL;
  *(_DWORD *)(a1 + 32) = a2;
  if ( !a3 )
    return 0LL;
  v6 = a4;
  if ( !a4 )
    return 1LL;
  v7 = (void *)sub_1810C(a4);
  if ( !v7 )
    return 5LL;
  v8 = v7;
  memcpy(v7, a3, v6);
  v9 = *(void **)(a1 + 48);
  if ( v9 )
    j__free(v9);
  result = 0LL;
  *(_QWORD *)(a1 + 48) = v8;
  return result;
}

//----- (00000000000112F4) ----------------------------------------------------
__int64 __fastcall sub_112F4(__int64 a1, int a2, int a3)
{
  __int64 result; // x0

  if ( !a1 )
    return 1LL;
  if ( a2 != 1 )
  {
    if ( !a2 )
    {
      result = 0LL;
      *(_DWORD *)(a1 + 56) = a3;
      return result;
    }
    return 1LL;
  }
  result = 0LL;
  *(_DWORD *)(a1 + 60) = a3;
  return result;
}

//----- (0000000000011328) ----------------------------------------------------
_QWORD *__fastcall sub_11328(__int64 a1)
{
  char *v1; // x19
  _QWORD *v3; // x0
  _QWORD *v4; // x21
  __int64 v5; // x8

  v1 = *(char **)a1;
  if ( !*(_QWORD *)a1 )
    return 0LL;
  v3 = sub_18234(v1 + 8, *((unsigned int *)v1 + 36));
  v4 = v3;
  if ( (unsigned __int64)v3 > 0x13 || !(_DWORD)v3 )
    sub_11988(*(_QWORD *)(a1 + 16), (__int64)v3, v1 + 136, *(_DWORD *)(a1 + 24), a1 + 56);
  v5 = *(_QWORD *)v1;
  *(_QWORD *)v1 = 0x100000LL;
  *(_QWORD *)a1 = v5;
  if ( !v5 )
    *(_QWORD *)(a1 + 8) = 0LL;
  j__free(v1);
  return v4;
}

//----- (00000000000113B4) ----------------------------------------------------
void **__fastcall sub_113B4(__int64 a1, __int64 *a2, int a3)
{
  void **v3; // x21
  __int64 *v4; // x22
  _QWORD *v7; // x20
  __int64 v8; // x21
  char *i; // x23
  void **v10; // x0
  __int64 v11; // x8
  __int64 v12; // x0
  __int64 v13; // x8
  __int128 v15[2]; // [xsp+0h] [xbp-70h] BYREF
  char v16[4]; // [xsp+2Ch] [xbp-44h] BYREF

  v3 = (void **)(&dword_0 + 1);
  if ( a1 )
  {
    v4 = a2;
    if ( a2 )
    {
      v15[0] = *(_OWORD *)off_19C88;
      v15[1] = unk_19C98;
      v7 = sub_183F0((__int64)v15);
      if ( a3 >= 1 )
      {
        v8 = (unsigned int)a3;
        do
        {
          if ( *v4 )
            sub_18560((__int64)v7, *v4, v16);
          --v8;
          ++v4;
        }
        while ( v8 );
      }
      for ( i = *(char **)a1; *(_QWORD *)a1; i = *(char **)a1 )
      {
        v10 = (void **)sub_18234(i + 8, *((unsigned int *)i + 36));
        v3 = v10;
        if ( (unsigned __int64)v10 <= 0x13 && (_DWORD)v10 )
        {
          v11 = *(_QWORD *)i;
          *(_QWORD *)i = 0x100000LL;
          *(_QWORD *)a1 = v11;
          if ( !v11 )
            goto LABEL_18;
        }
        else
        {
          sub_11988(*(_QWORD *)(a1 + 16), (__int64)v10, i + 136, *(_DWORD *)(a1 + 24), a1 + 56);
          v13 = *(_QWORD *)i;
          *(_QWORD *)i = 0x100000LL;
          *(_QWORD *)a1 = v13;
          if ( !v13 )
          {
LABEL_18:
            *(_QWORD *)(a1 + 8) = 0LL;
            goto LABEL_12;
          }
        }
LABEL_12:
        j__free(i);
        if ( !v3 )
          goto LABEL_20;
        if ( (unsigned __int64)v3 <= 0x13 && (_DWORD)v3 != 0 )
          goto LABEL_20;
        v12 = sub_18398((__int64)v3);
        if ( sub_184E4(v7, v12) )
          goto LABEL_20;
        sub_1820C(v3);
      }
      v3 = 0LL;
LABEL_20:
      sub_18438(v7);
    }
  }
  return v3;
}
// 0: using guessed type int dword_0;
// 19C88: using guessed type __int64 (__fastcall *off_19C88[2])();

//----- (000000000001151C) ----------------------------------------------------
__int64 __fastcall sub_1151C(__int64 a1, char *a2)
{
  const char *v4; // x0
  _OWORD *v5; // x0
  _OWORD *v6; // x19
  char *v7; // x22
  const char *v8; // x0
  const char *v9; // x0
  __int64 v10; // x21
  __int64 v11; // x0

  v4 = (const char *)sub_18398(a1);
  if ( (unsigned __int64)strnlen(v4, 0x81u) - 1 <= 0x7E )
  {
    v5 = (_OWORD *)sub_1810C(160LL);
    if ( !v5 )
      return 5LL;
    v6 = v5;
    v5[8] = 0u;
    v5[9] = 0u;
    v5[6] = 0u;
    v5[7] = 0u;
    v5[4] = 0u;
    v5[5] = 0u;
    v5[2] = 0u;
    v5[3] = 0u;
    *v5 = 0u;
    v5[1] = 0u;
    v7 = (char *)v5 + 8;
    v8 = (const char *)sub_18398(a1);
    strcpy(v7, v8);
    if ( a2 || (v9 = (const char *)sub_18398(a1), (a2 = sub_18710(v9)) != 0LL) )
    {
      if ( strnlen(a2, 9u) <= 7uLL )
      {
        strncpy((char *)v6 + 136, a2, 8u);
        *((_DWORD *)v6 + 36) = sub_183A0(a1);
        v10 = sub_183A8(a1);
        v11 = sub_183A0(a1);
        *(_QWORD *)((char *)v6 + 148) = sub_15410(v10, v11, 0LL);
        return (__int64)v6;
      }
    }
  }
  return 1LL;
}

//----- (000000000001161C) ----------------------------------------------------
__int64 __fastcall sub_1161C(unsigned __int64 *a1, __int64 a2, char *a3)
{
  unsigned __int64 v6; // x0
  unsigned __int64 v7; // x20
  unsigned __int64 *v8; // x8

  v6 = sub_1151C(a2, a3);
  v7 = v6;
  if ( v6 > 0x13 || !(_DWORD)v6 )
  {
    sub_11AB8(a1[2], a2, a3, (__int64)(a1 + 7));
    if ( *a1 )
      v8 = (unsigned __int64 *)a1[1];
    else
      v8 = a1;
    *v8 = v7;
    a1[1] = v7;
    LODWORD(v7) = 0;
  }
  return (unsigned int)v7;
}

//----- (0000000000011698) ----------------------------------------------------
bool __fastcall sub_11698(_QWORD *a1)
{
  return *a1 == 0LL;
}

//----- (00000000000116A8) ----------------------------------------------------
__int64 __fastcall sub_116A8(__int64 a1, __int64 a2, char *s2)
{
  __int64 v3; // x20
  _QWORD *v7; // x8
  int v8; // w9
  __int64 v9; // x8
  char *v10; // x23
  int v11; // w0
  const char *v12; // x0
  __int64 v13; // x23
  unsigned __int64 v14; // x0
  FILE *v15; // x20
  char *v16; // x21
  unsigned int v17; // w22
  _QWORD *v19; // x22
  __int64 v20; // [xsp+0h] [xbp-40h] BYREF
  int v21; // [xsp+8h] [xbp-38h]
  int v22; // [xsp+Ch] [xbp-34h]

  v3 = *(_QWORD *)(a1 + 48);
  v20 = 0x5ABAF0150C00100LL;
  v21 = *(_DWORD *)(a1 + 24);
  v7 = *(_QWORD **)a1;
  v8 = 0;
  if ( *(_QWORD *)a1 )
  {
    do
    {
      v7 = (_QWORD *)*v7;
      ++v8;
    }
    while ( v7 );
  }
  v22 = v8;
  v9 = *(int *)(a1 + 32);
  if ( (unsigned int)v9 > 4 )
  {
    v10 = &byte_2231;
    if ( !s2 )
      goto LABEL_12;
  }
  else
  {
    v10 = off_19CA8[v9];
    if ( !s2 )
      goto LABEL_12;
  }
  if ( *s2 )
  {
    v11 = strncmp(v10, s2, 8u);
    if ( v11 )
      v3 = 0LL;
    if ( v11 )
      v10 = s2;
  }
LABEL_12:
  if ( *v10 )
    v12 = v10;
  else
    v12 = "spk";
  if ( *(_QWORD *)(a1 + 40) )
    v13 = *(_QWORD *)(a1 + 40);
  else
    v13 = 1047552LL;
  v14 = sub_11AD4(v12, a2, v3, v13 + 1024, 0LL);
  v15 = (FILE *)v14;
  if ( v14 <= 0x13 )
  {
    v16 = 0LL;
    v17 = v14;
    if ( (_DWORD)v14 )
      goto LABEL_20;
  }
  v16 = (char *)sub_1810C(v13);
  if ( !v16 )
  {
    v17 = 5;
    if ( !v15 )
      goto LABEL_21;
    goto LABEL_20;
  }
  setbuffer(v15, v16, v13);
  if ( fwrite(&v20, 0x10u, 1u, v15) != 1LL )
  {
LABEL_34:
    v17 = 6;
    if ( !v15 )
      goto LABEL_21;
LABEL_20:
    fclose(v15);
    goto LABEL_21;
  }
  if ( fwrite((const void *)(a1 + 56), 8u, 1u, v15) == 1LL )
  {
    v19 = *(_QWORD **)a1;
    if ( !*(_QWORD *)a1 )
    {
LABEL_30:
      v17 = (*(__int64 (__fastcall **)(_QWORD, FILE *))(**(_QWORD **)(a1 + 16) + 8LL))(*(_QWORD *)(a1 + 16), v15);
      if ( !v15 )
        goto LABEL_21;
      goto LABEL_20;
    }
    while ( fwrite(v19 + 1, 0x94u, 1u, v15) == 1LL )
    {
      v19 = (_QWORD *)*v19;
      if ( !v19 )
        goto LABEL_30;
    }
    goto LABEL_34;
  }
  v17 = 6;
  if ( v15 )
    goto LABEL_20;
LABEL_21:
  if ( v16 )
    j__free(v16);
  return v17;
}
// 117A0: conditional instruction was optimized away because of 'x0.8 in (1..13)'
// 2231: using guessed type char byte_2231;
// 19CA8: using guessed type char *off_19CA8[5];

//----- (0000000000011898) ----------------------------------------------------
__int64 __fastcall sub_11898(_QWORD *a1)
{
  __int64 result; // x0

  if ( *a1 == 0x5ABAF0150C00100LL )
    result = 0LL;
  else
    result = 3LL;
  return result;
}

//----- (00000000000118BC) ----------------------------------------------------
__int64 __fastcall sub_118BC(__int64 result, __int64 a2)
{
  *(_QWORD *)a2 = 0LL;
  *(_DWORD *)(a2 + 8) = result;
  return result;
}

//----- (00000000000118C8) ----------------------------------------------------
__int64 __fastcall sub_118C8(_QWORD *a1, int a2)
{
  __int64 v2; // x8

  v2 = *a1 + a2;
  *a1 = v2;
  return v2;
}

//----- (00000000000118DC) ----------------------------------------------------
__int64 __fastcall sub_118DC(__int64 a1)
{
  __int64 *v2; // x8

  pthread_rwlock_wrlock(&stru_1C900);
  if ( edata )
    v2 = (__int64 *)qword_1C8F8;
  else
    v2 = &edata;
  *v2 = a1;
  qword_1C8F8 = a1;
  return pthread_rwlock_unlock(&stru_1C900);
}
// 1C8F0: using guessed type __int64 edata;
// 1C8F8: using guessed type __int64 qword_1C8F8;

//----- (0000000000011920) ----------------------------------------------------
char *__fastcall sub_11920(__int64 a1, const char *a2, const char *a3, __int64 a4, __int64 a5, __int64 a6)
{
  char *v10; // x23
  char *result; // x0

  v10 = (char *)(a1 + 34832);
  memset((void *)a1, 0, 0x8860u);
  strncpy(v10, a2, 0x40u);
  result = strncpy((char *)(a1 + 34896), a3, 8u);
  *(_QWORD *)(a1 + 8) = a6;
  return result;
}

//----- (0000000000011988) ----------------------------------------------------
__int64 __fastcall sub_11988(__int64 a1, __int64 a2, const char *a3, int a4, __int64 a5)
{
  __int64 v5; // x30
  __int64 v11; // x25
  __int64 v12; // x0
  _QWORD v14[2]; // [xsp-88h] [xbp-88h] BYREF
  int v15; // [xsp-78h] [xbp-78h]
  __int64 v16; // [xsp-70h] [xbp-70h]
  __int64 v17; // [xsp-68h] [xbp-68h]
  int v18; // [xsp-60h] [xbp-60h]
  int v19; // [xsp-5Ch] [xbp-5Ch]
  __int64 v20; // [xsp-58h] [xbp-58h]
  __int64 v21; // [xsp-50h] [xbp-50h]

  v21 = v5;
  pthread_rwlock_rdlock(&stru_1C900);
  if ( !a3 )
  {
    v12 = sub_18398(a2);
    a3 = (const char *)sub_18710(v12);
    v11 = edata;
    if ( !edata )
      goto LABEL_7;
    do
    {
LABEL_5:
      if ( !strncmp((const char *)(v11 + 34896), a3, 8u) )
        break;
      v11 = *(_QWORD *)v11;
    }
    while ( v11 );
    goto LABEL_7;
  }
  v11 = edata;
  if ( edata )
    goto LABEL_5;
LABEL_7:
  v14[0] = v11;
  v14[1] = a2;
  v15 = 1;
  v16 = 0LL;
  v17 = a1;
  v18 = 0;
  v19 = a4;
  v20 = a5;
  sub_11D5C(v14);
  if ( v15 )
  {
    if ( v15 == 1 )
      (*(void (__fastcall **)(_QWORD *))(*(_QWORD *)(v14[0] + 8LL) + 8LL))(v14);
  }
  else
  {
    (**(void (__fastcall ***)(_QWORD *))(v14[0] + 8LL))(v14);
  }
  nullsub_2(v14);
  return pthread_rwlock_unlock(&stru_1C900);
}
// 119B0: variable 'v5' is possibly undefined
// C620: using guessed type __int64 __fastcall nullsub_2(_QWORD);
// 11D5C: using guessed type __int64 __fastcall sub_11D5C(_QWORD);
// 18398: using guessed type __int64 __fastcall sub_18398(_QWORD);
// 18710: using guessed type __int64 __fastcall sub_18710(_QWORD);
// 1C8F0: using guessed type __int64 edata;

//----- (0000000000011AB8) ----------------------------------------------------
__int64 __fastcall sub_11AB8(__int64 a1, __int64 a2, char *a3, __int64 a4)
{
  __int64 v8; // x25
  const char *v9; // x0
  __int64 v11; // x30
  __int64 v12[2]; // [xsp+8h] [xbp-88h] BYREF
  int v13; // [xsp+18h] [xbp-78h]
  __int64 v14; // [xsp+20h] [xbp-70h]
  __int64 v15; // [xsp+28h] [xbp-68h]
  int v16; // [xsp+30h] [xbp-60h]
  int v17; // [xsp+34h] [xbp-5Ch]
  __int64 v18; // [xsp+38h] [xbp-58h]
  __int64 v19; // [xsp+40h] [xbp-50h]

  v19 = v11;
  pthread_rwlock_rdlock(&stru_1C900);
  if ( !a3 )
  {
    v9 = (const char *)sub_18398(a2);
    a3 = sub_18710(v9);
    v8 = edata;
    if ( !edata )
      goto LABEL_7;
    do
    {
LABEL_5:
      if ( !strncmp((const char *)(v8 + 34896), a3, 8u) )
        break;
      v8 = *(_QWORD *)v8;
    }
    while ( v8 );
    goto LABEL_7;
  }
  v8 = edata;
  if ( edata )
    goto LABEL_5;
LABEL_7:
  v12[0] = v8;
  v12[1] = a2;
  v13 = 0;
  v14 = 0LL;
  v15 = a1;
  v16 = 0;
  v17 = 30;
  v18 = a4;
  sub_11D5C((__int64)v12);
  if ( v13 )
  {
    if ( v13 == 1 )
      (*(void (__fastcall **)(__int64 *))(*(_QWORD *)(v12[0] + 8) + 8LL))(v12);
  }
  else
  {
    (**(void (__fastcall ***)(__int64 *))(v12[0] + 8))(v12);
  }
  nullsub_2(v12);
  return pthread_rwlock_unlock(&stru_1C900);
}
// 119B0: variable 'v11' is possibly undefined
// C620: using guessed type __int64 __fastcall nullsub_2(_QWORD);
// 1C8F0: using guessed type __int64 edata;

//----- (0000000000011AD4) ----------------------------------------------------
__int64 __fastcall sub_11AD4(const char *a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5)
{
  __int64 v10; // x8
  __int64 v11; // x23
  __int64 v12; // x0
  __int64 v13; // x20
  void (__fastcall *v14)(__int64, __int64); // x8
  __int64 result; // x0

  if ( !strcmp(a1, "spk") )
  {
    v10 = 0LL;
  }
  else if ( !strcmp(a1, "xz") )
  {
    v10 = 1LL;
  }
  else
  {
    if ( strcmp(a1, "spo") )
      return 7LL;
    v10 = 2LL;
  }
  v11 = (__int64)*(&off_19CD0 + 2 * v10);
  if ( a5 )
    *a5 = v11 + 40;
  v12 = (*(__int64 (__fastcall **)(__int64, __int64))v11)(a2, a4);
  if ( !v12 )
    return 6LL;
  v13 = v12;
  if ( a3 )
  {
    v14 = *(void (__fastcall **)(__int64, __int64))(v11 + 32);
    if ( v14 )
    {
      v14(v12, a3);
      goto LABEL_13;
    }
    return 7LL;
  }
LABEL_13:
  result = funopen(v13, *(_QWORD *)(v11 + 8), *(_QWORD *)(v11 + 16), 0LL, *(_QWORD *)(v11 + 24));
  if ( !result )
    result = 6LL;
  return result;
}
// 18990: using guessed type __int64 __fastcall funopen(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 19CD0: using guessed type __int64 (__fastcall *off_19CD0)();

//----- (0000000000011BE4) ----------------------------------------------------
__int64 __fastcall sub_11BE4(const char *a1, __int64 a2, _QWORD *a3)
{
  __int64 result; // x0
  __int64 v7; // x8
  __int64 v8; // x21
  __int64 v9; // x0

  if ( !strcmp(a1, "spk") )
  {
    v7 = 0LL;
  }
  else if ( !strcmp(a1, "xz") )
  {
    v7 = 1LL;
  }
  else
  {
    if ( strcmp(a1, "spo") )
      return 7LL;
    v7 = 2LL;
  }
  v8 = (__int64)*(&off_19CD0 + 2 * v7);
  if ( a3 )
    *a3 = v8 + 40;
  v9 = (*(__int64 (__fastcall **)(__int64, __int64))v8)(a2, 0x10000LL);
  if ( !v9 )
    return 6LL;
  result = funopen(v9, *(_QWORD *)(v8 + 8), *(_QWORD *)(v8 + 16), 0LL, *(_QWORD *)(v8 + 24));
  if ( !result )
    result = 6LL;
  return result;
}
// 18990: using guessed type __int64 __fastcall funopen(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 19CD0: using guessed type __int64 (__fastcall *off_19CD0)();

//----- (0000000000011CBC) ----------------------------------------------------
__int64 __fastcall sub_11CBC(__int64 a1, int a2)
{
  __int64 v2; // x20
  unsigned __int64 v3; // x19
  unsigned __int64 v5; // x0

  v2 = a1;
  if ( (a2 & 0xFFFFFFFE) != 0 )
    return a1;
  v5 = sub_1533C(a1, 0x903uLL, 1);
  v3 = v5;
  if ( v5 <= 0x13 && (_DWORD)v5 )
    return v3;
  *(_QWORD *)(*(_QWORD *)(v5 + 16) + 0x4000LL) = *(_QWORD *)(*(_QWORD *)(v2 + 16) + 0x4000LL);
  *(_QWORD *)(*(_QWORD *)(v5 + 16) + 16392LL) = *(_QWORD *)(*(_QWORD *)(v2 + 16) + 16392LL);
  *(_QWORD *)(*(_QWORD *)(v5 + 16) + 16400LL) = *(_QWORD *)(*(_QWORD *)(v2 + 16) + 16408LL);
  memcpy((void *)(*(_QWORD *)(v5 + 16) + 16408LL), *(const void **)(v2 + 16), 0x800u);
  return v3;
}

//----- (0000000000011D5C) ----------------------------------------------------
__int64 __fastcall sub_11D5C(__int64 result)
{
  *(_DWORD *)(result + 40) = 2051;
  return result;
}

//----- (0000000000011D68) ----------------------------------------------------
void __fastcall sub_11D68(__int64 a1)
{
  __int64 v1; // x21
  __int64 v2; // x24
  unsigned __int64 v3; // x22
  __int64 v4; // x23
  char *v6; // x0
  void **v7; // x20
  unsigned int v8; // w0
  __int64 v9; // x3
  unsigned int v10; // w20
  __int64 v11; // x4
  __int64 v12[4]; // [xsp+0h] [xbp-70h] BYREF
  unsigned __int64 v13; // [xsp+20h] [xbp-50h]
  unsigned __int64 v14; // [xsp+28h] [xbp-48h]

  v2 = *(_QWORD *)(a1 + 40);
  v1 = *(_QWORD *)(a1 + 48);
  v4 = *(int *)(a1 + 28);
  v3 = *(int *)(a1 + 32);
  v6 = sub_16154(0, 0xFFFFFFFF);
  if ( v6 )
  {
    v7 = (void **)v6;
    v12[0] = v2;
    v12[1] = 0LL;
    v12[2] = v4;
    v12[3] = v1;
    v13 = 0LL;
    v14 = v3;
    do
    {
      v8 = sub_158F0((__int64)v7, v12);
      v9 = v8;
    }
    while ( !v8 && v13 < v14 );
    if ( v8 <= 1 )
    {
      sub_161E8(v7);
      v10 = v13;
      goto LABEL_9;
    }
  }
  else
  {
    v9 = 1000LL;
  }
  __android_log_print(6, "ob_file_handler", "xz failure %d in ob_file_handler", v9);
  v10 = -1;
LABEL_9:
  free(*(void **)(a1 + 40));
  v11 = *(unsigned int *)(a1 + 32);
  if ( v10 != (_DWORD)v11 )
    __android_log_print(
      6,
      "ob_file_handler",
      "Expected xz stream %d size %d, got %d",
      *(unsigned int *)(a1 + 8),
      v11,
      v10);
}

//----- (0000000000011E4C) ----------------------------------------------------
__int64 __fastcall sub_11E4C(__int64 a1)
{
  pthread_mutex_t *v2; // x19
  pthread_cond_t *v3; // x22
  pthread_cond_t *v4; // x21
  unsigned __int8 **v6; // x25
  unsigned __int8 *v7; // x8
  char v8; // w9
  int v9; // w8
  unsigned int v10; // w0
  __int64 v11; // x4

  v2 = (pthread_mutex_t *)(a1 + 16);
  v3 = (pthread_cond_t *)(a1 + 56);
  v4 = (pthread_cond_t *)(a1 + 104);
  while ( 1 )
  {
    pthread_mutex_lock(v2);
    v6 = *(unsigned __int8 ***)(a1 + 8);
    if ( !v6 )
      break;
LABEL_8:
    if ( *(_BYTE *)(a1 + 154) )
      goto LABEL_16;
    v7 = *v6;
    *v6 = (unsigned __int8 *)0x100000;
    v8 = *(_BYTE *)(a1 + 153);
    *(_QWORD *)(a1 + 8) = v7;
    *(_BYTE *)(a1 + 153) = v8 + 1;
    pthread_mutex_unlock(v2);
    v9 = *((unsigned __int8 *)v6 + 24);
    if ( v9 == 42 )
    {
      v10 = sub_13E44(v6[5], v6[6]);
      v11 = *((unsigned int *)v6 + 8);
      if ( v10 != (_DWORD)v11 )
        __android_log_print(
          6,
          "ob_file_handler",
          "Expected ob stream %d size %d, got %d",
          *((unsigned int *)v6 + 2),
          v11,
          v10);
      free(v6[5]);
    }
    else if ( v9 == 1 )
    {
      sub_11D68((__int64)v6);
    }
    free(v6);
    pthread_mutex_lock(v2);
    if ( (unsigned __int8)(*(_BYTE *)(a1 + 154) | --*(_BYTE *)(a1 + 153)) == 0 && !*(_QWORD *)(a1 + 8) )
      pthread_cond_signal(v4);
    pthread_mutex_unlock(v2);
  }
  while ( !*(_BYTE *)(a1 + 154) )
  {
    pthread_cond_wait(v3, v2);
    v6 = *(unsigned __int8 ***)(a1 + 8);
    if ( v6 )
      goto LABEL_8;
  }
LABEL_16:
  --*(_BYTE *)(a1 + 152);
  pthread_cond_signal(v4);
  pthread_mutex_unlock(v2);
  return 0LL;
}

//----- (0000000000011FB4) ----------------------------------------------------
void __fastcall sub_11FB4(__int64 a1)
{
  pthread_mutex_t *v1; // x20
  _QWORD *v3; // x22
  unsigned int v4; // w21

  if ( a1 )
  {
    v1 = (pthread_mutex_t *)(a1 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    v3 = *(_QWORD **)(a1 + 8);
    if ( v3 )
    {
      v4 = 0;
      do
      {
        free(v3);
        v3 = (_QWORD *)*v3;
        ++v4;
      }
      while ( v3 );
      __android_log_print(6, "ob_file_handler", "%d work items were not completed", v4);
    }
    *(_BYTE *)(a1 + 154) = 1;
    pthread_cond_broadcast((pthread_cond_t *)(a1 + 56));
    pthread_mutex_unlock(v1);
    pthread_mutex_lock(v1);
    while ( 1 )
    {
      if ( *(_BYTE *)(a1 + 154) )
      {
        if ( !*(_BYTE *)(a1 + 152) )
          goto LABEL_12;
      }
      else if ( !*(_BYTE *)(a1 + 153) && !*(_QWORD *)(a1 + 8) )
      {
LABEL_12:
        pthread_mutex_unlock(v1);
        pthread_mutex_destroy(v1);
        pthread_cond_destroy((pthread_cond_t *)(a1 + 56));
        pthread_cond_destroy((pthread_cond_t *)(a1 + 104));
        free((void *)a1);
        return;
      }
      pthread_cond_wait((pthread_cond_t *)(a1 + 104), v1);
    }
  }
}

//----- (00000000000120AC) ----------------------------------------------------
_QWORD *__fastcall sub_120AC(__int64 a1)
{
  _QWORD *v2; // x20
  pthread_t newthread; // [xsp+8h] [xbp-28h] BYREF

  v2 = sub_180F4(1u, 0xA0u);
  *((_BYTE *)v2 + 152) = 3;
  pthread_mutex_init((pthread_mutex_t *)(v2 + 2), 0LL);
  pthread_cond_init((pthread_cond_t *)(v2 + 7), 0LL);
  pthread_cond_init((pthread_cond_t *)(v2 + 13), 0LL);
  v2[1] = 0LL;
  pthread_create(&newthread, 0LL, (void *(*)(void *))sub_11E4C, v2);
  pthread_detach(newthread);
  pthread_create(&newthread, 0LL, (void *(*)(void *))sub_11E4C, v2);
  pthread_detach(newthread);
  pthread_create(&newthread, 0LL, (void *(*)(void *))sub_11E4C, v2);
  pthread_detach(newthread);
  if ( v2 )
    *v2 = a1;
  return v2;
}

//----- (0000000000012174) ----------------------------------------------------
__int64 __fastcall sub_12174(__int64 a1, __int64 *a2)
{
  __int64 v3; // x21
  _QWORD *v4; // x29
  __int64 v5; // x19
  __int64 result; // x0
  int v7; // w9
  __int64 v8; // x25
  unsigned int v9; // w24
  size_t v10; // w26
  __int64 v11; // x23
  void *v12; // x27
  __int64 v13; // x8
  char v14; // w22
  __int64 v15; // x21
  _DWORD *v16; // x0
  _DWORD *v17; // x25
  _QWORD *v18; // x8
  pthread_mutex_t *mutex; // [xsp+18h] [xbp-88h]
  FILE *v21; // [xsp+20h] [xbp-80h]
  int ptr[3]; // [xsp+28h] [xbp-78h] BYREF
  int v23; // [xsp+34h] [xbp-6Ch]
  unsigned int v24; // [xsp+38h] [xbp-68h]
  char v25; // [xsp+3Ch] [xbp-64h]

  v3 = sub_14A5C(0x903uLL);
  v21 = *(FILE **)a1;
  if ( fread(ptr, 0x16u, 1u, *(FILE **)a1) == 1LL )
  {
    v4 = 0LL;
    mutex = (pthread_mutex_t *)(a1 + 16);
    do
    {
      v5 = (unsigned int)ptr[0];
      if ( *(_QWORD *)(v3 + 8) <= (unsigned __int64)(unsigned int)ptr[0] )
      {
        result = sub_14978(v3, (unsigned int)(ptr[0] + 1));
        if ( (_DWORD)result )
          return result;
      }
      v7 = v23;
      v8 = *(_QWORD *)(*(_QWORD *)(v3 + 16) + 8 * v5);
      v9 = (v23 + 3) & 0xFFFFFFFC;
      *(_DWORD *)(v8 + 40) = v9;
      *(_DWORD *)(v8 + 16) = v7;
      sub_14D88(v8);
      if ( !*(_QWORD *)v8 )
        goto LABEL_17;
      *(_QWORD *)(v8 + 8) = *(_QWORD *)v8;
      v10 = v24;
      v11 = v3;
      v12 = (void *)__wrap_malloc(v24);
      fread(v12, v10, 1u, v21);
      v13 = *(_QWORD *)v8;
      *(_QWORD *)(v8 + 8) = *(_QWORD *)v8;
      v14 = v25;
      v15 = *(_QWORD *)(v13 + 8);
      v16 = calloc(1u, 0x38u);
      v16[2] = v5;
      v17 = v16;
      *((_BYTE *)v16 + 24) = v14;
      *((_QWORD *)v16 + 5) = v12;
      *((_QWORD *)v16 + 6) = v15;
      v16[7] = v10;
      v16[8] = v9;
      v3 = v11;
      pthread_mutex_lock(mutex);
      if ( *(_QWORD *)(a1 + 8) )
        v18 = v4;
      else
        v18 = (_QWORD *)(a1 + 8);
      *v18 = v17;
      pthread_cond_broadcast((pthread_cond_t *)(a1 + 56));
      pthread_mutex_unlock(mutex);
      v4 = v17;
    }
    while ( fread(ptr, 0x16u, 1u, v21) == 1LL );
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  while ( *(_BYTE *)(a1 + 154) )
  {
    if ( !*(_BYTE *)(a1 + 152) )
      goto LABEL_16;
LABEL_12:
    pthread_cond_wait((pthread_cond_t *)(a1 + 104), (pthread_mutex_t *)(a1 + 16));
  }
  if ( *(_BYTE *)(a1 + 153) || *(_QWORD *)(a1 + 8) )
    goto LABEL_12;
LABEL_16:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
LABEL_17:
  result = 8LL;
  *a2 = v3;
  return result;
}
// 18890: using guessed type __int64 __fastcall __wrap_malloc(_QWORD);

//----- (0000000000012348) ----------------------------------------------------
__int64 sub_12348()
{
  return 0xFFFFFFFFLL;
}

//----- (0000000000012350) ----------------------------------------------------
__int64 __fastcall sub_12350(__int64 a1)
{
  sub_11FB4(a1);
  return 0LL;
}

//----- (0000000000012364) ----------------------------------------------------
void __fastcall sub_12364(__int64 a1, unsigned __int8 *a2)
{
  __int64 v4; // x0
  int v5; // w8
  __int64 v6; // x28
  _OWORD *v7; // x24
  int v8; // w27
  int v9; // w22
  __int128 v10; // q0
  unsigned __int64 v11; // x9
  int v12; // w29
  unsigned int v13; // w13
  unsigned int v14; // w8
  unsigned int v15; // w12
  unsigned int v16; // w11
  int v17; // w14
  unsigned __int8 v18; // w15
  unsigned int v19; // w13
  _DWORD *v20; // x30
  __int64 v21; // x14
  unsigned int v22; // w15
  unsigned __int8 v23; // w17
  bool v24; // cc
  int v25; // w11
  unsigned int v26; // w14
  unsigned int v27; // w11
  unsigned int v28; // w12
  unsigned int v29; // w13
  unsigned __int8 v30; // w8
  unsigned int v31; // w10
  int v32; // w14
  unsigned __int8 v33; // w15
  unsigned int v34; // w10
  __int64 v35; // x14
  unsigned int v36; // w15
  unsigned __int8 v37; // w17
  __int64 v38; // x10
  int v39; // w17
  int v40; // w12
  signed __int64 v41; // x26
  int v42; // w11
  int v43; // w12
  int v44; // w13
  int v45; // w15
  bool v46; // w3
  unsigned int v47; // w1
  unsigned int v48; // w2
  int v49; // w1
  unsigned __int8 v50; // w7
  char v51; // w2
  char *v52; // x1
  unsigned __int8 *v53; // x17
  unsigned int v54; // w0
  unsigned int v55; // w3
  unsigned int v56; // w4
  int v57; // w6
  unsigned __int8 v58; // w7
  unsigned int v59; // w5
  __int64 v60; // x6
  unsigned int v61; // w7
  unsigned __int8 v62; // w21
  __int128 v63; // q0
  _OWORD *v64; // x11
  __int64 v65; // x22
  __int128 v66; // q0
  __int64 v67; // x17
  bool v68; // zf
  int *v69; // x1
  int v70; // w7
  __int64 v71; // x0
  char *v72; // x1
  _BYTE *v73; // x1
  int v74; // t1
  int v75; // w1
  _OWORD *v76; // x1
  int *v77; // x5
  int v78; // w2
  int v79; // w4
  _QWORD *v80; // x3
  int *v81; // x5
  int v82; // w6
  int v83; // w9
  unsigned __int8 v84; // w9
  int v85; // w23
  __int64 v86; // x21
  unsigned __int8 *v87; // x20
  unsigned int v88; // w7
  unsigned int v89; // w24
  unsigned int v90; // w25
  int v91; // w29
  unsigned __int8 v92; // w30
  unsigned int v93; // w13
  __int64 v94; // x29
  unsigned int v95; // w30
  unsigned __int8 v96; // w27
  unsigned __int8 v97; // w20
  int *v98; // x1
  __int64 v99; // x0
  unsigned __int64 v100; // x1
  int v101; // w1
  _OWORD *v102; // x1
  int *v103; // x5
  int v104; // w2
  int v105; // w4
  _QWORD *v106; // x3
  int *v107; // x5
  int v108; // w6
  int v109; // w9
  unsigned __int8 v110; // w9
  int v111; // w23
  __int64 v112; // x21
  unsigned __int8 *v113; // x7
  unsigned int v114; // w20
  unsigned int v115; // w24
  unsigned int v116; // w25
  int v117; // w29
  unsigned __int8 v118; // w30
  unsigned int v119; // w13
  __int64 v120; // x29
  unsigned int v121; // w30
  unsigned __int8 v122; // w27
  __int64 v123; // x20
  __int128 v124; // q2
  int v125; // w14
  unsigned __int64 v126; // x9
  char v127; // w11
  int v128; // w10
  int v129; // w13
  unsigned int *v130; // x12
  int v131; // w15
  bool v132; // w2
  unsigned int v133; // w1
  int v134; // w0
  char v135; // w27
  unsigned __int8 *v136; // x16
  unsigned int v137; // w17
  unsigned int v138; // w0
  unsigned int v139; // w1
  int v140; // w3
  unsigned __int8 v141; // w4
  unsigned int v142; // w2
  __int64 v143; // x3
  unsigned int v144; // w4
  unsigned __int8 v145; // w6
  unsigned __int64 v146; // x9
  int v147; // w8
  _OWORD *v148; // x10
  __int64 v149; // x8
  int v150; // w9
  __int64 v151; // x11
  char v152; // w13
  int v153; // w10
  int v154; // w12
  char *v155; // x14
  int v156; // w15
  bool v157; // cc
  unsigned int v158; // w1
  char v159; // w2
  int v160; // w0
  unsigned __int8 v161; // w0
  unsigned __int8 v162; // w17
  unsigned __int8 *v163; // x16
  unsigned int v164; // w17
  unsigned int v165; // w0
  unsigned int v166; // w1
  int v167; // w3
  unsigned __int8 v168; // w4
  unsigned int v169; // w2
  __int64 v170; // x3
  unsigned int v171; // w4
  unsigned __int8 v172; // w6
  _OWORD *v173; // x9
  unsigned int v174; // w9
  int v175; // w8
  unsigned int v176; // w10
  int v177; // w8
  char v178; // w11
  unsigned int v179; // w12
  int v180; // w11
  unsigned int v181; // w12
  __int64 v182; // x13
  unsigned int v183; // w14
  unsigned __int8 v184; // w16
  unsigned int v185; // w14
  unsigned int v186; // w16
  int v187; // w15
  __int64 v188; // x12
  unsigned int v189; // w17
  unsigned int v190; // w13
  unsigned __int8 v191; // w11
  unsigned int v192; // w11
  _OWORD *v193; // x8
  __int64 v194; // x11
  char v195; // w13
  int v196; // w10
  int v197; // w12
  char *v198; // x14
  int v199; // w15
  bool v200; // cc
  unsigned int v201; // w1
  char v202; // w2
  int v203; // w0
  unsigned __int8 v204; // w0
  char v205; // w17
  unsigned __int8 *v206; // x16
  unsigned int v207; // w17
  unsigned int v208; // w0
  unsigned int v209; // w1
  int v210; // w3
  unsigned __int8 v211; // w4
  unsigned int v212; // w2
  __int64 v213; // x3
  unsigned int v214; // w4
  unsigned __int8 v215; // w6
  __int64 v216; // x8
  unsigned __int8 *v217; // x30
  int v218; // w9
  __int64 v219; // x8
  __int64 v220; // x9
  unsigned __int8 v221; // w0
  unsigned __int8 v222; // w10
  __int64 v223; // x13
  int *v224; // x11
  __int64 v225; // x10
  char *v226; // x11
  _BYTE *v227; // x11
  int v228; // t1
  int v229; // w11
  _OWORD *v230; // x11
  int *v231; // x15
  int v232; // w12
  int v233; // w14
  _QWORD *v234; // x13
  int *v235; // x15
  int v236; // w16
  unsigned int v237; // w1
  unsigned int v238; // w2
  bool v239; // w3
  int v240; // w1
  unsigned __int8 v241; // w1
  int v242; // w2
  __int64 v243; // x1
  unsigned __int8 *v244; // x17
  unsigned int v245; // w0
  unsigned int v246; // w3
  unsigned int v247; // w4
  int v248; // w6
  unsigned __int8 v249; // w7
  unsigned int v250; // w5
  __int64 v251; // x6
  unsigned int v252; // w7
  unsigned __int8 v253; // w27
  unsigned __int8 v254; // w0
  __int64 v255; // x10
  unsigned __int8 v256; // w10
  __int64 v257; // x14
  int *v258; // x11
  __int64 v259; // x10
  char *v260; // x11
  _BYTE *v261; // x11
  int v262; // t1
  int v263; // w11
  _OWORD *v264; // x11
  int *v265; // x15
  int v266; // w12
  int v267; // w13
  _QWORD *v268; // x14
  int *v269; // x15
  int v270; // w16
  unsigned int v271; // w1
  unsigned int v272; // w2
  bool v273; // w3
  int v274; // w1
  unsigned __int8 v275; // w1
  int v276; // w2
  __int64 v277; // x1
  unsigned __int8 *v278; // x17
  unsigned int v279; // w0
  unsigned int v280; // w3
  unsigned int v281; // w4
  int v282; // w6
  unsigned __int8 v283; // w7
  unsigned int v284; // w5
  __int64 v285; // x6
  unsigned int v286; // w7
  unsigned __int8 v287; // w27
  int v288; // w14
  unsigned int v289; // w15
  unsigned __int8 v290; // w17
  __int64 v291; // x9
  int v292; // w10
  __int64 v293; // x12
  char v294; // w14
  int v295; // w11
  int v296; // w13
  char *v297; // x15
  int v298; // w16
  bool v299; // cc
  unsigned int v300; // w2
  char v301; // w3
  int v302; // w1
  unsigned __int8 v303; // w1
  unsigned __int8 v304; // w0
  unsigned __int8 *v305; // x17
  unsigned int v306; // w0
  unsigned int v307; // w1
  unsigned int v308; // w2
  int v309; // w4
  unsigned __int8 v310; // w5
  unsigned int v311; // w3
  __int64 v312; // x4
  unsigned int v313; // w5
  unsigned __int8 v314; // w7
  unsigned __int8 v315; // w10
  _BOOL4 v316; // w9
  char v317; // w11
  unsigned int v318; // w14
  unsigned int v319; // w16
  int v320; // w15
  __int64 v321; // x12
  unsigned int v322; // w17
  unsigned int v323; // w13
  unsigned __int8 v324; // w11
  unsigned int v325; // w11
  _OWORD *v326; // x10
  unsigned int v327; // w12
  int v328; // w11
  unsigned int v329; // w12
  __int64 v330; // x13
  unsigned int v331; // w14
  unsigned __int8 v332; // w16
  int v333; // w14
  unsigned int v334; // w15
  unsigned __int8 v335; // w17
  int v336; // w10
  int v337; // w10
  signed int v338; // w10
  char *v339; // x0
  size_t v340; // w29
  char *v341; // x1
  __int64 v342; // x8
  __int64 v343; // x11
  __int64 v344; // x10
  unsigned __int8 *v345; // x9
  __int64 v346; // x13
  unsigned __int8 *v347; // x12
  __int128 v348; // q1
  _OWORD *v349; // x9
  __int64 v350; // x11
  char v351; // w13
  int v352; // w10
  int v353; // w12
  char *v354; // x14
  int v355; // w15
  bool v356; // cc
  unsigned int v357; // w1
  char v358; // w2
  int v359; // w0
  unsigned __int8 v360; // w0
  char v361; // w17
  unsigned __int8 *v362; // x16
  unsigned int v363; // w17
  unsigned int v364; // w0
  unsigned int v365; // w1
  int v366; // w3
  unsigned __int8 v367; // w4
  unsigned int v368; // w2
  __int64 v369; // x3
  unsigned int v370; // w4
  unsigned __int8 v371; // w6
  __int64 v372; // x8
  _OWORD *v373; // x9
  int v374; // w9
  __int64 v375; // x11
  char v376; // w12
  int v377; // w10
  int v378; // w14
  char *v379; // x13
  bool v380; // cc
  unsigned int v381; // w0
  char v382; // w1
  int v383; // w17
  unsigned __int8 *v384; // x15
  unsigned int v385; // w16
  unsigned int v386; // w17
  unsigned int v387; // w0
  int v388; // w2
  unsigned __int8 v389; // w3
  unsigned int v390; // w1
  __int64 v391; // x2
  unsigned int v392; // w3
  unsigned __int8 v393; // w5
  int v394; // w27
  __int64 v395; // x9
  unsigned __int8 v396; // w8
  int v397; // w10
  __int64 v398; // x12
  char v399; // w14
  int v400; // w11
  int v401; // w13
  char *v402; // x15
  int v403; // w16
  bool v404; // cc
  unsigned int v405; // w2
  char v406; // w3
  int v407; // w1
  unsigned __int8 v408; // w1
  char v409; // w0
  unsigned __int8 *v410; // x17
  unsigned int v411; // w0
  unsigned int v412; // w1
  unsigned int v413; // w2
  int v414; // w4
  unsigned __int8 v415; // w5
  unsigned int v416; // w3
  __int64 v417; // x4
  unsigned int v418; // w5
  unsigned __int8 v419; // w7
  _OWORD *v420; // x10
  __int64 v421; // x8
  _OWORD *v422; // x9
  int v423; // w9
  __int64 v424; // x11
  char v425; // w12
  int v426; // w10
  int v427; // w14
  char *v428; // x13
  bool v429; // cc
  unsigned int v430; // w0
  char v431; // w1
  int v432; // w17
  unsigned __int8 *v433; // x15
  unsigned int v434; // w16
  unsigned int v435; // w17
  unsigned int v436; // w0
  int v437; // w2
  unsigned __int8 v438; // w3
  unsigned int v439; // w1
  __int64 v440; // x2
  unsigned int v441; // w3
  unsigned __int8 v442; // w5
  int v443; // w9
  size_t n; // [xsp+30h] [xbp-C250h]
  __int64 v445; // [xsp+50h] [xbp-C230h]
  void *ptr; // [xsp+78h] [xbp-C208h]
  _BYTE *v447; // [xsp+80h] [xbp-C200h]
  _DWORD *v448; // [xsp+80h] [xbp-C200h]
  _BYTE *v449; // [xsp+88h] [xbp-C1F8h]
  int v450; // [xsp+88h] [xbp-C1F8h]
  int v451; // [xsp+90h] [xbp-C1F0h]
  int s[1026]; // [xsp+98h] [xbp-C1E8h] BYREF
  _OWORD *v453; // [xsp+10A0h] [xbp-B1E0h]
  char v454[4]; // [xsp+10B0h] [xbp-B1D0h]
  int v455; // [xsp+10B4h] [xbp-B1CCh]
  int v456; // [xsp+10B8h] [xbp-B1C8h]
  _OWORD *v457; // [xsp+20C0h] [xbp-A1C0h]
  char v458; // [xsp+20D0h] [xbp-A1B0h]
  int v459; // [xsp+20D4h] [xbp-A1ACh]
  int v460; // [xsp+20D8h] [xbp-A1A8h]
  _OWORD *v461; // [xsp+30E0h] [xbp-91A0h]
  char v462; // [xsp+30F0h] [xbp-9190h]
  int v463; // [xsp+30F4h] [xbp-918Ch]
  int v464; // [xsp+30F8h] [xbp-9188h]
  _OWORD *v465; // [xsp+4100h] [xbp-8180h]
  char v466; // [xsp+4110h] [xbp-8170h]
  int v467; // [xsp+4114h] [xbp-816Ch]
  _DWORD v468[1026]; // [xsp+4118h] [xbp-8168h] BYREF
  _OWORD *v469; // [xsp+5120h] [xbp-7160h]
  unsigned __int8 v470; // [xsp+5130h] [xbp-7150h]
  int v471; // [xsp+5134h] [xbp-714Ch]
  _DWORD v472[1026]; // [xsp+5138h] [xbp-7148h] BYREF
  _OWORD *v473; // [xsp+6140h] [xbp-6140h]
  unsigned __int8 v474; // [xsp+6150h] [xbp-6130h]
  int v475; // [xsp+6154h] [xbp-612Ch]
  _DWORD v476[1026]; // [xsp+6158h] [xbp-6128h] BYREF
  _OWORD *v477; // [xsp+7160h] [xbp-5120h]
  unsigned __int8 v478; // [xsp+7170h] [xbp-5110h]
  int v479; // [xsp+7174h] [xbp-510Ch]
  _DWORD v480[1026]; // [xsp+7178h] [xbp-5108h] BYREF
  _OWORD *v481; // [xsp+8180h] [xbp-4100h]
  unsigned __int8 v482; // [xsp+8190h] [xbp-40F0h]
  int v483; // [xsp+8194h] [xbp-40ECh]
  _DWORD v484[1026]; // [xsp+8198h] [xbp-40E8h] BYREF
  _OWORD *v485; // [xsp+91A0h] [xbp-30E0h]
  unsigned __int8 v486; // [xsp+91B0h] [xbp-30D0h]
  int v487; // [xsp+91B4h] [xbp-30CCh]
  _DWORD v488[1026]; // [xsp+91B8h] [xbp-30C8h] BYREF
  _OWORD *v489; // [xsp+A1C0h] [xbp-20C0h]
  unsigned __int8 v490; // [xsp+A1D0h] [xbp-20B0h]
  int v491; // [xsp+A1D4h] [xbp-20ACh]
  _DWORD v492[193]; // [xsp+A1D8h] [xbp-20A8h] BYREF
  char v493; // [xsp+A4DCh] [xbp-1DA4h]
  _OWORD *v494; // [xsp+B1E0h] [xbp-10A0h]
  unsigned __int8 v495; // [xsp+B1F0h] [xbp-1090h]
  int v496; // [xsp+B1F4h] [xbp-108Ch]
  _DWORD v497[129]; // [xsp+B1F8h] [xbp-1088h] BYREF
  char v498; // [xsp+B3FCh] [xbp-E84h]
  _OWORD *v499; // [xsp+C200h] [xbp-80h]
  unsigned __int8 v500; // [xsp+C210h] [xbp-70h]
  int v501; // [xsp+C214h] [xbp-6Ch]
  __int64 v502; // [xsp+C218h] [xbp-68h]

  v502 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v4 = __wrap_malloc(1048600LL);
  if ( !v4 )
    return;
  v5 = *(_DWORD *)(a1 + 112);
  v6 = v4 + 0x100000;
  *(_DWORD *)(v4 + 0x100000) = *(_DWORD *)(a1 + 104);
  *(_DWORD *)(v4 + 1048580) = v5;
  *(_DWORD *)(v4 + 1048584) = 0;
  v449 = (_BYTE *)(v4 + 196609);
  v7 = (_OWORD *)v4;
  v447 = (_BYTE *)(v4 + 131073);
  *(_QWORD *)(v4 + 1048592) = *(_QWORD *)(a1 + 120);
  memset(s, 0, 0x4080u);
  ptr = v7;
  v453 = v7;
  v454[0] = 8;
  v8 = *(_DWORD *)(a1 + 16);
  v457 = v7;
  v456 = 1;
  v455 = v8;
  v458 = 8;
  v461 = v7;
  v459 = v8;
  v460 = 2;
  v462 = 8;
  v463 = v8;
  v464 = 3;
  v465 = v7;
  v466 = 8;
  v467 = v8;
  memset(v497, 0, 0x1020u);
  v499 = v7;
  v497[0] = 2;
  v500 = 1;
  v501 = *(_DWORD *)(a1 + 48);
  v9 = v501;
  memset(v492, 0, 0x1020u);
  v492[0] = 3;
  v494 = v7;
  v495 = 1;
  v496 = v9;
  memset(v488, 0, 0x1020u);
  v489 = v7;
  v488[0] = 4;
  v490 = 1;
  v491 = v9;
  memset(v484, 0, 0x1020u);
  v485 = v7;
  v484[0] = 5;
  v486 = 1;
  v487 = v9;
  memset(v480, 0, 0x1020u);
  v481 = v7;
  v480[0] = 6;
  v482 = 1;
  v483 = v9;
  memset(v476, 0, 0x1020u);
  v476[0] = 7;
  v477 = v7;
  v478 = 8;
  v479 = v8;
  memset(v472, 0, 0x1020u);
  v472[0] = 8;
  v473 = v7;
  v474 = 5;
  v475 = *(_DWORD *)(a1 + 32);
  memset(v468, 0, 0x1020u);
  v468[0] = 9;
  v469 = v7;
  v470 = 5;
  *(_QWORD *)&v10 = 0x8080808080808080LL;
  *((_QWORD *)&v10 + 1) = 0x8080808080808080LL;
  v471 = *(_DWORD *)(a1 + 24);
  v11 = *(unsigned int *)(a1 + 68);
  v12 = *(_DWORD *)(a1 + 76);
  v7[8206] = v10;
  v7[8207] = v10;
  v7[8204] = v10;
  v7[8205] = v10;
  v7[8202] = v10;
  v7[8203] = v10;
  v7[8200] = v10;
  v7[8201] = v10;
  v7[8198] = v10;
  v7[8199] = v10;
  v7[8196] = v10;
  v7[8197] = v10;
  v7[8194] = v10;
  v7[8195] = v10;
  v7[0x2000] = v10;
  v7[8193] = v10;
  v13 = *(_DWORD *)(v6 + 4);
  v14 = (unsigned __int8)*v447;
  v498 = 1;
  v15 = (unsigned __int8)v13;
  v16 = 256 - v14;
  v17 = (unsigned __int8)-(char)v14;
  if ( 256 - v14 > (unsigned __int8)v13 )
    v18 = -(char)v14;
  else
    v18 = v14;
  if ( v16 > (unsigned __int8)v13 )
    v17 = 0;
  v19 = (unsigned __int8)v13 - v17 + v18 * (v13 >> 8);
  v20 = (_DWORD *)a1;
  *(_DWORD *)(v6 + 4) = v19;
  if ( !HIBYTE(v19) )
  {
    v21 = *(_QWORD *)(v6 + 16);
    v22 = *(_DWORD *)(v6 + 8);
    do
    {
      *(_DWORD *)(v6 + 8) = v22 + 1;
      v23 = *(_BYTE *)(v21 + v22++);
      v19 = v23 | (v19 << 8);
      *(_DWORD *)(v6 + 4) = v19;
    }
    while ( !HIBYTE(v19) );
  }
  v24 = v16 > v15;
  v25 = v16 >> v9;
  if ( v24 )
    v25 = -(v14 >> v9);
  *v447 = v25 + v14;
  v7[12302] = v10;
  v7[12303] = v10;
  v7[12300] = v10;
  v7[12301] = v10;
  v7[12298] = v10;
  v7[12299] = v10;
  v7[12296] = v10;
  v7[12297] = v10;
  v7[12294] = v10;
  v7[12295] = v10;
  v7[12292] = v10;
  v7[12293] = v10;
  v7[12290] = v10;
  v7[12291] = v10;
  v7[12288] = v10;
  v7[12289] = v10;
  v26 = *(_DWORD *)(v6 + 4);
  v27 = (unsigned __int8)*v449;
  v28 = (unsigned __int8)v26;
  v29 = 256 - v27;
  v493 = 1;
  v30 = !v24;
  v31 = v26 >> 8;
  v32 = (unsigned __int8)-(char)v27;
  if ( v29 <= v28 )
    v33 = v27;
  else
    v33 = -(char)v27;
  if ( v29 > v28 )
    v32 = 0;
  v34 = v28 - v32 + v33 * v31;
  *(_DWORD *)(v6 + 4) = v34;
  if ( !HIBYTE(v34) )
  {
    v35 = *(_QWORD *)(v6 + 16);
    v36 = *(_DWORD *)(v6 + 8);
    do
    {
      *(_DWORD *)(v6 + 8) = v36 + 1;
      v37 = *(_BYTE *)(v35 + v36++);
      v34 = v37 | (v34 << 8);
      *(_DWORD *)(v6 + 4) = v34;
    }
    while ( !HIBYTE(v34) );
  }
  v38 = s[0] << 8;
  v39 = *((unsigned __int8 *)&s[1] + v38);
  if ( v29 > v28 )
    v40 = -(v27 >> v9);
  else
    LOBYTE(v40) = v29 >> v9;
  *v449 = v40 + v27;
  if ( v39 )
  {
    v41 = v11 >> 3;
    v42 = (unsigned __int8)v454[0];
    if ( v454[0] )
      goto LABEL_29;
  }
  else
  {
    *(_BYTE *)(((unsigned __int64)s + v38) | 4) = 1;
    *(_QWORD *)&v63 = 0x8080808080808080LL;
    *((_QWORD *)&v63 + 1) = 0x8080808080808080LL;
    v64 = &v453[16 * v38];
    v64[14] = v63;
    v64[15] = v63;
    v64[12] = v63;
    v64[13] = v63;
    v64[10] = v63;
    v64[11] = v63;
    v64[8] = v63;
    v64[9] = v63;
    v64[6] = v63;
    v64[7] = v63;
    v64[4] = v63;
    v64[5] = v63;
    v64[2] = v63;
    v64[3] = v63;
    *v64 = v63;
    v64[1] = v63;
    v41 = v11 >> 3;
    v42 = (unsigned __int8)v454[0];
    if ( v454[0] )
    {
LABEL_29:
      v43 = 0;
      v44 = 0;
      v45 = 1;
      do
      {
        v51 = v455;
        v52 = (char *)v453 + 1048580;
        v53 = (unsigned __int8 *)&v453[16 * v38] + v45;
        v54 = *v53;
        v55 = (unsigned __int8)*((_DWORD *)v453 + 262145);
        v56 = 256 - v54;
        v57 = (unsigned __int8)-(char)v54;
        if ( 256 - v54 > v55 )
          v58 = -(char)v54;
        else
          v58 = *v53;
        if ( v56 > v55 )
          v57 = 0;
        v59 = v55 - v57 + v58 * (*((_DWORD *)v453 + 262145) >> 8);
        *(_DWORD *)v52 = v59;
        if ( !HIBYTE(v59) )
        {
          v60 = *(_QWORD *)(v52 + 12);
          v61 = *((_DWORD *)v52 + 1);
          do
          {
            *((_DWORD *)v52 + 1) = v61 + 1;
            v62 = *(_BYTE *)(v60 + v61++);
            v59 = v62 | (v59 << 8);
            *(_DWORD *)v52 = v59;
          }
          while ( !HIBYTE(v59) );
        }
        v24 = v56 > v55;
        v46 = v56 <= v55;
        v47 = v54 >> v51;
        v48 = v56 >> v51;
        ++v43;
        if ( v24 )
          v49 = -v47;
        else
          LOBYTE(v49) = v48;
        v50 = v46 | (2 * v44);
        v45 = v46 | (2 * v45);
        v44 = v46 | (2 * v44);
        *v53 = v49 + v54;
      }
      while ( v43 != v42 );
      goto LABEL_46;
    }
  }
  v50 = 0;
LABEL_46:
  *a2 = v50;
  v448 = v20;
  v450 = v12;
  if ( (unsigned int)v11 >= 0x10 )
  {
    if ( (unsigned int)v41 <= 2 )
      v65 = 2LL;
    else
      v65 = (unsigned int)v41;
    *(_QWORD *)&v66 = 0x8080808080808080LL;
    *((_QWORD *)&v66 + 1) = 0x8080808080808080LL;
    v67 = 1LL;
    if ( !v12 )
    {
      while ( 1 )
      {
        v98 = &s[1032 * v67];
        v99 = *v98 << 8;
        v100 = (unsigned __int64)v98 + v99;
        if ( *(_BYTE *)(v100 + 4) )
        {
          v101 = (unsigned __int8)v454[4128 * v67];
          if ( v454[4128 * v67] )
            goto LABEL_78;
        }
        else
        {
          *(_BYTE *)(v100 | 4) = 1;
          v102 = (_OWORD *)(*(_QWORD *)&s[1032 * v67 + 1026] + (v99 << 8));
          v102[14] = v66;
          v102[15] = v66;
          v102[12] = v66;
          v102[13] = v66;
          v102[10] = v66;
          v102[11] = v66;
          v102[8] = v66;
          v102[9] = v66;
          v102[6] = v66;
          v102[7] = v66;
          v102[4] = v66;
          v102[5] = v66;
          v102[2] = v66;
          v102[3] = v66;
          *v102 = v66;
          v102[1] = v66;
          v101 = (unsigned __int8)v454[4128 * v67];
          if ( v454[4128 * v67] )
          {
LABEL_78:
            v103 = &s[1032 * v67];
            v104 = 0;
            v105 = 0;
            v106 = v103 + 1026;
            v107 = v103 + 1031;
            v108 = 1;
            do
            {
              v111 = *v107;
              v112 = *v106 + 1048580LL;
              v113 = (unsigned __int8 *)(*v106 + (v99 << 8) + v108);
              v114 = *v113;
              v115 = (unsigned __int8)*(_DWORD *)v112;
              v116 = 256 - v114;
              v117 = (unsigned __int8)-(char)v114;
              if ( 256 - v114 > v115 )
                v118 = -(char)v114;
              else
                v118 = *v113;
              if ( v116 > v115 )
                v117 = 0;
              v119 = v115 - v117 + v118 * (*(_DWORD *)v112 >> 8);
              *(_DWORD *)v112 = v119;
              if ( !HIBYTE(v119) )
              {
                v120 = *(_QWORD *)(v112 + 12);
                v121 = *(_DWORD *)(v112 + 4);
                do
                {
                  *(_DWORD *)(v112 + 4) = v121 + 1;
                  v122 = *(_BYTE *)(v120 + v121++);
                  v119 = v122 | (v119 << 8);
                  *(_DWORD *)v112 = v119;
                }
                while ( !HIBYTE(v119) );
              }
              if ( v116 > v115 )
                v109 = -(v114 >> v111);
              else
                LOBYTE(v109) = v116 >> v111;
              v110 = v109 + v114;
              ++v104;
              v97 = (v116 <= v115) | (2 * v105);
              v108 = (v116 <= v115) | (2 * v108);
              v105 = (v116 <= v115) | (2 * v105);
              *v113 = v110;
            }
            while ( v104 != v101 );
            goto LABEL_73;
          }
        }
        v97 = 0;
LABEL_73:
        v20 = v448;
        v12 = v450;
        v68 = v67 + 1 == v65;
        a2[v67++] = v97;
        if ( v68 )
          goto LABEL_93;
      }
    }
    while ( 1 )
    {
      v69 = &s[1032 * v67];
      v70 = v50 | (*v69 << 8);
      v71 = v70;
      v72 = (char *)v69 + v70;
      v74 = (unsigned __int8)v72[4];
      v73 = v72 + 4;
      if ( v74 )
      {
        v75 = (unsigned __int8)v454[4128 * v67];
        if ( v454[4128 * v67] )
          goto LABEL_58;
      }
      else
      {
        *v73 = 1;
        v76 = (_OWORD *)(*(_QWORD *)&s[1032 * v67 + 1026] + ((__int64)v70 << 8));
        v76[14] = v66;
        v76[15] = v66;
        v76[12] = v66;
        v76[13] = v66;
        v76[10] = v66;
        v76[11] = v66;
        v76[8] = v66;
        v76[9] = v66;
        v76[6] = v66;
        v76[7] = v66;
        v76[4] = v66;
        v76[5] = v66;
        v76[2] = v66;
        v76[3] = v66;
        *v76 = v66;
        v76[1] = v66;
        v75 = (unsigned __int8)v454[4128 * v67];
        if ( v454[4128 * v67] )
        {
LABEL_58:
          v77 = &s[1032 * v67];
          v78 = 0;
          v79 = 0;
          v80 = v77 + 1026;
          v81 = v77 + 1031;
          v82 = 1;
          do
          {
            v85 = *v81;
            v86 = *v80 + 1048580LL;
            v87 = (unsigned __int8 *)(*v80 + (v71 << 8) + v82);
            v88 = *v87;
            v89 = (unsigned __int8)*(_DWORD *)v86;
            v90 = 256 - v88;
            v91 = (unsigned __int8)-(char)v88;
            if ( 256 - v88 > v89 )
              v92 = -(char)v88;
            else
              v92 = *v87;
            if ( v90 > v89 )
              v91 = 0;
            v93 = v89 - v91 + v92 * (*(_DWORD *)v86 >> 8);
            *(_DWORD *)v86 = v93;
            if ( !HIBYTE(v93) )
            {
              v94 = *(_QWORD *)(v86 + 12);
              v95 = *(_DWORD *)(v86 + 4);
              do
              {
                *(_DWORD *)(v86 + 4) = v95 + 1;
                v96 = *(_BYTE *)(v94 + v95++);
                v93 = v96 | (v93 << 8);
                *(_DWORD *)v86 = v93;
              }
              while ( !HIBYTE(v93) );
            }
            if ( v90 > v89 )
              v83 = -(v88 >> v85);
            else
              LOBYTE(v83) = v90 >> v85;
            v84 = v83 + v88;
            ++v78;
            v50 = (v90 <= v89) | (2 * v79);
            v82 = (v90 <= v89) | (2 * v82);
            v79 = (v90 <= v89) | (2 * v79);
            *v87 = v84;
          }
          while ( v78 != v75 );
          goto LABEL_53;
        }
      }
      v50 = 0;
LABEL_53:
      v20 = v448;
      v12 = v450;
      v68 = v67 + 1 == v65;
      a2[v67++] = v50;
      if ( v68 )
        goto LABEL_93;
    }
  }
  LODWORD(v65) = 1;
LABEL_93:
  if ( (unsigned int)v65 < v20[2] )
  {
    v123 = (__int64)ptr;
    *(_QWORD *)&v124 = 0x8080808080808080LL;
    *((_QWORD *)&v124 + 1) = 0x8080808080808080LL;
    v125 = 1;
    n = v41 - 1;
    do
    {
      v126 = (int)(v497[0] << 8) & 0xFFFFFFFFFFFFFF00LL | v30;
      if ( *((_BYTE *)&v497[1] + v126) )
      {
        v451 = v125;
        if ( !(_BYTE)v125 )
          goto LABEL_119;
      }
      else
      {
        *((_BYTE *)&v497[1] + v126) = 1;
        v123 = (__int64)v499;
        v148 = &v499[16 * v126];
        v148[14] = v124;
        v148[15] = v124;
        v148[12] = v124;
        v148[13] = v124;
        v148[10] = v124;
        v148[11] = v124;
        v148[8] = v124;
        v148[9] = v124;
        v148[6] = v124;
        v148[7] = v124;
        v148[4] = v124;
        v148[5] = v124;
        v148[2] = v124;
        v148[3] = v124;
        *v148 = v124;
        v148[1] = v124;
        LOBYTE(v125) = v500;
        v451 = v500;
        if ( !v500 )
        {
LABEL_119:
          v135 = 0;
LABEL_120:
          v149 = (int)(v472[0] << 8);
          if ( *((_BYTE *)&v472[1] + v149) )
          {
            v150 = v474;
            if ( v474 )
            {
LABEL_122:
              v151 = (__int64)v473;
              v152 = v475;
              v153 = 0;
              v154 = 0;
              v155 = (char *)v473 + 1048580;
              v156 = 1;
              do
              {
                v163 = (unsigned __int8 *)(v151 + (v149 << 8) + v156);
                v164 = *v163;
                v165 = (unsigned __int8)*(_DWORD *)v155;
                v166 = 256 - v164;
                v167 = (unsigned __int8)-(char)v164;
                if ( 256 - v164 > v165 )
                  v168 = -(char)v164;
                else
                  v168 = *v163;
                if ( v166 > v165 )
                  v167 = 0;
                v169 = v165 - v167 + v168 * (*(_DWORD *)v155 >> 8);
                *(_DWORD *)v155 = v169;
                if ( !HIBYTE(v169) )
                {
                  v170 = *(_QWORD *)(v155 + 12);
                  v171 = *((_DWORD *)v155 + 1);
                  do
                  {
                    *((_DWORD *)v155 + 1) = v171 + 1;
                    v172 = *(_BYTE *)(v170 + v171++);
                    v169 = v172 | (v169 << 8);
                    *(_DWORD *)v155 = v169;
                  }
                  while ( !HIBYTE(v169) );
                }
                v157 = v166 > v165;
                v158 = v166 >> v152;
                v159 = !v157;
                if ( v157 )
                  v160 = -(v164 >> v152);
                else
                  LOBYTE(v160) = v158;
                v161 = v160 + v164;
                ++v153;
                v162 = v159 & 1 | (2 * v154);
                v156 = v159 & 1 | (2 * v156);
                v154 = v159 & 1 | (2 * v154);
                *v163 = v161;
              }
              while ( v153 != v150 );
LABEL_141:
              v174 = v20[16];
              v175 = v162;
              if ( v174 <= v162 )
              {
                v176 = v162 - v174;
                if ( v162 == v174 )
                  v177 = 1;
                else
                  v177 = v162 - v174;
                v178 = v177 - 15;
                if ( v177 > 15 )
                {
                  v185 = *(_DWORD *)(v6 + 4);
                  v186 = *(_DWORD *)(v6 + 8);
                  v187 = (-1 << v178) ^ 0x1FFFF;
                  v188 = *(_QWORD *)(v6 + 16);
                  v189 = v185 >> v178;
                  *(_DWORD *)(v6 + 4) = v185 >> v178;
                  if ( v185 >> v178 >> 24 )
                  {
                    v190 = v186;
                    v192 = v185 >> v178;
                  }
                  else
                  {
                    do
                    {
                      v190 = v186 + 1;
                      *(_DWORD *)(v6 + 8) = v186 + 1;
                      v191 = *(_BYTE *)(v188 + v186++);
                      v192 = v191 | (v189 << 8);
                      v189 = v192;
                      *(_DWORD *)(v6 + 4) = v192;
                    }
                    while ( !HIBYTE(v192) );
                  }
                  v288 = v185 & v187;
                  v289 = v192 >> 15;
                  *(_DWORD *)(v6 + 4) = v192 >> 15;
                  do
                  {
                    *(_DWORD *)(v6 + 8) = v190 + 1;
                    v290 = *(_BYTE *)(v188 + v190++);
                    v289 = v290 | (v289 << 8);
                    *(_DWORD *)(v6 + 4) = v289;
                  }
                  while ( !HIBYTE(v289) );
                  v180 = v192 & 0x7FFF | (v288 << 15);
                  if ( v176 )
                    goto LABEL_150;
                }
                else
                {
                  v179 = *(_DWORD *)(v6 + 4);
                  v180 = v179 & ~(-1 << v177);
                  v181 = v179 >> v177;
                  *(_DWORD *)(v6 + 4) = v181;
                  if ( !HIBYTE(v181) )
                  {
                    v182 = *(_QWORD *)(v6 + 16);
                    v183 = *(_DWORD *)(v6 + 8);
                    do
                    {
                      *(_DWORD *)(v6 + 8) = v183 + 1;
                      v184 = *(_BYTE *)(v182 + v183++);
                      v181 = v184 | (v181 << 8);
                      *(_DWORD *)(v6 + 4) = v181;
                    }
                    while ( !HIBYTE(v181) );
                  }
                  if ( v176 )
                  {
LABEL_150:
                    v175 = v180 + v174 + (1 << v177);
                    goto LABEL_233;
                  }
                }
                v175 = v180 + v174;
              }
LABEL_233:
              v291 = (int)(v468[0] << 8);
              if ( *((_BYTE *)&v468[1] + v291) )
              {
                v292 = v470;
                if ( v470 )
                {
LABEL_235:
                  v293 = (__int64)v469;
                  v294 = v471;
                  v295 = 0;
                  v296 = 0;
                  v297 = (char *)v469 + 1048580;
                  v298 = 1;
                  do
                  {
                    v305 = (unsigned __int8 *)(v293 + (v291 << 8) + v298);
                    v306 = *v305;
                    v307 = (unsigned __int8)*(_DWORD *)v297;
                    v308 = 256 - v306;
                    v309 = (unsigned __int8)-(char)v306;
                    if ( 256 - v306 > v307 )
                      v310 = -(char)v306;
                    else
                      v310 = *v305;
                    if ( v308 > v307 )
                      v309 = 0;
                    v311 = v307 - v309 + v310 * (*(_DWORD *)v297 >> 8);
                    *(_DWORD *)v297 = v311;
                    if ( !HIBYTE(v311) )
                    {
                      v312 = *(_QWORD *)(v297 + 12);
                      v313 = *((_DWORD *)v297 + 1);
                      do
                      {
                        *((_DWORD *)v297 + 1) = v313 + 1;
                        v314 = *(_BYTE *)(v312 + v313++);
                        v311 = v314 | (v311 << 8);
                        *(_DWORD *)v297 = v311;
                      }
                      while ( !HIBYTE(v311) );
                    }
                    v299 = v308 > v307;
                    v300 = v308 >> v294;
                    v301 = !v299;
                    if ( v299 )
                      v302 = -(v306 >> v294);
                    else
                      LOBYTE(v302) = v300;
                    v303 = v302 + v306;
                    ++v295;
                    v304 = v301 & 1 | (2 * v296);
                    v298 = v301 & 1 | (2 * v298);
                    v296 = v301 & 1 | (2 * v296);
                    *v305 = v303;
                  }
                  while ( v295 != v292 );
                  if ( v304 )
                    v315 = v304;
                  else
                    v315 = 1;
                  v316 = v304 == 0;
                  v317 = v315 - 15;
                  if ( v315 > 0xFu )
                  {
                    v318 = *(_DWORD *)(v6 + 4);
                    v319 = *(_DWORD *)(v6 + 8);
                    v320 = (-1 << v317) ^ 0x1FFFF;
                    v321 = *(_QWORD *)(v6 + 16);
                    v322 = v318 >> v317;
                    *(_DWORD *)(v6 + 4) = v318 >> v317;
                    if ( v318 >> v317 >> 24 )
                    {
                      v323 = v319;
                      v325 = v318 >> v317;
                    }
                    else
                    {
                      do
                      {
                        v323 = v319 + 1;
                        *(_DWORD *)(v6 + 8) = v319 + 1;
                        v324 = *(_BYTE *)(v321 + v319++);
                        v325 = v324 | (v322 << 8);
                        v322 = v325;
                        *(_DWORD *)(v6 + 4) = v325;
                      }
                      while ( !HIBYTE(v325) );
                    }
                    v333 = v318 & v320;
                    v334 = v325 >> 15;
                    *(_DWORD *)(v6 + 4) = v325 >> 15;
                    do
                    {
                      *(_DWORD *)(v6 + 8) = v323 + 1;
                      v335 = *(_BYTE *)(v321 + v323++);
                      v334 = v335 | (v334 << 8);
                      *(_DWORD *)(v6 + 4) = v334;
                    }
                    while ( !HIBYTE(v334) );
                    v328 = v325 & 0x7FFF | (v333 << 15);
                    goto LABEL_269;
                  }
LABEL_261:
                  v327 = *(_DWORD *)(v6 + 4);
                  v328 = v327 & ~(-1 << v315);
                  v329 = v327 >> v315;
                  *(_DWORD *)(v6 + 4) = v329;
                  if ( !HIBYTE(v329) )
                  {
                    v330 = *(_QWORD *)(v6 + 16);
                    v331 = *(_DWORD *)(v6 + 8);
                    do
                    {
                      *(_DWORD *)(v6 + 8) = v331 + 1;
                      v332 = *(_BYTE *)(v330 + v331++);
                      v329 = v332 | (v329 << 8);
                      *(_DWORD *)(v6 + 4) = v329;
                    }
                    while ( !HIBYTE(v329) );
                  }
LABEL_269:
                  v336 = 1 << v315;
                  if ( v316 )
                    v337 = 1;
                  else
                    v337 = v336 + 1;
                  v338 = (v337 + v328) * v41;
                  v339 = (char *)&a2[(int)v65];
                  v340 = (v20[3] + v175) * v41;
                  v341 = &v339[-v338];
                  if ( v338 > (int)v340 )
                  {
                    memcpy(v339, v341, v340);
                    v20 = v448;
                    *(_QWORD *)&v124 = 0x8080808080808080LL;
                    *((_QWORD *)&v124 + 1) = 0x8080808080808080LL;
                  }
                  else if ( (int)v340 >= 1 )
                  {
                    v342 = -(__int64)v338;
                    if ( v340 < 0x20
                      || v339 < (char *)&a2[(int)v65 + (unsigned __int64)v340 - v338]
                      && v341 < (char *)&a2[(int)v65 + (unsigned __int64)v340] )
                    {
                      v343 = 0LL;
                      goto LABEL_278;
                    }
                    v343 = v340 & 0xFFFFFFE0;
                    v346 = v343;
                    v347 = &a2[(int)v65 + 16];
                    do
                    {
                      v348 = *(_OWORD *)&v347[-v338];
                      v346 -= 32LL;
                      *((_OWORD *)v347 - 1) = *(_OWORD *)&v347[-v338 - 16];
                      *(_OWORD *)v347 = v348;
                      v347 += 32;
                    }
                    while ( v346 );
                    if ( v343 != v340 )
                    {
LABEL_278:
                      v344 = v340 - v343;
                      v345 = &a2[v343 + (int)v65];
                      do
                      {
                        --v344;
                        *v345 = v345[v342];
                        ++v345;
                      }
                      while ( v344 );
                    }
                  }
                  LODWORD(v65) = v340 + v65;
                  v12 = v450;
                  goto LABEL_97;
                }
              }
              else
              {
                *(_BYTE *)(((unsigned __int64)v468 + v291) | 4) = 1;
                v326 = &v469[16 * v291];
                v326[14] = v124;
                v326[15] = v124;
                v326[12] = v124;
                v326[13] = v124;
                v326[10] = v124;
                v326[11] = v124;
                v326[8] = v124;
                v326[9] = v124;
                v326[6] = v124;
                v326[7] = v124;
                v326[4] = v124;
                v326[5] = v124;
                v326[2] = v124;
                v326[3] = v124;
                *v326 = v124;
                v326[1] = v124;
                v292 = v470;
                if ( v470 )
                  goto LABEL_235;
              }
              v315 = 1;
              v316 = 1;
              goto LABEL_261;
            }
          }
          else
          {
            *(_BYTE *)(((unsigned __int64)v472 + v149) | 4) = 1;
            v173 = &v473[16 * v149];
            v173[14] = v124;
            v173[15] = v124;
            v173[12] = v124;
            v173[13] = v124;
            v173[10] = v124;
            v173[11] = v124;
            v173[8] = v124;
            v173[9] = v124;
            v173[6] = v124;
            v173[7] = v124;
            v173[4] = v124;
            v173[5] = v124;
            v173[2] = v124;
            v173[3] = v124;
            *v173 = v124;
            v173[1] = v124;
            v150 = v474;
            if ( v474 )
              goto LABEL_122;
          }
          v162 = 0;
          goto LABEL_141;
        }
      }
      v127 = v501;
      v128 = 0;
      v129 = 0;
      v130 = (unsigned int *)(v123 + 1048580);
      v131 = 1;
      do
      {
        v136 = (unsigned __int8 *)(v123 + (v126 << 8) + v131);
        v137 = *v136;
        v138 = (unsigned __int8)*v130;
        v139 = 256 - v137;
        v140 = (unsigned __int8)-(char)v137;
        if ( 256 - v137 > v138 )
          v141 = -(char)v137;
        else
          v141 = *v136;
        if ( v139 > v138 )
          v140 = 0;
        v142 = v138 - v140 + v141 * (*v130 >> 8);
        *v130 = v142;
        if ( !HIBYTE(v142) )
        {
          v143 = *(_QWORD *)(v123 + 1048592);
          v144 = *(_DWORD *)(v123 + 1048584);
          do
          {
            *(_DWORD *)(v123 + 1048584) = v144 + 1;
            v145 = *(_BYTE *)(v143 + v144++);
            v142 = v145 | (v142 << 8);
            *v130 = v142;
          }
          while ( !HIBYTE(v142) );
        }
        v24 = v139 > v138;
        v132 = v139 <= v138;
        v133 = v139 >> v127;
        ++v128;
        if ( v24 )
          v134 = -(v137 >> v127);
        else
          LOBYTE(v134) = v133;
        v135 = v132 | (2 * v129);
        v131 = v132 | (2 * v131);
        v129 = v132 | (2 * v129);
        *v136 = v134 + v137;
      }
      while ( v128 != (unsigned __int8)v125 );
      if ( v135 != 1 )
        goto LABEL_120;
      v146 = (int)(v492[0] << 8) & 0xFFFFFFFFFFFFFF00LL | v30;
      if ( *((_BYTE *)&v492[1] + v146) )
      {
        v147 = v495;
        if ( !v495 )
          goto LABEL_176;
      }
      else
      {
        *((_BYTE *)&v492[1] + v146) = 1;
        v193 = &v494[16 * v146];
        v193[14] = v124;
        v193[15] = v124;
        v193[12] = v124;
        v193[13] = v124;
        v193[10] = v124;
        v193[11] = v124;
        v193[8] = v124;
        v193[9] = v124;
        v193[6] = v124;
        v193[7] = v124;
        v193[4] = v124;
        v193[5] = v124;
        v193[2] = v124;
        v193[3] = v124;
        *v193 = v124;
        v193[1] = v124;
        v147 = v495;
        if ( !v495 )
          goto LABEL_176;
      }
      v194 = (__int64)v494;
      v195 = v496;
      v196 = 0;
      v197 = 0;
      v198 = (char *)v494 + 1048580;
      v199 = 1;
      do
      {
        v206 = (unsigned __int8 *)(v194 + (v146 << 8) + v199);
        v207 = *v206;
        v208 = (unsigned __int8)*(_DWORD *)v198;
        v209 = 256 - v207;
        v210 = (unsigned __int8)-(char)v207;
        if ( 256 - v207 > v208 )
          v211 = -(char)v207;
        else
          v211 = *v206;
        if ( v209 > v208 )
          v210 = 0;
        v212 = v208 - v210 + v211 * (*(_DWORD *)v198 >> 8);
        *(_DWORD *)v198 = v212;
        if ( !HIBYTE(v212) )
        {
          v213 = *(_QWORD *)(v198 + 12);
          v214 = *((_DWORD *)v198 + 1);
          do
          {
            *((_DWORD *)v198 + 1) = v214 + 1;
            v215 = *(_BYTE *)(v213 + v214++);
            v212 = v215 | (v212 << 8);
            *(_DWORD *)v198 = v212;
          }
          while ( !HIBYTE(v212) );
        }
        v200 = v209 > v208;
        v201 = v209 >> v195;
        v202 = !v200;
        if ( v200 )
          v203 = -(v207 >> v195);
        else
          LOBYTE(v203) = v201;
        v204 = v203 + v207;
        ++v196;
        v205 = v202 & 1 | (2 * v197);
        v199 = v202 & 1 | (2 * v199);
        v197 = v202 & 1 | (2 * v197);
        *v206 = v204;
      }
      while ( v196 != v147 );
      if ( !v205 )
      {
LABEL_176:
        v219 = (int)v65;
        v220 = v41;
        if ( (v12 & 2) == 0 )
        {
          while ( 1 )
          {
            v222 = 0;
            if ( v12 && v220 < v41 )
              v222 = a2[v219 - 1];
            v223 = v41 - v220;
            v224 = &s[1032 * (v41 - v220)];
            v225 = v222 | (*v224 << 8);
            v226 = (char *)v224 + v225;
            v228 = (unsigned __int8)v226[4];
            v227 = v226 + 4;
            if ( v228 )
            {
              v229 = (unsigned __int8)v454[4128 * v223];
              if ( v454[4128 * v223] )
                goto LABEL_187;
            }
            else
            {
              *v227 = 1;
              v230 = (_OWORD *)(*(_QWORD *)&s[1032 * v223 + 1026] + (v225 << 8));
              v230[14] = v124;
              v230[15] = v124;
              v230[12] = v124;
              v230[13] = v124;
              v230[10] = v124;
              v230[11] = v124;
              v230[8] = v124;
              v230[9] = v124;
              v230[6] = v124;
              v230[7] = v124;
              v230[4] = v124;
              v230[5] = v124;
              v230[2] = v124;
              v230[3] = v124;
              *v230 = v124;
              v230[1] = v124;
              v229 = (unsigned __int8)v454[4128 * v223];
              if ( v454[4128 * v223] )
              {
LABEL_187:
                v231 = &s[1032 * v223];
                v232 = 0;
                v233 = 0;
                v234 = v231 + 1026;
                v235 = v231 + 1031;
                v236 = 1;
                do
                {
                  v242 = *v235;
                  v243 = *v234 + 1048580LL;
                  v244 = (unsigned __int8 *)(*v234 + (v225 << 8) + v236);
                  v245 = *v244;
                  v246 = (unsigned __int8)*(_DWORD *)v243;
                  v247 = 256 - v245;
                  v248 = (unsigned __int8)-(char)v245;
                  if ( 256 - v245 > v246 )
                    v249 = -(char)v245;
                  else
                    v249 = *v244;
                  if ( v247 > v246 )
                    v248 = 0;
                  v250 = v246 - v248 + v249 * (*(_DWORD *)v243 >> 8);
                  *(_DWORD *)v243 = v250;
                  if ( !HIBYTE(v250) )
                  {
                    v251 = *(_QWORD *)(v243 + 12);
                    v252 = *(_DWORD *)(v243 + 4);
                    do
                    {
                      *(_DWORD *)(v243 + 4) = v252 + 1;
                      v253 = *(_BYTE *)(v251 + v252++);
                      v250 = v253 | (v250 << 8);
                      *(_DWORD *)v243 = v250;
                    }
                    while ( !HIBYTE(v250) );
                  }
                  v24 = v247 > v246;
                  v237 = v245 >> v242;
                  v238 = v247 >> v242;
                  v239 = v247 <= v246;
                  if ( v24 )
                    v240 = -v237;
                  else
                    LOBYTE(v240) = v238;
                  v241 = v240 + v245;
                  ++v232;
                  v221 = v239 | (2 * v233);
                  v236 = v239 | (2 * v236);
                  v233 = v239 | (2 * v233);
                  *v244 = v241;
                }
                while ( v232 != v229 );
                goto LABEL_179;
              }
            }
            v221 = 0;
LABEL_179:
            LODWORD(v65) = v219 + 1;
            --v220;
            a2[v219++] = v221;
            if ( !(_DWORD)v220 )
              goto LABEL_227;
          }
        }
        while ( 2 )
        {
          if ( (_DWORD)v41 == (_DWORD)v220 )
          {
            v255 = v219 - v41;
            goto LABEL_208;
          }
          v256 = 0;
          if ( v12 && v220 < v41 )
          {
            v255 = v219 - 1;
LABEL_208:
            v256 = a2[v255];
          }
          v257 = v41 - v220;
          v258 = &s[1032 * (v41 - v220)];
          v259 = v256 | (*v258 << 8);
          v260 = (char *)v258 + v259;
          v262 = (unsigned __int8)v260[4];
          v261 = v260 + 4;
          if ( v262 )
          {
            v263 = (unsigned __int8)v454[4128 * v257];
            if ( !v454[4128 * v257] )
            {
LABEL_201:
              v254 = 0;
              goto LABEL_202;
            }
          }
          else
          {
            *v261 = 1;
            v264 = (_OWORD *)(*(_QWORD *)&s[1032 * v257 + 1026] + (v259 << 8));
            v264[14] = v124;
            v264[15] = v124;
            v264[12] = v124;
            v264[13] = v124;
            v264[10] = v124;
            v264[11] = v124;
            v264[8] = v124;
            v264[9] = v124;
            v264[6] = v124;
            v264[7] = v124;
            v264[4] = v124;
            v264[5] = v124;
            v264[2] = v124;
            v264[3] = v124;
            *v264 = v124;
            v264[1] = v124;
            v263 = (unsigned __int8)v454[4128 * v257];
            if ( !v454[4128 * v257] )
              goto LABEL_201;
          }
          v265 = &s[1032 * v257];
          v266 = 0;
          v267 = 0;
          v268 = v265 + 1026;
          v269 = v265 + 1031;
          v270 = 1;
          do
          {
            v276 = *v269;
            v277 = *v268 + 1048580LL;
            v278 = (unsigned __int8 *)(*v268 + (v259 << 8) + v270);
            v279 = *v278;
            v280 = (unsigned __int8)*(_DWORD *)v277;
            v281 = 256 - v279;
            v282 = (unsigned __int8)-(char)v279;
            if ( 256 - v279 > v280 )
              v283 = -(char)v279;
            else
              v283 = *v278;
            if ( v281 > v280 )
              v282 = 0;
            v284 = v280 - v282 + v283 * (*(_DWORD *)v277 >> 8);
            *(_DWORD *)v277 = v284;
            if ( !HIBYTE(v284) )
            {
              v285 = *(_QWORD *)(v277 + 12);
              v286 = *(_DWORD *)(v277 + 4);
              do
              {
                *(_DWORD *)(v277 + 4) = v286 + 1;
                v287 = *(_BYTE *)(v285 + v286++);
                v284 = v287 | (v284 << 8);
                *(_DWORD *)v277 = v284;
              }
              while ( !HIBYTE(v284) );
            }
            v24 = v281 > v280;
            v271 = v279 >> v276;
            v272 = v281 >> v276;
            v273 = v281 <= v280;
            if ( v24 )
              v274 = -v271;
            else
              LOBYTE(v274) = v272;
            v275 = v274 + v279;
            ++v266;
            v254 = v273 | (2 * v267);
            v270 = v273 | (2 * v270);
            v267 = v273 | (2 * v267);
            *v278 = v275;
          }
          while ( v266 != v263 );
LABEL_202:
          LODWORD(v65) = v219 + 1;
          --v220;
          a2[v219++] = v254;
          if ( !(_DWORD)v220 )
          {
LABEL_227:
            v135 = 1;
            goto LABEL_97;
          }
          continue;
        }
      }
      v216 = (int)(v488[0] << 8);
      if ( *((_BYTE *)&v488[1] + v216) )
      {
        v217 = &a2[-v41];
        v218 = v490;
        if ( !v490 )
          goto LABEL_324;
      }
      else
      {
        *(_BYTE *)(((unsigned __int64)v488 + v216) | 4) = 1;
        v349 = &v489[16 * v216];
        v349[14] = v124;
        v349[15] = v124;
        v349[12] = v124;
        v349[13] = v124;
        v349[10] = v124;
        v349[11] = v124;
        v349[8] = v124;
        v349[9] = v124;
        v349[6] = v124;
        v349[7] = v124;
        v349[4] = v124;
        v349[5] = v124;
        v349[2] = v124;
        v349[3] = v124;
        *v349 = v124;
        v349[1] = v124;
        v217 = &a2[-v41];
        v218 = v490;
        if ( !v490 )
          goto LABEL_324;
      }
      v350 = (__int64)v489;
      v351 = v491;
      v352 = 0;
      v353 = 0;
      v354 = (char *)v489 + 1048580;
      v355 = 1;
      do
      {
        v362 = (unsigned __int8 *)(v350 + (v216 << 8) + v355);
        v363 = *v362;
        v364 = (unsigned __int8)*(_DWORD *)v354;
        v365 = 256 - v363;
        v366 = (unsigned __int8)-(char)v363;
        if ( 256 - v363 > v364 )
          v367 = -(char)v363;
        else
          v367 = *v362;
        if ( v365 > v364 )
          v366 = 0;
        v368 = v364 - v366 + v367 * (*(_DWORD *)v354 >> 8);
        *(_DWORD *)v354 = v368;
        if ( !HIBYTE(v368) )
        {
          v369 = *(_QWORD *)(v354 + 12);
          v370 = *((_DWORD *)v354 + 1);
          do
          {
            *((_DWORD *)v354 + 1) = v370 + 1;
            v371 = *(_BYTE *)(v369 + v370++);
            v368 = v371 | (v368 << 8);
            *(_DWORD *)v354 = v368;
          }
          while ( !HIBYTE(v368) );
        }
        v356 = v365 > v364;
        v357 = v365 >> v351;
        v358 = !v356;
        if ( v356 )
          v359 = -(v363 >> v351);
        else
          LOBYTE(v359) = v357;
        v360 = v359 + v363;
        ++v352;
        v361 = v358 & 1 | (2 * v353);
        v355 = v358 & 1 | (2 * v355);
        v353 = v358 & 1 | (2 * v353);
        *v362 = v360;
      }
      while ( v352 != v218 );
      if ( v361 != 1 )
      {
LABEL_324:
        v394 = v65 - v41;
        goto LABEL_325;
      }
      v372 = (int)(v484[0] << 8);
      if ( !*((_BYTE *)&v484[1] + v372) )
      {
        *(_BYTE *)(((unsigned __int64)v484 + v372) | 4) = 1;
        v373 = &v485[16 * v372];
        v373[14] = v124;
        v373[15] = v124;
        v373[12] = v124;
        v373[13] = v124;
        v373[10] = v124;
        v373[11] = v124;
        v373[8] = v124;
        v373[9] = v124;
        v373[6] = v124;
        v373[7] = v124;
        v373[4] = v124;
        v373[5] = v124;
        v373[2] = v124;
        v373[3] = v124;
        *v373 = v124;
        v373[1] = v124;
      }
      v374 = v486;
      if ( v486 )
      {
        v375 = (__int64)v485;
        v376 = v487;
        v377 = 0;
        v378 = 1;
        v379 = (char *)v485 + 1048580;
        do
        {
          v384 = (unsigned __int8 *)(v375 + (v372 << 8) + v378);
          v385 = *v384;
          v386 = (unsigned __int8)*(_DWORD *)v379;
          v387 = 256 - v385;
          v388 = (unsigned __int8)-(char)v385;
          if ( 256 - v385 > v386 )
            v389 = -(char)v385;
          else
            v389 = *v384;
          if ( v387 > v386 )
            v388 = 0;
          v390 = v386 - v388 + v389 * (*(_DWORD *)v379 >> 8);
          *(_DWORD *)v379 = v390;
          if ( !HIBYTE(v390) )
          {
            v391 = *(_QWORD *)(v379 + 12);
            v392 = *((_DWORD *)v379 + 1);
            do
            {
              *((_DWORD *)v379 + 1) = v392 + 1;
              v393 = *(_BYTE *)(v391 + v392++);
              v390 = v393 | (v390 << 8);
              *(_DWORD *)v379 = v390;
            }
            while ( !HIBYTE(v390) );
          }
          v380 = v387 > v386;
          v381 = v387 >> v376;
          v382 = !v380;
          ++v377;
          if ( v380 )
            v383 = -(v385 >> v376);
          else
            LOBYTE(v383) = v381;
          v378 = v382 & 1 | (2 * v378);
          *v384 = v383 + v385;
        }
        while ( v377 != v374 );
      }
      v421 = (int)(v480[0] << 8);
      if ( !*((_BYTE *)&v480[1] + v421) )
      {
        *(_BYTE *)(((unsigned __int64)v480 + v421) | 4) = 1;
        v422 = &v481[16 * v421];
        v422[14] = v124;
        v422[15] = v124;
        v422[12] = v124;
        v422[13] = v124;
        v422[10] = v124;
        v422[11] = v124;
        v422[8] = v124;
        v422[9] = v124;
        v422[6] = v124;
        v422[7] = v124;
        v422[4] = v124;
        v422[5] = v124;
        v422[2] = v124;
        v422[3] = v124;
        *v422 = v124;
        v422[1] = v124;
      }
      v423 = v482;
      if ( v482 )
      {
        v424 = (__int64)v481;
        v425 = v483;
        v426 = 0;
        v427 = 1;
        v428 = (char *)v481 + 1048580;
        do
        {
          v433 = (unsigned __int8 *)(v424 + (v421 << 8) + v427);
          v434 = *v433;
          v435 = (unsigned __int8)*(_DWORD *)v428;
          v436 = 256 - v434;
          v437 = (unsigned __int8)-(char)v434;
          if ( 256 - v434 > v435 )
            v438 = -(char)v434;
          else
            v438 = *v433;
          if ( v436 > v435 )
            v437 = 0;
          v439 = v435 - v437 + v438 * (*(_DWORD *)v428 >> 8);
          *(_DWORD *)v428 = v439;
          if ( !HIBYTE(v439) )
          {
            v440 = *(_QWORD *)(v428 + 12);
            v441 = *((_DWORD *)v428 + 1);
            do
            {
              *((_DWORD *)v428 + 1) = v441 + 1;
              v442 = *(_BYTE *)(v440 + v441++);
              v439 = v442 | (v439 << 8);
              *(_DWORD *)v428 = v439;
            }
            while ( !HIBYTE(v439) );
          }
          v429 = v436 > v435;
          v430 = v436 >> v425;
          v431 = !v429;
          ++v426;
          if ( v429 )
            v432 = -(v434 >> v425);
          else
            LOBYTE(v432) = v430;
          v427 = v431 & 1 | (2 * v427);
          *v433 = v432 + v434;
        }
        while ( v426 != v423 );
      }
      v443 = -2 * v41 + v65;
      do
      {
        v394 = v443;
        if ( (v443 & 0x80000000) != 0 )
          break;
        v443 -= v41;
      }
      while ( a2[v394] == v217[(int)v65] );
LABEL_325:
      v445 = (int)v65;
      memcpy(&a2[(int)v65], &a2[v394], n);
      *(_QWORD *)&v124 = 0x8080808080808080LL;
      *((_QWORD *)&v124 + 1) = 0x8080808080808080LL;
      v395 = (int)(v476[0] << 8);
      v396 = a2[n + v394];
      if ( *((_BYTE *)&v476[1] + v395) )
      {
        v20 = v448;
        v397 = v478;
        if ( !v478 )
          goto LABEL_345;
      }
      else
      {
        *(_BYTE *)(((unsigned __int64)v476 + v395) | 4) = 1;
        v420 = &v477[16 * v395];
        v420[14] = v124;
        v420[15] = v124;
        v420[12] = v124;
        v420[13] = v124;
        v420[10] = v124;
        v420[11] = v124;
        v420[8] = v124;
        v420[9] = v124;
        v420[6] = v124;
        v420[7] = v124;
        v420[4] = v124;
        v420[5] = v124;
        v420[2] = v124;
        v420[3] = v124;
        *v420 = v124;
        v420[1] = v124;
        v20 = v448;
        v397 = v478;
        if ( !v478 )
        {
LABEL_345:
          v409 = 0;
          goto LABEL_346;
        }
      }
      v398 = (__int64)v477;
      v399 = v479;
      v400 = 0;
      v401 = 0;
      v402 = (char *)v477 + 1048580;
      v403 = 1;
      do
      {
        v410 = (unsigned __int8 *)(v398 + (v395 << 8) + v403);
        v411 = *v410;
        v412 = (unsigned __int8)*(_DWORD *)v402;
        v413 = 256 - v411;
        v414 = (unsigned __int8)-(char)v411;
        if ( 256 - v411 > v412 )
          v415 = -(char)v411;
        else
          v415 = *v410;
        if ( v413 > v412 )
          v414 = 0;
        v416 = v412 - v414 + v415 * (*(_DWORD *)v402 >> 8);
        *(_DWORD *)v402 = v416;
        if ( !HIBYTE(v416) )
        {
          v417 = *(_QWORD *)(v402 + 12);
          v418 = *((_DWORD *)v402 + 1);
          do
          {
            *((_DWORD *)v402 + 1) = v418 + 1;
            v419 = *(_BYTE *)(v417 + v418++);
            v416 = v419 | (v416 << 8);
            *(_DWORD *)v402 = v416;
          }
          while ( !HIBYTE(v416) );
        }
        v404 = v413 > v412;
        v405 = v413 >> v399;
        v406 = !v404;
        if ( v404 )
          v407 = -(v411 >> v399);
        else
          LOBYTE(v407) = v405;
        v408 = v407 + v411;
        ++v400;
        v409 = v406 & 1 | (2 * v401);
        v403 = v406 & 1 | (2 * v403);
        v401 = v406 & 1 | (2 * v401);
        *v410 = v408;
      }
      while ( v400 != v397 );
LABEL_346:
      v135 = 1;
      LODWORD(v65) = v65 + v41;
      a2[v445 - 1 + v41] = v409 + v396;
LABEL_97:
      v125 = v451;
      v30 = v135;
    }
    while ( (unsigned int)v65 < v20[2] );
  }
  free(ptr);
}
// 18890: using guessed type __int64 __fastcall __wrap_malloc(_QWORD);

//----- (0000000000013E44) ----------------------------------------------------
__int64 __fastcall sub_13E44(unsigned __int8 *a1, unsigned __int8 *a2)
{
  _DWORD v4[32]; // [xsp+0h] [xbp-90h] BYREF

  sub_13E74(a1, (__int64)v4);
  sub_12364((__int64)v4, a2);
  return v4[2];
}

//----- (0000000000013E74) ----------------------------------------------------
__int64 __fastcall sub_13E74(unsigned __int8 *a1, __int64 a2)
{
  int v2; // w8
  __int64 v3; // x9
  unsigned __int8 *v4; // x10
  int v5; // w8
  unsigned __int8 *v6; // x10
  int v7; // w8
  unsigned __int8 *v8; // x10
  int v9; // w8
  unsigned __int8 *v10; // x10
  int v11; // w8
  unsigned __int8 *v12; // x10
  int v13; // w8
  unsigned __int8 *v14; // x10
  int v15; // w8
  unsigned __int8 *v16; // x10
  int v17; // w8
  unsigned __int8 *v18; // x10
  int v19; // w8
  unsigned __int8 *v20; // x10
  int v21; // w8
  unsigned __int8 *v22; // x10
  int v23; // w8
  unsigned __int8 *v24; // x10
  int v25; // w8
  unsigned __int8 *v26; // x10
  int v27; // w8
  unsigned __int8 *v28; // x10
  int v29; // w8
  unsigned __int8 *v30; // x10
  int v31; // w8
  unsigned __int8 *v32; // x10
  int v33; // w8
  unsigned __int8 *v34; // x10
  int v35; // w8
  unsigned __int8 *v36; // x10
  int v37; // w8
  unsigned __int8 *v38; // x10
  int v39; // w8
  unsigned __int8 *v40; // x10
  int v41; // w8
  __int64 v42; // x8
  unsigned __int8 *v43; // x11
  int v44; // w10
  unsigned __int8 *v45; // x10
  int v46; // w9
  unsigned __int8 *v47; // x10
  int v48; // w9
  unsigned __int8 *v49; // x10
  int v50; // w9
  unsigned __int8 *v51; // x10
  int v52; // w9
  unsigned __int8 *v53; // x10
  int v54; // w9
  unsigned __int8 *v55; // x10
  int v56; // w9
  unsigned __int8 *v57; // x10
  int v58; // w9
  unsigned __int8 *v59; // x9
  __int64 result; // x0

  v2 = *a1;
  if ( ((char)*a1 & 0x80000000) != 0 )
  {
    switch ( v2 )
    {
      case 252:
        v2 = *(_DWORD *)(a1 + 1);
        v3 = 9LL;
        break;
      case 253:
        v2 = *(_DWORD *)(a1 + 1);
        v3 = 5LL;
        break;
      case 254:
        v2 = *(unsigned __int16 *)(a1 + 1);
        v3 = 3LL;
        break;
      default:
        v3 = 0LL;
        v2 = 0;
        break;
    }
  }
  else
  {
    v3 = 1LL;
  }
  *(_DWORD *)a2 = v2;
  v4 = &a1[v3];
  v5 = a1[v3];
  if ( ((char)a1[v3] & 0x80000000) != 0 )
  {
    switch ( v5 )
    {
      case 252:
        v5 = *(_DWORD *)(v4 + 1);
        v3 = (unsigned int)(v3 + 9);
        break;
      case 253:
        v5 = *(_DWORD *)(v4 + 1);
        v3 = (unsigned int)(v3 + 5);
        break;
      case 254:
        v5 = *(unsigned __int16 *)(v4 + 1);
        v3 = (unsigned int)(v3 + 3);
        break;
      default:
        v5 = 0;
        break;
    }
  }
  else
  {
    v3 = (unsigned int)(v3 + 1);
  }
  *(_DWORD *)(a2 + 4) = v5;
  v6 = &a1[v3];
  v7 = a1[v3];
  if ( ((char)a1[v3] & 0x80000000) != 0 )
  {
    switch ( v7 )
    {
      case 252:
        v7 = *(_DWORD *)(v6 + 1);
        v3 = (unsigned int)(v3 + 9);
        break;
      case 253:
        v7 = *(_DWORD *)(v6 + 1);
        v3 = (unsigned int)(v3 + 5);
        break;
      case 254:
        v7 = *(unsigned __int16 *)(v6 + 1);
        v3 = (unsigned int)(v3 + 3);
        break;
      default:
        v7 = 0;
        break;
    }
  }
  else
  {
    v3 = (unsigned int)(v3 + 1);
  }
  *(_DWORD *)(a2 + 8) = v7;
  v8 = &a1[v3];
  v9 = a1[v3];
  if ( ((char)a1[v3] & 0x80000000) != 0 )
  {
    switch ( v9 )
    {
      case 252:
        v9 = *(_DWORD *)(v8 + 1);
        v3 = (unsigned int)(v3 + 9);
        break;
      case 253:
        v9 = *(_DWORD *)(v8 + 1);
        v3 = (unsigned int)(v3 + 5);
        break;
      case 254:
        v9 = *(unsigned __int16 *)(v8 + 1);
        v3 = (unsigned int)(v3 + 3);
        break;
      default:
        v9 = 0;
        break;
    }
  }
  else
  {
    v3 = (unsigned int)(v3 + 1);
  }
  *(_DWORD *)(a2 + 12) = v9;
  v10 = &a1[v3];
  v11 = a1[v3];
  if ( ((char)a1[v3] & 0x80000000) != 0 )
  {
    switch ( v11 )
    {
      case 252:
        v11 = *(_DWORD *)(v10 + 1);
        v3 = (unsigned int)(v3 + 9);
        break;
      case 253:
        v11 = *(_DWORD *)(v10 + 1);
        v3 = (unsigned int)(v3 + 5);
        break;
      case 254:
        v11 = *(unsigned __int16 *)(v10 + 1);
        v3 = (unsigned int)(v3 + 3);
        break;
      default:
        v11 = 0;
        break;
    }
  }
  else
  {
    v3 = (unsigned int)(v3 + 1);
  }
  *(_DWORD *)(a2 + 16) = v11;
  v12 = &a1[v3];
  v13 = a1[v3];
  if ( ((char)a1[v3] & 0x80000000) != 0 )
  {
    switch ( v13 )
    {
      case 252:
        v13 = *(_DWORD *)(v12 + 1);
        v3 = (unsigned int)(v3 + 9);
        break;
      case 253:
        v13 = *(_DWORD *)(v12 + 1);
        v3 = (unsigned int)(v3 + 5);
        break;
      case 254:
        v13 = *(unsigned __int16 *)(v12 + 1);
        v3 = (unsigned int)(v3 + 3);
        break;
      default:
        v13 = 0;
        break;
    }
  }
  else
  {
    v3 = (unsigned int)(v3 + 1);
  }
  *(_DWORD *)(a2 + 20) = v13;
  v14 = &a1[v3];
  v15 = a1[v3];
  if ( ((char)a1[v3] & 0x80000000) != 0 )
  {
    switch ( v15 )
    {
      case 252:
        v15 = *(_DWORD *)(v14 + 1);
        v3 = (unsigned int)(v3 + 9);
        break;
      case 253:
        v15 = *(_DWORD *)(v14 + 1);
        v3 = (unsigned int)(v3 + 5);
        break;
      case 254:
        v15 = *(unsigned __int16 *)(v14 + 1);
        v3 = (unsigned int)(v3 + 3);
        break;
      default:
        v15 = 0;
        break;
    }
  }
  else
  {
    v3 = (unsigned int)(v3 + 1);
  }
  *(_DWORD *)(a2 + 24) = v15;
  v16 = &a1[v3];
  v17 = a1[v3];
  if ( ((char)a1[v3] & 0x80000000) != 0 )
  {
    switch ( v17 )
    {
      case 252:
        v17 = *(_DWORD *)(v16 + 1);
        v3 = (unsigned int)(v3 + 9);
        break;
      case 253:
        v17 = *(_DWORD *)(v16 + 1);
        v3 = (unsigned int)(v3 + 5);
        break;
      case 254:
        v17 = *(unsigned __int16 *)(v16 + 1);
        v3 = (unsigned int)(v3 + 3);
        break;
      default:
        v17 = 0;
        break;
    }
  }
  else
  {
    v3 = (unsigned int)(v3 + 1);
  }
  *(_DWORD *)(a2 + 28) = v17;
  v18 = &a1[v3];
  v19 = a1[v3];
  if ( ((char)a1[v3] & 0x80000000) != 0 )
  {
    switch ( v19 )
    {
      case 252:
        v19 = *(_DWORD *)(v18 + 1);
        v3 = (unsigned int)(v3 + 9);
        break;
      case 253:
        v19 = *(_DWORD *)(v18 + 1);
        v3 = (unsigned int)(v3 + 5);
        break;
      case 254:
        v19 = *(unsigned __int16 *)(v18 + 1);
        v3 = (unsigned int)(v3 + 3);
        break;
      default:
        v19 = 0;
        break;
    }
  }
  else
  {
    v3 = (unsigned int)(v3 + 1);
  }
  *(_DWORD *)(a2 + 32) = v19;
  v20 = &a1[v3];
  v21 = a1[v3];
  if ( ((char)a1[v3] & 0x80000000) != 0 )
  {
    switch ( v21 )
    {
      case 252:
        v21 = *(_DWORD *)(v20 + 1);
        v3 = (unsigned int)(v3 + 9);
        break;
      case 253:
        v21 = *(_DWORD *)(v20 + 1);
        v3 = (unsigned int)(v3 + 5);
        break;
      case 254:
        v21 = *(unsigned __int16 *)(v20 + 1);
        v3 = (unsigned int)(v3 + 3);
        break;
      default:
        v21 = 0;
        break;
    }
  }
  else
  {
    v3 = (unsigned int)(v3 + 1);
  }
  *(_DWORD *)(a2 + 36) = v21;
  v22 = &a1[v3];
  v23 = a1[v3];
  if ( ((char)a1[v3] & 0x80000000) != 0 )
  {
    switch ( v23 )
    {
      case 252:
        v23 = *(_DWORD *)(v22 + 1);
        v3 = (unsigned int)(v3 + 9);
        break;
      case 253:
        v23 = *(_DWORD *)(v22 + 1);
        v3 = (unsigned int)(v3 + 5);
        break;
      case 254:
        v23 = *(unsigned __int16 *)(v22 + 1);
        v3 = (unsigned int)(v3 + 3);
        break;
      default:
        v23 = 0;
        break;
    }
  }
  else
  {
    v3 = (unsigned int)(v3 + 1);
  }
  *(_DWORD *)(a2 + 40) = v23;
  v24 = &a1[v3];
  v25 = a1[v3];
  if ( ((char)a1[v3] & 0x80000000) != 0 )
  {
    switch ( v25 )
    {
      case 252:
        v25 = *(_DWORD *)(v24 + 1);
        v3 = (unsigned int)(v3 + 9);
        break;
      case 253:
        v25 = *(_DWORD *)(v24 + 1);
        v3 = (unsigned int)(v3 + 5);
        break;
      case 254:
        v25 = *(unsigned __int16 *)(v24 + 1);
        v3 = (unsigned int)(v3 + 3);
        break;
      default:
        v25 = 0;
        break;
    }
  }
  else
  {
    v3 = (unsigned int)(v3 + 1);
  }
  *(_DWORD *)(a2 + 44) = v25;
  v26 = &a1[v3];
  v27 = a1[v3];
  if ( ((char)a1[v3] & 0x80000000) != 0 )
  {
    switch ( v27 )
    {
      case 252:
        v27 = *(_DWORD *)(v26 + 1);
        v3 = (unsigned int)(v3 + 9);
        break;
      case 253:
        v27 = *(_DWORD *)(v26 + 1);
        v3 = (unsigned int)(v3 + 5);
        break;
      case 254:
        v27 = *(unsigned __int16 *)(v26 + 1);
        v3 = (unsigned int)(v3 + 3);
        break;
      default:
        v27 = 0;
        break;
    }
  }
  else
  {
    v3 = (unsigned int)(v3 + 1);
  }
  *(_DWORD *)(a2 + 48) = v27;
  v28 = &a1[v3];
  v29 = a1[v3];
  if ( ((char)a1[v3] & 0x80000000) != 0 )
  {
    switch ( v29 )
    {
      case 252:
        v29 = *(_DWORD *)(v28 + 1);
        v3 = (unsigned int)(v3 + 9);
        break;
      case 253:
        v29 = *(_DWORD *)(v28 + 1);
        v3 = (unsigned int)(v3 + 5);
        break;
      case 254:
        v29 = *(unsigned __int16 *)(v28 + 1);
        v3 = (unsigned int)(v3 + 3);
        break;
      default:
        v29 = 0;
        break;
    }
  }
  else
  {
    v3 = (unsigned int)(v3 + 1);
  }
  *(_DWORD *)(a2 + 52) = v29;
  v30 = &a1[v3];
  v31 = a1[v3];
  if ( ((char)a1[v3] & 0x80000000) != 0 )
  {
    switch ( v31 )
    {
      case 252:
        v31 = *(_DWORD *)(v30 + 1);
        v3 = (unsigned int)(v3 + 9);
        break;
      case 253:
        v31 = *(_DWORD *)(v30 + 1);
        v3 = (unsigned int)(v3 + 5);
        break;
      case 254:
        v31 = *(unsigned __int16 *)(v30 + 1);
        v3 = (unsigned int)(v3 + 3);
        break;
      default:
        v31 = 0;
        break;
    }
  }
  else
  {
    v3 = (unsigned int)(v3 + 1);
  }
  *(_DWORD *)(a2 + 56) = v31;
  v32 = &a1[v3];
  v33 = a1[v3];
  if ( ((char)a1[v3] & 0x80000000) != 0 )
  {
    switch ( v33 )
    {
      case 252:
        v33 = *(_DWORD *)(v32 + 1);
        v3 = (unsigned int)(v3 + 9);
        break;
      case 253:
        v33 = *(_DWORD *)(v32 + 1);
        v3 = (unsigned int)(v3 + 5);
        break;
      case 254:
        v33 = *(unsigned __int16 *)(v32 + 1);
        v3 = (unsigned int)(v3 + 3);
        break;
      default:
        v33 = 0;
        break;
    }
  }
  else
  {
    v3 = (unsigned int)(v3 + 1);
  }
  *(_DWORD *)(a2 + 60) = v33;
  v34 = &a1[v3];
  v35 = a1[v3];
  if ( ((char)a1[v3] & 0x80000000) != 0 )
  {
    switch ( v35 )
    {
      case 252:
        v35 = *(_DWORD *)(v34 + 1);
        v3 = (unsigned int)(v3 + 9);
        break;
      case 253:
        v35 = *(_DWORD *)(v34 + 1);
        v3 = (unsigned int)(v3 + 5);
        break;
      case 254:
        v35 = *(unsigned __int16 *)(v34 + 1);
        v3 = (unsigned int)(v3 + 3);
        break;
      default:
        v35 = 0;
        break;
    }
  }
  else
  {
    v3 = (unsigned int)(v3 + 1);
  }
  *(_DWORD *)(a2 + 64) = v35;
  v36 = &a1[v3];
  v37 = a1[v3];
  if ( ((char)a1[v3] & 0x80000000) != 0 )
  {
    switch ( v37 )
    {
      case 252:
        v37 = *(_DWORD *)(v36 + 1);
        v3 = (unsigned int)(v3 + 9);
        break;
      case 253:
        v37 = *(_DWORD *)(v36 + 1);
        v3 = (unsigned int)(v3 + 5);
        break;
      case 254:
        v37 = *(unsigned __int16 *)(v36 + 1);
        v3 = (unsigned int)(v3 + 3);
        break;
      default:
        v37 = 0;
        break;
    }
  }
  else
  {
    v3 = (unsigned int)(v3 + 1);
  }
  *(_DWORD *)(a2 + 68) = v37;
  v38 = &a1[v3];
  v39 = a1[v3];
  if ( ((char)a1[v3] & 0x80000000) != 0 )
  {
    switch ( v39 )
    {
      case 252:
        v39 = *(_DWORD *)(v38 + 1);
        v3 = (unsigned int)(v3 + 9);
        break;
      case 253:
        v39 = *(_DWORD *)(v38 + 1);
        v3 = (unsigned int)(v3 + 5);
        break;
      case 254:
        v39 = *(unsigned __int16 *)(v38 + 1);
        v3 = (unsigned int)(v3 + 3);
        break;
      default:
        v39 = 0;
        break;
    }
  }
  else
  {
    v3 = (unsigned int)(v3 + 1);
  }
  *(_DWORD *)(a2 + 72) = v39;
  v40 = &a1[v3];
  v41 = a1[v3];
  if ( ((char)a1[v3] & 0x80000000) != 0 )
  {
    switch ( v41 )
    {
      case 252:
        v41 = *(_DWORD *)(v40 + 1);
        v3 = (unsigned int)(v3 + 9);
        break;
      case 253:
        v41 = *(_DWORD *)(v40 + 1);
        v3 = (unsigned int)(v3 + 5);
        break;
      case 254:
        v41 = *(unsigned __int16 *)(v40 + 1);
        v3 = (unsigned int)(v3 + 3);
        break;
      default:
        v41 = 0;
        break;
    }
  }
  else
  {
    v3 = (unsigned int)(v3 + 1);
  }
  *(_DWORD *)(a2 + 76) = v41;
  *(_DWORD *)(a2 + 80) = a1[v3];
  v42 = v3 + 2;
  v43 = &a1[v3 + 2];
  *(_DWORD *)(a2 + 84) = a1[v3 + 1];
  v44 = *v43;
  if ( ((char)*v43 & 0x80000000) != 0 )
  {
    switch ( v44 )
    {
      case 252:
        v44 = *(_DWORD *)(v43 + 1);
        v42 = (unsigned int)(v3 + 11);
        break;
      case 253:
        v44 = *(_DWORD *)(v43 + 1);
        v42 = (unsigned int)(v3 + 7);
        break;
      case 254:
        v44 = *(unsigned __int16 *)(v43 + 1);
        v42 = (unsigned int)(v3 + 5);
        break;
      default:
        v44 = 0;
        break;
    }
  }
  else
  {
    v42 = (unsigned int)(v3 + 3);
  }
  *(_DWORD *)(a2 + 88) = v44;
  v45 = &a1[v42];
  v46 = a1[v42];
  if ( ((char)a1[v42] & 0x80000000) != 0 )
  {
    switch ( v46 )
    {
      case 252:
        v46 = *(_DWORD *)(v45 + 1);
        v42 = (unsigned int)(v42 + 9);
        break;
      case 253:
        v46 = *(_DWORD *)(v45 + 1);
        v42 = (unsigned int)(v42 + 5);
        break;
      case 254:
        v46 = *(unsigned __int16 *)(v45 + 1);
        v42 = (unsigned int)(v42 + 3);
        break;
      default:
        v46 = 0;
        break;
    }
  }
  else
  {
    v42 = (unsigned int)(v42 + 1);
  }
  *(_DWORD *)(a2 + 92) = v46;
  v47 = &a1[v42];
  v48 = a1[v42];
  if ( ((char)a1[v42] & 0x80000000) != 0 )
  {
    switch ( v48 )
    {
      case 252:
        v48 = *(_DWORD *)(v47 + 1);
        v42 = (unsigned int)(v42 + 9);
        break;
      case 253:
        v48 = *(_DWORD *)(v47 + 1);
        v42 = (unsigned int)(v42 + 5);
        break;
      case 254:
        v48 = *(unsigned __int16 *)(v47 + 1);
        v42 = (unsigned int)(v42 + 3);
        break;
      default:
        v48 = 0;
        break;
    }
  }
  else
  {
    v42 = (unsigned int)(v42 + 1);
  }
  *(_DWORD *)(a2 + 96) = v48;
  v49 = &a1[v42];
  v50 = a1[v42];
  if ( ((char)a1[v42] & 0x80000000) != 0 )
  {
    switch ( v50 )
    {
      case 252:
        v50 = *(_DWORD *)(v49 + 1);
        v42 = (unsigned int)(v42 + 9);
        break;
      case 253:
        v50 = *(_DWORD *)(v49 + 1);
        v42 = (unsigned int)(v42 + 5);
        break;
      case 254:
        v50 = *(unsigned __int16 *)(v49 + 1);
        v42 = (unsigned int)(v42 + 3);
        break;
      default:
        v50 = 0;
        break;
    }
  }
  else
  {
    v42 = (unsigned int)(v42 + 1);
  }
  *(_DWORD *)(a2 + 100) = v50;
  v51 = &a1[v42];
  v52 = a1[v42];
  if ( ((char)a1[v42] & 0x80000000) != 0 )
  {
    switch ( v52 )
    {
      case 252:
        v52 = *(_DWORD *)(v51 + 1);
        v42 = (unsigned int)(v42 + 9);
        break;
      case 253:
        v52 = *(_DWORD *)(v51 + 1);
        v42 = (unsigned int)(v42 + 5);
        break;
      case 254:
        v52 = *(unsigned __int16 *)(v51 + 1);
        v42 = (unsigned int)(v42 + 3);
        break;
      default:
        v52 = 0;
        break;
    }
  }
  else
  {
    v42 = (unsigned int)(v42 + 1);
  }
  *(_DWORD *)(a2 + 104) = v52;
  v53 = &a1[v42];
  v54 = a1[v42];
  if ( ((char)a1[v42] & 0x80000000) != 0 )
  {
    switch ( v54 )
    {
      case 252:
        v54 = *(_DWORD *)(v53 + 1);
        v42 = (unsigned int)(v42 + 9);
        break;
      case 253:
        v54 = *(_DWORD *)(v53 + 1);
        v42 = (unsigned int)(v42 + 5);
        break;
      case 254:
        v54 = *(unsigned __int16 *)(v53 + 1);
        v42 = (unsigned int)(v42 + 3);
        break;
      default:
        v54 = 0;
        break;
    }
  }
  else
  {
    v42 = (unsigned int)(v42 + 1);
  }
  *(_DWORD *)(a2 + 108) = v54;
  v55 = &a1[v42];
  v56 = a1[v42];
  if ( ((char)a1[v42] & 0x80000000) != 0 )
  {
    switch ( v56 )
    {
      case 252:
        v56 = *(_DWORD *)(v55 + 1);
        v42 = (unsigned int)(v42 + 9);
        break;
      case 253:
        v56 = *(_DWORD *)(v55 + 1);
        v42 = (unsigned int)(v42 + 5);
        break;
      case 254:
        v56 = *(unsigned __int16 *)(v55 + 1);
        v42 = (unsigned int)(v42 + 3);
        break;
      default:
        v56 = 0;
        break;
    }
  }
  else
  {
    v42 = (unsigned int)(v42 + 1);
  }
  *(_DWORD *)(a2 + 112) = v56;
  v57 = &a1[v42];
  v58 = a1[v42];
  if ( ((char)a1[v42] & 0x80000000) != 0 )
  {
    switch ( v58 )
    {
      case 252:
        v58 = *(_DWORD *)(v57 + 1);
        v42 = (unsigned int)(v42 + 9);
        break;
      case 253:
        v58 = *(_DWORD *)(v57 + 1);
        v42 = (unsigned int)(v42 + 5);
        break;
      case 254:
        v58 = *(unsigned __int16 *)(v57 + 1);
        v42 = (unsigned int)(v42 + 3);
        break;
      default:
        v58 = 0;
        break;
    }
  }
  else
  {
    v42 = (unsigned int)(v42 + 1);
  }
  *(_DWORD *)(a2 + 116) = v58;
  v59 = &a1[v42];
  result = (unsigned int)v42;
  *(_QWORD *)(a2 + 120) = v59;
  return result;
}

//----- (00000000000148B0) ----------------------------------------------------
__int64 __fastcall sub_148B0(FILE *stream, void *ptr, size_t a3)
{
  return fread(ptr, 1u, a3, stream);
}

//----- (00000000000148D4) ----------------------------------------------------
__int64 __fastcall sub_148D4(FILE *s, void *ptr, size_t a3)
{
  return fwrite(ptr, 1u, a3, s);
}

//----- (00000000000148F8) ----------------------------------------------------
__int64 sub_148F8()
{
  return 0LL;
}

//----- (0000000000014900) ----------------------------------------------------
_QWORD *__fastcall sub_14900(int a1)
{
  _QWORD *v2; // x0
  _QWORD *v3; // x19
  __int64 v4; // x0
  _QWORD *result; // x0

  v2 = (_QWORD *)sub_1810C(16LL);
  *v2 = 0LL;
  if ( v2 && (v3 = v2, v4 = sub_1810C(a1), (v3[1] = v4) != 0LL) )
    result = v3;
  else
    result = 0LL;
  return result;
}

//----- (0000000000014954) ----------------------------------------------------
void __fastcall sub_14954(_QWORD *a1)
{
  void *v2; // x0

  v2 = (void *)a1[1];
  *a1 = 0x100000LL;
  j__free(v2);
  j__free(a1);
}

//----- (0000000000014978) ----------------------------------------------------
__int64 __fastcall sub_14978(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // x19
  __int64 v4; // x0
  __int64 v5; // x8
  void **v6; // x20
  unsigned __int64 v7; // x22
  _OWORD *v8; // x0
  __int64 result; // x0

  if ( *(_QWORD *)(a1 + 8) >= a2 )
    return 1LL;
  v3 = a2;
  v4 = sub_1810C(8 * a2);
  if ( !v4 )
    return 5LL;
  v5 = *(_QWORD *)(a1 + 8);
  v6 = (void **)v4;
  if ( v3 > (int)v5 )
  {
    v7 = (int)v5;
    while ( 1 )
    {
      v8 = (_OWORD *)sub_1810C(48LL);
      v6[v7] = v8;
      if ( !v8 )
        break;
      ++v7;
      v8[1] = 0u;
      v8[2] = 0u;
      *v8 = 0u;
      if ( v7 >= v3 )
      {
        v5 = *(_QWORD *)(a1 + 8);
        goto LABEL_8;
      }
    }
    do
    {
      if ( *v6 )
        j__free(*v6);
      --v3;
      ++v6;
    }
    while ( v3 );
    return 5LL;
  }
LABEL_8:
  if ( v5 )
  {
    memcpy(v6, *(const void **)(a1 + 16), 8 * v5);
    j__free(*(void **)(a1 + 16));
  }
  result = 0LL;
  *(_QWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a1 + 16) = v6;
  return result;
}

//----- (0000000000014A5C) ----------------------------------------------------
__int64 __fastcall sub_14A5C(unsigned __int64 a1)
{
  _QWORD *v2; // x0
  _QWORD *v3; // x19
  unsigned int v4; // w0
  unsigned __int64 v5; // x8
  __int64 v6; // x20
  unsigned __int64 i; // x22
  __int64 **v8; // x21
  __int64 *j; // x0
  __int64 *v10; // x8

  v2 = (_QWORD *)sub_1810C(24LL);
  if ( !v2 )
    return 5LL;
  v3 = v2;
  v2[1] = 0LL;
  v2[2] = 0LL;
  *v2 = &off_19D60;
  v4 = sub_14978((__int64)v2, a1);
  if ( !v4 )
    return (__int64)v3;
  v5 = v3[1];
  v6 = v4;
  if ( v5 )
  {
    for ( i = 0LL; i < v5; i = (unsigned int)(i + 1) )
    {
      v8 = *(__int64 ***)(v3[2] + 8 * i);
      if ( v8 )
      {
        for ( j = *v8; *v8; j = *v8 )
        {
          v10 = (__int64 *)*j;
          *j = 0x100000LL;
          *v8 = v10;
          sub_14954(j);
        }
        j__free(v8);
        v5 = v3[1];
      }
    }
  }
  j__free((void *)v3[2]);
  j__free(v3);
  return v6;
}
// 19D60: using guessed type __int64 (__fastcall *off_19D60)();

//----- (0000000000014B2C) ----------------------------------------------------
void __fastcall sub_14B2C(__int64 a1)
{
  unsigned __int64 v1; // x8
  unsigned __int64 i; // x21
  __int64 **v4; // x20
  __int64 *j; // x0
  __int64 *v6; // x8

  v1 = *(_QWORD *)(a1 + 8);
  if ( v1 )
  {
    for ( i = 0LL; i < v1; i = (unsigned int)(i + 1) )
    {
      v4 = *(__int64 ***)(*(_QWORD *)(a1 + 16) + 8 * i);
      if ( v4 )
      {
        for ( j = *v4; *v4; j = *v4 )
        {
          v6 = (__int64 *)*j;
          *j = 0x100000LL;
          *v4 = v6;
          sub_14954(j);
        }
        j__free(v4);
        v1 = *(_QWORD *)(a1 + 8);
      }
    }
  }
  j__free(*(void **)(a1 + 16));
  j__free((void *)a1);
}

//----- (0000000000014BB4) ----------------------------------------------------
__int64 __fastcall sub_14BB4(__int64 a1, void *dest, int a3, int a4)
{
  _QWORD *v4; // x23
  int v6; // w19
  unsigned int v8; // w24
  int v10; // w8
  int v11; // w9
  int v12; // w8
  unsigned int v13; // w8
  signed int v14; // w25

  if ( a3 )
  {
    v4 = *(_QWORD **)a1;
    if ( !*(_QWORD *)a1 )
      return 0xFFFFFFFFLL;
    v6 = a3;
    if ( (unsigned int)(a4 + a3) > *(_DWORD *)(a1 + 16) )
      return 0xFFFFFFFFLL;
    v8 = *(_DWORD *)(a1 + 36);
    if ( a4 >= 1 )
    {
      v10 = *(_DWORD *)(a1 + 40);
      do
      {
        v11 = v10 - v8;
        if ( a4 < v10 - v8 )
          v11 = a4;
        v8 += v11;
        a4 -= v11;
        if ( v8 == v10 )
        {
          v4 = (_QWORD *)*v4;
          v8 = 0;
        }
      }
      while ( a4 > 0 );
    }
    if ( a3 >= 1 )
    {
      v12 = *(_DWORD *)(a1 + 40);
      do
      {
        v13 = v12 - v8;
        if ( v6 >= v13 )
          v14 = v13;
        else
          v14 = v6;
        memcpy(dest, (const void *)(v4[1] + v8), v14);
        v12 = *(_DWORD *)(a1 + 40);
        v8 += v14;
        v6 -= v14;
        dest = (char *)dest + v14;
        if ( v8 == v12 )
        {
          v4 = (_QWORD *)*v4;
          v8 = 0;
        }
      }
      while ( v6 > 0 );
    }
  }
  return 0LL;
}

//----- (0000000000014CB0) ----------------------------------------------------
__int64 __fastcall sub_14CB0(__int64 **a1, void *dest, int a3)
{
  _QWORD *v3; // x9
  unsigned int v5; // w8
  int v6; // w19
  bool v7; // cf
  unsigned int v8; // w8
  unsigned int v10; // w8
  __int64 v12; // x9
  signed int v13; // w24
  int v14; // w9
  _QWORD *v15; // x0
  __int64 *v16; // x8

  if ( a3 )
  {
    v3 = *a1;
    if ( !*a1 )
      return 0xFFFFFFFFLL;
    v5 = *((_DWORD *)a1 + 4);
    v6 = a3;
    v7 = v5 >= a3;
    v8 = v5 - a3;
    if ( !v7 )
      return 0xFFFFFFFFLL;
    *((_DWORD *)a1 + 4) = v8;
    if ( a3 >= 1 )
    {
      v10 = *((_DWORD *)a1 + 9);
      while ( 1 )
      {
        v12 = v3[1];
        v13 = v6 >= *((_DWORD *)a1 + 10) - v10 ? *((_DWORD *)a1 + 10) - v10 : v6;
        memcpy(dest, (const void *)(v12 + v10), v13);
        v14 = *((_DWORD *)a1 + 10);
        v6 -= v13;
        v10 = *((_DWORD *)a1 + 9) + v13;
        *((_DWORD *)a1 + 9) = v10;
        if ( v10 == v14 )
        {
          v15 = *a1;
          v16 = (__int64 *)**a1;
          *v15 = 0x100000LL;
          *a1 = v16;
          sub_14954(v15);
          v10 = 0;
          *((_DWORD *)a1 + 9) = 0;
        }
        if ( v6 < 1 )
          break;
        v3 = *a1;
        dest = (char *)dest + v13;
      }
    }
  }
  return 0LL;
}

//----- (0000000000014D88) ----------------------------------------------------
__int64 __fastcall sub_14D88(__int64 a1)
{
  _QWORD *v2; // x0
  unsigned int v3; // w8

  v2 = sub_14900(*(_DWORD *)(a1 + 40));
  if ( v2 )
    v3 = 0;
  else
    v3 = 5;
  *(_QWORD *)a1 = v2;
  *(_QWORD *)(a1 + 8) = v2;
  return v3;
}

//----- (0000000000014DB4) ----------------------------------------------------
__int64 __fastcall sub_14DB4(FILE *stream)
{
  __int64 result; // x0
  __int64 ptr; // [xsp+8h] [xbp-8h] BYREF

  if ( fread(&ptr, 8u, 1u, stream) == 1LL )
    result = ptr;
  else
    result = 6LL;
  return result;
}

//----- (0000000000014DE4) ----------------------------------------------------
__int64 __fastcall sub_14DE4(FILE *a1)
{
  __int64 v2; // x19
  __int64 v3; // x20
  __int64 v4; // x22
  unsigned int v5; // w0
  size_t v6; // w23
  __int64 v7; // x24
  int v8; // w0
  _QWORD *v9; // x0
  size_t v10; // w0
  size_t v11; // w8
  unsigned int v12; // w0
  unsigned __int64 v13; // x8
  unsigned __int64 i; // x22
  __int64 **v15; // x21
  __int64 *j; // x0
  __int64 *v17; // x8
  int ptr[3]; // [xsp+8h] [xbp-58h] BYREF
  size_t v20; // [xsp+14h] [xbp-4Ch]
  size_t v21; // [xsp+2Ch] [xbp-34h] BYREF

  v2 = sub_14A5C(0x903uLL);
  if ( fread(ptr, 0x16u, 1u, a1) == 1LL )
  {
    v3 = 5LL;
    while ( 1 )
    {
      v4 = (unsigned int)ptr[0];
      if ( *(_QWORD *)(v2 + 8) <= (unsigned __int64)(unsigned int)ptr[0] )
      {
        v5 = sub_14978(v2, (unsigned int)(ptr[0] + 1));
        if ( v5 )
          break;
      }
      v6 = v20;
      v7 = *(_QWORD *)(*(_QWORD *)(v2 + 16) + 8 * v4);
      v8 = v20;
      *(_DWORD *)(v7 + 40) = v20;
      *(_DWORD *)(v7 + 16) = v6;
      v9 = sub_14900(v8);
      *(_QWORD *)v7 = v9;
      *(_QWORD *)(v7 + 8) = v9;
      if ( !v9 )
        goto LABEL_15;
      *(_QWORD *)(v7 + 8) = v9;
      v10 = fread((void *)v9[1], v6, 1u, a1);
      if ( !v10 )
      {
        v12 = ferror(a1);
        __android_log_print(6, "streams", "Error %d: Could not read stream %d", v12, (unsigned int)v4);
        v3 = 3LL;
        goto LABEL_15;
      }
      v11 = ((v6 + 3) & 0xFFFFFFFC) - v6;
      *(_DWORD *)(v7 + 32) = v10;
      v21 = v11;
      if ( v11 )
        fread(&v21, v11, 1u, a1);
      if ( fread(ptr, 0x16u, 1u, a1) != 1LL )
        goto LABEL_10;
    }
    v3 = v5;
    v13 = *(_QWORD *)(v2 + 8);
    if ( !v13 )
      goto LABEL_24;
    goto LABEL_16;
  }
LABEL_10:
  if ( !feof(a1) )
  {
    v3 = 6LL;
    if ( !v2 )
      return v3;
LABEL_15:
    v13 = *(_QWORD *)(v2 + 8);
    if ( !v13 )
      goto LABEL_24;
LABEL_16:
    for ( i = 0LL; i < v13; i = (unsigned int)(i + 1) )
    {
      v15 = *(__int64 ***)(*(_QWORD *)(v2 + 16) + 8 * i);
      if ( v15 )
      {
        for ( j = *v15; *v15; j = *v15 )
        {
          v17 = (__int64 *)*j;
          *j = 0x100000LL;
          *v15 = v17;
          sub_14954(j);
        }
        j__free(v15);
        v13 = *(_QWORD *)(v2 + 8);
      }
    }
LABEL_24:
    j__free(*(void **)(v2 + 16));
    j__free((void *)v2);
    return v3;
  }
  return v2;
}

//----- (0000000000014FB8) ----------------------------------------------------
__int64 __fastcall sub_14FB8(__int64 **a1)
{
  char v1; // w9
  unsigned int v2; // w8
  unsigned int v4; // w19
  int v5; // w23
  unsigned int v6; // w11
  _QWORD *v7; // x10
  unsigned int v8; // w12
  int v9; // w12
  int v10; // w25
  char *v11; // x21
  signed int v12; // w26
  int v13; // w9
  _QWORD *v14; // x0
  __int64 *v15; // x8
  char dest; // [xsp+Ch] [xbp-44h] BYREF

  v2 = *((_DWORD *)a1 + 9);
  v4 = 0;
  v5 = 0;
  do
  {
    v6 = *((_DWORD *)a1 + 10);
    v7 = *a1;
    v8 = v2 + 1;
    if ( v2 + 1 >= v6 )
    {
      if ( v7 )
      {
        v9 = *((_DWORD *)a1 + 4);
        if ( v9 )
        {
          v10 = 1;
          v11 = &dest;
          *((_DWORD *)a1 + 4) = v9 - 1;
          while ( 1 )
          {
            v12 = v10 >= v6 - v2 ? v6 - v2 : v10;
            memcpy(v11, (const void *)(v7[1] + v2), v12);
            v13 = *((_DWORD *)a1 + 10);
            v10 -= v12;
            v2 = *((_DWORD *)a1 + 9) + v12;
            *((_DWORD *)a1 + 9) = v2;
            if ( v2 == v13 )
            {
              v14 = *a1;
              v15 = (__int64 *)**a1;
              *v14 = 0x100000LL;
              *a1 = v15;
              sub_14954(v14);
              v2 = 0;
              *((_DWORD *)a1 + 9) = 0;
            }
            if ( v10 < 1 )
              break;
            v7 = *a1;
            v6 = *((_DWORD *)a1 + 10);
            v11 += v12;
          }
          v1 = dest;
        }
      }
    }
    else
    {
      v1 = *(_BYTE *)(v7[1] + v2++);
      dest = v1;
      *((_DWORD *)a1 + 9) = v8;
    }
    v4 |= (v1 & 0x7F) << v5;
    v5 += 7;
  }
  while ( (v1 & 0x80) != 0 );
  return v4;
}
// 15008: variable 'v1' is possibly undefined

//----- (00000000000150D0) ----------------------------------------------------
__int64 __fastcall sub_150D0(__int64 **a1)
{
  char v1; // w9
  unsigned int v2; // w8
  int v4; // w22
  unsigned int v5; // w12
  unsigned int v6; // w11
  _QWORD *v7; // x10
  unsigned int v8; // w13
  unsigned int v9; // w24
  int v10; // w12
  int v11; // w25
  char *v12; // x20
  signed int v13; // w26
  int v14; // w9
  _QWORD *v15; // x0
  __int64 *v16; // x8
  int v17; // w8
  char dest; // [xsp+Ch] [xbp-44h] BYREF

  v2 = *((_DWORD *)a1 + 9);
  v4 = 0;
  v5 = 0;
  do
  {
    v6 = *((_DWORD *)a1 + 10);
    v7 = *a1;
    v8 = v2 + 1;
    v9 = v5;
    if ( v2 + 1 >= v6 )
    {
      if ( v7 )
      {
        v10 = *((_DWORD *)a1 + 4);
        if ( v10 )
        {
          v11 = 1;
          v12 = &dest;
          *((_DWORD *)a1 + 4) = v10 - 1;
          while ( 1 )
          {
            if ( v11 >= v6 - v2 )
              v13 = v6 - v2;
            else
              v13 = v11;
            memcpy(v12, (const void *)(v7[1] + v2), v13);
            v14 = *((_DWORD *)a1 + 10);
            v11 -= v13;
            v2 = *((_DWORD *)a1 + 9) + v13;
            *((_DWORD *)a1 + 9) = v2;
            if ( v2 == v14 )
            {
              v15 = *a1;
              v16 = (__int64 *)**a1;
              *v15 = 0x100000LL;
              *a1 = v16;
              sub_14954(v15);
              v2 = 0;
              *((_DWORD *)a1 + 9) = 0;
            }
            if ( v11 < 1 )
              break;
            v7 = *a1;
            v6 = *((_DWORD *)a1 + 10);
            v12 += v13;
          }
          v1 = dest;
        }
      }
    }
    else
    {
      v1 = *(_BYTE *)(v7[1] + v2++);
      dest = v1;
      *((_DWORD *)a1 + 9) = v8;
    }
    v4 |= (v1 & 0x7F) << v9;
    v5 = v9 + 7;
  }
  while ( (v1 & 0x80) != 0 );
  if ( ((v9 < 0x19) & ((unsigned __int8)(v1 & 0x40) >> 6)) != 0 )
    v17 = -128 << v9;
  else
    v17 = 0;
  return (unsigned int)(v17 + v4);
}
// 15124: variable 'v1' is possibly undefined

//----- (0000000000015208) ----------------------------------------------------
__int64 __fastcall sub_15208(__int64 a1, FILE *s)
{
  __int64 i; // x22
  __int64 **v5; // x25
  int v6; // w8
  __int64 v7; // x9
  __int64 *v8; // x27
  int v9; // w26
  __int64 *v10; // x8
  __int64 v11; // x9
  int v12; // w21
  size_t v13; // w8
  int ptr; // [xsp+8h] [xbp-68h] BYREF
  __int64 v16; // [xsp+Ch] [xbp-64h]
  int v17; // [xsp+14h] [xbp-5Ch]
  int v18; // [xsp+18h] [xbp-58h]
  char v19; // [xsp+1Ch] [xbp-54h]
  char v20; // [xsp+1Dh] [xbp-53h]

  for ( i = 0LL; i != 2307; ++i )
  {
    v5 = *(__int64 ***)(*(_QWORD *)(a1 + 16) + 8 * i);
    v6 = *((_DWORD *)v5 + 4);
    if ( v6 )
    {
      ptr = i;
      v7 = *(__int64 *)((char *)v5 + 20);
      v17 = v6;
      v18 = 0;
      v19 = 0;
      v16 = v7;
      v20 = *((_BYTE *)v5 + 28);
      if ( fwrite(&ptr, 0x16u, 1u, s) != 1LL )
        return 6LL;
      v8 = *v5;
      if ( *v5 )
      {
        v9 = 0;
        while ( 1 )
        {
          while ( 1 )
          {
            v10 = (__int64 *)*v8;
            v11 = *v8 ? 40LL : 32LL;
            v12 = *(_DWORD *)((char *)v5 + v11);
            if ( v12 )
              break;
            v8 = (__int64 *)*v8;
            if ( !v10 )
              goto LABEL_16;
          }
          if ( fwrite((const void *)v8[1], *(_DWORD *)((char *)v5 + v11), 1u, s) != 1 )
            return 6LL;
          v8 = (__int64 *)*v8;
          v9 += v12;
          if ( !v8 )
            goto LABEL_16;
        }
      }
    }
    v9 = 0;
LABEL_16:
    v13 = ((v9 + 3) & 0xFFFFFFFC) - v9;
    ptr = 0;
    if ( v13 )
      fwrite(&ptr, v13, 1u, s);
  }
  return 0LL;
}

//----- (000000000001533C) ----------------------------------------------------
__int64 __fastcall sub_1533C(__int64 a1, unsigned __int64 a2, int a3)
{
  __int64 v6; // x22
  char *v7; // x0
  unsigned __int64 v8; // x25
  char *v9; // x23
  unsigned __int64 v10; // x24
  __int64 v11; // x9

  v6 = sub_1810C(32LL);
  *(_OWORD *)v6 = 0u;
  *(_OWORD *)(v6 + 16) = 0u;
  v7 = (char *)sub_1810C(8 * a2);
  v8 = *(_QWORD *)(a1 + 8);
  v9 = v7;
  if ( v8 >= a2 )
    v10 = a2;
  else
    v10 = *(_QWORD *)(a1 + 8);
  memcpy(v7, *(const void **)(a1 + 16), 8 * v10);
  if ( v8 < a2 )
    memset(&v9[8 * v10], 0, 8 * (a2 - v10));
  if ( a3 )
    v11 = a1;
  else
    v11 = 0LL;
  *(_QWORD *)(v6 + 16) = v9;
  *(_QWORD *)(v6 + 24) = v11;
  *(_QWORD *)v6 = off_19D70;
  *(_QWORD *)(v6 + 8) = a2;
  return v6;
}
// 19D70: using guessed type __int64 (__fastcall *off_19D70[6])();

//----- (00000000000153D8) ----------------------------------------------------
void __fastcall sub_153D8(__int64 a1)
{
  void (__fastcall ***v2)(_QWORD); // x0

  v2 = *(void (__fastcall ****)(_QWORD))(a1 + 24);
  if ( v2 )
    (**v2)(v2);
  j__free(*(void **)(a1 + 16));
  j__free((void *)a1);
}

//----- (0000000000015408) ----------------------------------------------------
__int64 sub_15408()
{
  return 8LL;
}

//----- (0000000000015410) ----------------------------------------------------
unsigned __int64 __fastcall sub_15410(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x10
  unsigned __int64 v4; // x14
  unsigned __int64 v5; // x16
  unsigned __int64 v6; // x15
  __int64 v7; // x3
  __int64 v8; // x4
  __int64 v9; // x5
  __int64 v10; // x6
  unsigned __int64 v11; // x2
  unsigned __int64 v12; // x15
  __int64 v13; // x6
  __int64 v14; // x5
  __int64 v15; // x4
  __int64 v16; // x3
  unsigned __int64 v17; // x14
  unsigned int *v18; // x15
  bool v19; // cc
  unsigned int *v20; // x13
  __int64 v21; // x16
  unsigned int v22; // t1
  unsigned __int64 v23; // x14
  unsigned __int64 v24; // x16
  unsigned __int64 v25; // x15
  __int64 v26; // x3
  __int64 v27; // x4
  __int64 v28; // x5
  __int64 v29; // x6
  unsigned __int64 v30; // x2
  unsigned __int64 v31; // x15
  __int64 v32; // x6
  __int64 v33; // x5
  __int64 v34; // x4
  __int64 v35; // x3
  unsigned int *v36; // x15
  unsigned int *v37; // x13
  __int64 v38; // x16
  unsigned int v39; // t1
  unsigned __int64 v40; // x8

  v3 = a1 + a2;
  if ( (a1 & 7) != 0 )
  {
    if ( a2 < 0x20 )
    {
      v17 = a3 + 0x27D4EB2F165667C5LL + a2;
      if ( a1 + 8 <= v3 )
      {
        do
        {
LABEL_6:
          v18 = (unsigned int *)(a1 + 8);
          v19 = a1 + 16 > v3;
          v17 = 0x85EBCA77C2B2AE63LL
              - 0x61C8864E7A143579LL
              * __ROR8__(
                  (0x9E3779B185EBCA87LL
                 * ((0x93EA75A780000000LL * *(_QWORD *)a1) | ((0xC2B2AE3D27D4EB4FLL * *(_QWORD *)a1) >> 33))) ^ v17,
                  37);
          a1 += 8LL;
        }
        while ( !v19 );
        v20 = v18 + 1;
        if ( (unsigned __int64)(v18 + 1) > v3 )
          goto LABEL_10;
        goto LABEL_9;
      }
    }
    else
    {
      v4 = a3 - 0x3D4D51C2D82B14B1LL;
      v5 = a3 + 0x60EA27EEADC0B5D6LL;
      v6 = a3 + 0x61C8864E7A143579LL;
      do
      {
        v7 = *(_QWORD *)a1;
        v8 = *(_QWORD *)(a1 + 8);
        v9 = *(_QWORD *)(a1 + 16);
        v10 = *(_QWORD *)(a1 + 24);
        a1 += 32LL;
        v11 = a3 - 0x3D4D51C2D82B14B1LL * v9;
        v12 = v6 - 0x3D4D51C2D82B14B1LL * v10;
        v13 = __ROR8__(v5 - 0x3D4D51C2D82B14B1LL * v7, 33);
        v14 = __ROR8__(v4 - 0x3D4D51C2D82B14B1LL * v8, 33);
        v15 = __ROR8__(v11, 33);
        v16 = __ROR8__(v12, 33);
        v5 = 0x9E3779B185EBCA87LL * v13;
        v4 = 0x9E3779B185EBCA87LL * v14;
        a3 = 0x9E3779B185EBCA87LL * v15;
        v6 = 0x9E3779B185EBCA87LL * v16;
      }
      while ( a1 <= v3 - 32 );
      v17 = 0x85EBCA77C2B2AE63LL
          - 0x61C8864E7A143579LL
          * ((0x85EBCA77C2B2AE63LL
            - 0x61C8864E7A143579LL
            * ((0x85EBCA77C2B2AE63LL
              - 0x61C8864E7A143579LL
              * ((0x85EBCA77C2B2AE63LL
                - 0x61C8864E7A143579LL
                * ((((0x1BBCD8C2F5E54380LL * v14) | (v4 >> 57) & 0x7F)
                  + ((0x3C6EF3630BD7950ELL * v13) | (v5 >> 63))
                  + ((0x779B185EBCA87000LL * v15) | (a3 >> 52) & 0xFFF)
                  + ((0xE6C617AF2A1C0000LL * v16) | (v6 >> 46) & 0x3FFFF)) ^ (0x9E3779B185EBCA87LL
                                                                            * ((0x87BCB65480000000LL * v13) | ((0xDEF35B010F796CA9LL * v13) >> 33) & 0x7FFFFFFF)))) ^ (0x9E3779B185EBCA87LL * ((0x87BCB65480000000LL * v14) | ((0xDEF35B010F796CA9LL * v14) >> 33) & 0x7FFFFFFF)))) ^ (0x9E3779B185EBCA87LL * ((0x87BCB65480000000LL * v15) | ((0xDEF35B010F796CA9LL * v15) >> 33) & 0x7FFFFFFF)))) ^ (0x9E3779B185EBCA87LL * ((0x87BCB65480000000LL * v16) | ((0xDEF35B010F796CA9LL * v16) >> 33) & 0x7FFFFFFF)))
          + a2;
      if ( a1 + 8 <= v3 )
        goto LABEL_6;
    }
    v18 = (unsigned int *)a1;
    v20 = (unsigned int *)(a1 + 4);
    if ( a1 + 4 > v3 )
    {
LABEL_10:
      if ( (unsigned __int64)v18 < v3 )
      {
        do
        {
          v22 = *(unsigned __int8 *)v18;
          v18 = (unsigned int *)((char *)v18 + 1);
          v17 = 0x9E3779B185EBCA87LL * __ROR8__((0x27D4EB2F165667C5LL * v22) ^ v17, 53);
        }
        while ( (unsigned int *)v3 != v18 );
      }
      goto LABEL_23;
    }
LABEL_9:
    v21 = *v18;
    v18 = v20;
    v17 = 0xC2B2AE3D27D4EB4FLL * __ROR8__((0x9E3779B185EBCA87LL * v21) ^ v17, 41) + 0x165667B19E3779F9LL;
    goto LABEL_10;
  }
  if ( a2 < 0x20 )
  {
    v17 = a3 + 0x27D4EB2F165667C5LL + a2;
    if ( a1 + 8 <= v3 )
    {
      do
      {
LABEL_17:
        v36 = (unsigned int *)(a1 + 8);
        v19 = a1 + 16 > v3;
        v17 = 0x85EBCA77C2B2AE63LL
            - 0x61C8864E7A143579LL
            * __ROR8__(
                (0x9E3779B185EBCA87LL
               * ((0x93EA75A780000000LL * *(_QWORD *)a1) | ((0xC2B2AE3D27D4EB4FLL * *(_QWORD *)a1) >> 33))) ^ v17,
                37);
        a1 += 8LL;
      }
      while ( !v19 );
      v37 = v36 + 1;
      if ( (unsigned __int64)(v36 + 1) <= v3 )
        goto LABEL_20;
      goto LABEL_21;
    }
  }
  else
  {
    v23 = a3 - 0x3D4D51C2D82B14B1LL;
    v24 = a3 + 0x60EA27EEADC0B5D6LL;
    v25 = a3 + 0x61C8864E7A143579LL;
    do
    {
      v26 = *(_QWORD *)a1;
      v27 = *(_QWORD *)(a1 + 8);
      v28 = *(_QWORD *)(a1 + 16);
      v29 = *(_QWORD *)(a1 + 24);
      a1 += 32LL;
      v30 = a3 - 0x3D4D51C2D82B14B1LL * v28;
      v31 = v25 - 0x3D4D51C2D82B14B1LL * v29;
      v32 = __ROR8__(v24 - 0x3D4D51C2D82B14B1LL * v26, 33);
      v33 = __ROR8__(v23 - 0x3D4D51C2D82B14B1LL * v27, 33);
      v34 = __ROR8__(v30, 33);
      v35 = __ROR8__(v31, 33);
      v24 = 0x9E3779B185EBCA87LL * v32;
      v23 = 0x9E3779B185EBCA87LL * v33;
      a3 = 0x9E3779B185EBCA87LL * v34;
      v25 = 0x9E3779B185EBCA87LL * v35;
    }
    while ( a1 <= v3 - 32 );
    v17 = 0x85EBCA77C2B2AE63LL
        - 0x61C8864E7A143579LL
        * ((0x85EBCA77C2B2AE63LL
          - 0x61C8864E7A143579LL
          * ((0x85EBCA77C2B2AE63LL
            - 0x61C8864E7A143579LL
            * ((0x85EBCA77C2B2AE63LL
              - 0x61C8864E7A143579LL
              * ((((0x1BBCD8C2F5E54380LL * v33) | (v23 >> 57) & 0x7F)
                + ((0x3C6EF3630BD7950ELL * v32) | (v24 >> 63))
                + ((0x779B185EBCA87000LL * v34) | (a3 >> 52) & 0xFFF)
                + ((0xE6C617AF2A1C0000LL * v35) | (v25 >> 46) & 0x3FFFF)) ^ (0x9E3779B185EBCA87LL
                                                                           * ((0x87BCB65480000000LL * v32) | ((0xDEF35B010F796CA9LL * v32) >> 33) & 0x7FFFFFFF)))) ^ (0x9E3779B185EBCA87LL * ((0x87BCB65480000000LL * v33) | ((0xDEF35B010F796CA9LL * v33) >> 33) & 0x7FFFFFFF)))) ^ (0x9E3779B185EBCA87LL * ((0x87BCB65480000000LL * v34) | ((0xDEF35B010F796CA9LL * v34) >> 33) & 0x7FFFFFFF)))) ^ (0x9E3779B185EBCA87LL * ((0x87BCB65480000000LL * v35) | ((0xDEF35B010F796CA9LL * v35) >> 33) & 0x7FFFFFFF)))
        + a2;
    if ( a1 + 8 <= v3 )
      goto LABEL_17;
  }
  v36 = (unsigned int *)a1;
  v37 = (unsigned int *)(a1 + 4);
  if ( a1 + 4 <= v3 )
  {
LABEL_20:
    v38 = *v36;
    v36 = v37;
    v17 = 0xC2B2AE3D27D4EB4FLL * __ROR8__((0x9E3779B185EBCA87LL * v38) ^ v17, 41) + 0x165667B19E3779F9LL;
  }
LABEL_21:
  if ( (unsigned __int64)v36 < v3 )
  {
    do
    {
      v39 = *(unsigned __int8 *)v36;
      v36 = (unsigned int *)((char *)v36 + 1);
      v17 = 0x9E3779B185EBCA87LL * __ROR8__((0x27D4EB2F165667C5LL * v39) ^ v17, 53);
    }
    while ( (unsigned int *)v3 != v36 );
  }
LABEL_23:
  v40 = 0x165667B19E3779F9LL
      * ((0xC2B2AE3D27D4EB4FLL * (v17 ^ (v17 >> 33))) ^ ((0xC2B2AE3D27D4EB4FLL * (v17 ^ (v17 >> 33))) >> 29));
  return v40 ^ HIDWORD(v40);
}

//----- (00000000000158F0) ----------------------------------------------------
__int64 __fastcall sub_158F0(__int64 a1, __int64 *a2)
{
  int v2; // w8
  __int64 v5; // x23
  __int64 v6; // x22
  __int64 *v7; // x24
  __int64 v8; // x26
  __int64 v9; // x9
  __int64 v10; // x10
  _QWORD *v11; // x28
  void *v12; // x0
  unsigned __int64 v13; // x10
  unsigned __int64 v14; // x21
  __int64 v15; // x9
  unsigned __int64 v16; // x8
  bool v17; // zf
  int v18; // w8
  unsigned int v19; // w8
  __int64 v20; // x8
  __int64 v21; // x9
  __int64 v22; // x8
  __int64 v23; // x9
  __int64 v24; // x12
  unsigned __int64 v25; // x9
  unsigned __int64 v26; // x21
  __int64 v27; // x9
  unsigned __int64 v28; // x8
  bool v29; // zf
  unsigned __int64 v30; // x9
  char v31; // w10
  unsigned __int64 v32; // x8
  unsigned __int64 v33; // x9
  unsigned __int64 v34; // x10
  __int64 result; // x0
  unsigned __int64 v36; // x8
  unsigned __int64 v37; // x9
  int v39; // w11
  __int64 v40; // x9
  __int64 v41; // x12
  __int64 v42; // x13
  int v43; // w15
  __int64 v44; // x14
  unsigned __int64 v45; // x14
  __int64 v46; // x0
  __int64 v47; // x12
  __int64 v48; // x13
  unsigned __int64 v49; // x11
  unsigned __int64 v50; // x8
  unsigned __int64 v51; // x9
  unsigned __int64 v52; // x10
  int v53; // w12
  __int64 v54; // x10
  __int64 v55; // x10
  __int64 v56; // x11
  __int64 v57; // x8
  __int64 v58; // x9
  __int64 v59; // x8
  __int64 v60; // x8
  unsigned int v61; // w8
  int v62; // w10
  unsigned __int64 v63; // x11
  int v64; // w10
  int v65; // w13
  unsigned __int64 v66; // x12
  bool v67; // w13
  __int64 v68; // x11
  unsigned __int64 v69; // x12
  unsigned __int64 v70; // x10
  int v71; // w13
  int v72; // w14
  unsigned __int64 v73; // x10
  int v74; // w11
  __int64 v75; // x11
  __int64 v76; // x11
  __int64 v77; // x12
  __int64 v78; // x11
  __int64 v79; // x11
  __int64 v80; // x8
  __int64 v81; // x9
  __int64 v82; // x10
  __int64 v83; // x9
  __int64 v84; // x8
  __int64 v85; // x8
  __int64 v86; // x9
  __int64 v87; // x8
  unsigned int v88; // w8
  __int64 v89; // x10
  __int64 v90; // x11
  _QWORD *v91; // x24
  unsigned __int64 v92; // x8
  __int64 v93; // x11
  unsigned __int64 v94; // x21
  __int64 v95; // x9
  unsigned __int64 v96; // x8
  bool v97; // zf
  int v98; // w8

  v2 = *(_DWORD *)(a1 + 40);
  if ( v2 )
  {
    v2 = *(_DWORD *)a1;
  }
  else
  {
    *(_BYTE *)(a1 + 44) = 0;
    *(_QWORD *)a1 = 0LL;
    *(_DWORD *)(a1 + 32) = 0;
    *(_OWORD *)(a1 + 72) = 0u;
    *(_OWORD *)(a1 + 88) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
    *(_OWORD *)(a1 + 120) = 0u;
    *(_OWORD *)(a1 + 136) = 0u;
    *(_OWORD *)(a1 + 152) = 0u;
    *(_QWORD *)(a1 + 168) = 0LL;
    *(_QWORD *)(a1 + 176) = 12LL;
  }
  v5 = a2[1];
  v6 = a2[4];
  v7 = (__int64 *)(a1 + 72);
  v8 = a1 + 184;
  *(_QWORD *)(a1 + 16) = v5;
  while ( 2 )
  {
    switch ( v2 )
    {
      case 0:
        v9 = a2[1];
        v11 = (_QWORD *)(a1 + 168);
        v10 = *(_QWORD *)(a1 + 168);
        v12 = (void *)(a1 + 168 + v10 + 16);
        v13 = *(_QWORD *)(a1 + 176) - v10;
        if ( a2[2] - v9 >= v13 )
          v14 = v13;
        else
          v14 = a2[2] - v9;
        memcpy(v12, (const void *)(*a2 + v9), v14);
        a2[1] += v14;
        v15 = *(_QWORD *)(a1 + 176);
        v16 = *v11 + v14;
        v17 = v16 == v15;
        if ( v16 == v15 )
          v16 = 0LL;
        *v11 = v16;
        if ( !v17 )
          goto LABEL_139;
        v18 = *(_DWORD *)(a1 + 184) ^ 0x587A37FD | *(unsigned __int16 *)(a1 + 188) ^ 0x5A;
        *(_DWORD *)a1 = 1;
        if ( v18 )
        {
          result = 5LL;
          goto LABEL_140;
        }
        if ( *(_BYTE *)(a1 + 190) || (v19 = *(unsigned __int8 *)(a1 + 191), *(_DWORD *)(a1 + 36) = v19, v19 > 1) )
        {
LABEL_116:
          result = 6LL;
          goto LABEL_140;
        }
LABEL_16:
        v20 = a2[1];
        if ( v20 == a2[2] )
          goto LABEL_139;
        v21 = *(unsigned __int8 *)(*a2 + v20);
        if ( !*(_BYTE *)(*a2 + v20) )
        {
          a2[1] = v20 + 1;
          *(_QWORD *)(a1 + 16) = v20;
          v2 = 6;
          *(_DWORD *)a1 = 6;
          continue;
        }
        v22 = 0LL;
        v23 = 4 * v21 + 4;
        *(_DWORD *)(a1 + 64) = v23;
        *(_QWORD *)(a1 + 168) = 0LL;
        *(_QWORD *)(a1 + 176) = v23;
        *(_DWORD *)a1 = 2;
LABEL_20:
        v24 = a2[1];
        v25 = v23 - v22;
        if ( a2[2] - v24 >= v25 )
          v26 = v25;
        else
          v26 = a2[2] - v24;
        memcpy((void *)(a1 + 168 + v22 + 16), (const void *)(*a2 + v24), v26);
        a2[1] += v26;
        v27 = *(_QWORD *)(a1 + 176);
        v28 = *(_QWORD *)(a1 + 168) + v26;
        v29 = v28 == v27;
        if ( v28 == v27 )
          v30 = 0LL;
        else
          v30 = *(_QWORD *)(a1 + 168) + v26;
        *(_QWORD *)(a1 + 168) = v30;
        if ( !v29 )
          goto LABEL_139;
        v31 = *(_BYTE *)(a1 + 185);
        v32 = v28 - 4;
        *(_QWORD *)(a1 + 168) = 2LL;
        *(_QWORD *)(a1 + 176) = v32;
        if ( (v31 & 0x3F) != 0 )
          goto LABEL_116;
        if ( (v31 & 0x40) != 0 )
        {
          v39 = *(_DWORD *)(a1 + 4);
          if ( !v39 )
            *(_QWORD *)(a1 + 8) = 0LL;
          if ( v32 <= 2 )
            v40 = 2LL;
          else
            v40 = v32;
          v41 = 0LL;
          v42 = v40 - 2;
          while ( 1 )
          {
            if ( v42 == v41 )
              goto LABEL_138;
            v43 = *(unsigned __int8 *)(a1 + 186 + v41);
            v44 = *(_QWORD *)(a1 + 8);
            v33 = v41 + 3;
            *(_QWORD *)(a1 + 168) = v41 + 3;
            v45 = ((unsigned __int64)(v43 & 0x7F) << v39) | v44;
            *(_QWORD *)(a1 + 8) = v45;
            if ( (v43 & 0x80) == 0 )
              break;
            v39 += 7;
            ++v41;
            *(_DWORD *)(a1 + 4) = v39;
            if ( v39 == 63 )
              goto LABEL_138;
          }
          if ( v39 && !v43 )
            goto LABEL_138;
          *(_DWORD *)(a1 + 4) = 0;
          *(_QWORD *)(a1 + 48) = v45;
          if ( (v31 & 0x80000000) == 0 )
          {
LABEL_31:
            *(_QWORD *)(a1 + 56) = -1LL;
            if ( v32 - v33 < 2 )
              goto LABEL_138;
            goto LABEL_32;
          }
        }
        else
        {
          v33 = 2LL;
          *(_QWORD *)(a1 + 48) = -1LL;
          if ( (v31 & 0x80000000) == 0 )
            goto LABEL_31;
        }
        v62 = *(_DWORD *)(a1 + 4);
        if ( !v62 )
          *(_QWORD *)(a1 + 8) = 0LL;
        if ( v33 <= v32 )
          v63 = v32;
        else
          v63 = v33;
        v64 = v62 + 7;
        while ( 1 )
        {
          if ( v63 == v33 )
            goto LABEL_138;
          v65 = *(unsigned __int8 *)(v8 + v33++);
          v66 = ((unsigned __int64)(v65 & 0x7F) << ((unsigned __int8)v64 - 7)) | *(_QWORD *)(a1 + 8);
          *(_QWORD *)(a1 + 168) = v33;
          *(_QWORD *)(a1 + 8) = v66;
          if ( (v65 & 0x80) == 0 )
            break;
          *(_DWORD *)(a1 + 4) = v64;
          v64 += 7;
          result = 7LL;
          if ( v64 == 70 )
            goto LABEL_140;
        }
        if ( v64 != 7 && !v65 )
          goto LABEL_138;
        *(_DWORD *)(a1 + 4) = 0;
        *(_QWORD *)(a1 + 56) = v66;
        if ( v32 - v33 < 2 )
          goto LABEL_138;
LABEL_32:
        *(_QWORD *)(a1 + 168) = v33 + 1;
        if ( *(_BYTE *)(a1 + 168 + v33 + 16) != 33 )
          goto LABEL_116;
        v34 = v33 + 2;
        *(_QWORD *)(a1 + 168) = v33 + 2;
        if ( *(_BYTE *)(a1 + 168 + v33 + 1 + 16) != 1 )
          goto LABEL_116;
        if ( v32 == v34 )
          goto LABEL_138;
        *(_QWORD *)(a1 + 168) = v33 + 3;
        result = sub_16A14(*(_QWORD *)(a1 + 1208), *(_BYTE *)(a1 + 168 + v34 + 16));
        if ( (_DWORD)result )
          goto LABEL_140;
        v36 = *(_QWORD *)(a1 + 168);
        v37 = *(_QWORD *)(a1 + 176);
        if ( v36 > v37 )
          v37 = *(_QWORD *)(a1 + 168);
        while ( v37 != v36 )
        {
          *(_QWORD *)(a1 + 168) = v36 + 1;
          if ( *(unsigned __int8 *)(v8 + v36++) )
            goto LABEL_116;
        }
        *(_QWORD *)(a1 + 168) = 0LL;
        *v7 = 0LL;
        *(_QWORD *)(a1 + 80) = 0LL;
        *(_DWORD *)a1 = 3;
LABEL_55:
        v46 = *(_QWORD *)(a1 + 1208);
        *(_QWORD *)(a1 + 16) = a2[1];
        *(_QWORD *)(a1 + 24) = a2[4];
        result = sub_1620C(v46, a2);
        v47 = *(_QWORD *)(a1 + 24);
        v48 = *(_QWORD *)(a1 + 80);
        v49 = *(_QWORD *)(a1 + 48);
        v50 = *(_QWORD *)(a1 + 72) + a2[1] - *(_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 72) = v50;
        v51 = v48 + a2[4] - v47;
        *(_QWORD *)(a1 + 80) = v51;
        if ( v50 > v49 )
          goto LABEL_138;
        v52 = *(_QWORD *)(a1 + 56);
        if ( v51 > v52 )
          goto LABEL_138;
        if ( (_DWORD)result != 1 )
          goto LABEL_140;
        if ( v49 != -1LL && v49 != v50 || v52 != -1LL && v52 != v51 )
        {
LABEL_138:
          result = 7LL;
          goto LABEL_140;
        }
        v53 = *(_DWORD *)(a1 + 36);
        v54 = v50 + *(unsigned int *)(a1 + 64) + *(_QWORD *)(a1 + 96);
        *(_QWORD *)(a1 + 96) = v54;
        if ( v53 == 1 )
          *(_QWORD *)(a1 + 96) = v54 + 4;
        v55 = *(_QWORD *)(a1 + 104);
        v56 = *(_QWORD *)(a1 + 88);
        *(_DWORD *)a1 = 4;
        *(_QWORD *)(a1 + 104) = v55 + v51;
        *(_QWORD *)(a1 + 88) = v56 + 1;
        if ( (v50 & 3) != 0 )
        {
LABEL_65:
          do
          {
            v57 = a2[1];
            if ( v57 == a2[2] )
              goto LABEL_139;
            v58 = *a2;
            a2[1] = v57 + 1;
            if ( *(_BYTE *)(v58 + v57) )
              goto LABEL_138;
            v59 = *v7 + 1;
            *v7 = v59;
          }
          while ( (v59 & 3) != 0 );
        }
LABEL_68:
        *(_DWORD *)a1 = 5;
LABEL_69:
        if ( *(_DWORD *)(a1 + 36) == 1 )
        {
          do
          {
            v60 = a2[1];
            if ( v60 == a2[2] )
              goto LABEL_139;
            a2[1] = v60 + 1;
            v61 = *(_DWORD *)(a1 + 4) + 8;
            *(_DWORD *)(a1 + 4) = v61;
          }
          while ( v61 < 0x20 );
          *(_DWORD *)(a1 + 32) = 0;
          *(_DWORD *)(a1 + 4) = 0;
        }
        v2 = 1;
        *(_DWORD *)a1 = 1;
        continue;
      case 1:
        goto LABEL_16;
      case 2:
        v22 = *(_QWORD *)(a1 + 168);
        v23 = *(_QWORD *)(a1 + 176);
        goto LABEL_20;
      case 3:
        goto LABEL_55;
      case 4:
        if ( (*v7 & 3) == 0 )
          goto LABEL_68;
        goto LABEL_65;
      case 5:
        goto LABEL_69;
      case 6:
        v67 = *(_DWORD *)(a1 + 4) == 0;
        while ( 2 )
        {
          v68 = *a2;
          v69 = a2[2];
          if ( v67 )
            *(_QWORD *)(a1 + 8) = 0LL;
          while ( 2 )
          {
            v70 = a2[1];
            if ( v70 >= v69 )
            {
              result = 0LL;
LABEL_119:
              *(_QWORD *)(a1 + 128) += a2[1] - *(_QWORD *)(a1 + 16);
              goto LABEL_140;
            }
            v71 = *(unsigned __int8 *)(v68 + v70);
            a2[1] = v70 + 1;
            v72 = *(_DWORD *)(a1 + 4);
            v73 = ((unsigned __int64)(v71 & 0x7F) << v72) | *(_QWORD *)(a1 + 8);
            *(_QWORD *)(a1 + 8) = v73;
            if ( (v71 & 0x80) != 0 )
            {
              *(_DWORD *)(a1 + 4) = v72 + 7;
              if ( v72 == 56 )
                goto LABEL_118;
              continue;
            }
            break;
          }
          if ( !v71 && v72 )
          {
LABEL_118:
            result = 7LL;
            goto LABEL_119;
          }
          v74 = *(_DWORD *)(a1 + 120);
          *(_DWORD *)(a1 + 4) = 0;
          if ( v74 == 2 )
          {
            v76 = *(_QWORD *)(a1 + 152);
            v77 = *(_QWORD *)(a1 + 136);
            *(_DWORD *)(a1 + 120) = 1;
            v78 = v76 + v73;
            v73 = v77 - 1;
            *(_QWORD *)(a1 + 152) = v78;
            *(_QWORD *)(a1 + 136) = v77 - 1;
            goto LABEL_108;
          }
          if ( v74 == 1 )
          {
            v79 = *(_QWORD *)(a1 + 144);
            *(_DWORD *)(a1 + 120) = 2;
            *(_QWORD *)(a1 + 144) = v79 + v73;
            goto LABEL_107;
          }
          if ( v74 )
          {
LABEL_107:
            v73 = *(_QWORD *)(a1 + 136);
            goto LABEL_108;
          }
          v75 = *(_QWORD *)(a1 + 88);
          *(_QWORD *)(a1 + 136) = v73;
          if ( v73 != v75 )
            goto LABEL_138;
          *(_DWORD *)(a1 + 120) = 1;
LABEL_108:
          v67 = 1;
          if ( v73 )
            continue;
          break;
        }
        *(_DWORD *)a1 = 7;
LABEL_110:
        v80 = a2[1];
        while ( 1 )
        {
          v81 = *(_QWORD *)(a1 + 128);
          v82 = *(_QWORD *)(a1 + 16);
          if ( (((_BYTE)v80 + (_BYTE)v81 - (_BYTE)v82) & 3) == 0 )
            break;
          if ( v80 == a2[2] )
          {
            result = 0LL;
            *(_QWORD *)(a1 + 128) = v81 - v82 + v80;
            goto LABEL_140;
          }
          v83 = *a2;
          a2[1] = v80 + 1;
          LODWORD(v83) = *(unsigned __int8 *)(v83 + v80++);
          if ( (_DWORD)v83 )
            goto LABEL_138;
        }
        v85 = v81 - v82 + v80;
        v86 = *(_QWORD *)(a1 + 96) ^ *(_QWORD *)(a1 + 144) | *(_QWORD *)(a1 + 104) ^ *(_QWORD *)(a1 + 152) | *(_QWORD *)(a1 + 112) ^ *(_QWORD *)(a1 + 160);
        *(_QWORD *)(a1 + 128) = v85;
        if ( v86 )
          goto LABEL_138;
        *(_DWORD *)a1 = 8;
LABEL_122:
        while ( 1 )
        {
          v87 = a2[1];
          if ( v87 == a2[2] )
            break;
          a2[1] = v87 + 1;
          v88 = *(_DWORD *)(a1 + 4) + 8;
          *(_DWORD *)(a1 + 4) = v88;
          if ( v88 >= 0x20 )
          {
            v84 = 12LL;
            *(_DWORD *)(a1 + 32) = 0;
            *(_QWORD *)(a1 + 176) = 12LL;
            *(_QWORD *)a1 = 9LL;
LABEL_125:
            v89 = a2[1];
            v91 = (_QWORD *)(a1 + 168);
            v90 = *(_QWORD *)(a1 + 168);
            v92 = v84 - v90;
            v93 = a1 + 168 + v90;
            if ( a2[2] - v89 >= v92 )
              v94 = v92;
            else
              v94 = a2[2] - v89;
            memcpy((void *)(v93 + 16), (const void *)(*a2 + v89), v94);
            a2[1] += v94;
            v95 = *(_QWORD *)(a1 + 176);
            v96 = *v91 + v94;
            v97 = v96 == v95;
            if ( v96 == v95 )
              v96 = 0LL;
            *v91 = v96;
            if ( !v97 )
              break;
            if ( *(_WORD *)(a1 + 194) != 23129 || *(_DWORD *)(a1 + 188) != *(_QWORD *)(a1 + 128) >> 2 )
              goto LABEL_138;
            result = 7LL;
            if ( !*(_BYTE *)(a1 + 192) )
            {
              if ( *(_DWORD *)(a1 + 36) == *(unsigned __int8 *)(a1 + 193) )
                result = 1LL;
              else
                result = 7LL;
            }
            goto LABEL_140;
          }
        }
LABEL_139:
        result = 0LL;
LABEL_140:
        if ( !*(_DWORD *)(a1 + 40) )
        {
          if ( (_DWORD)result )
          {
            if ( (_DWORD)result == 1 )
              return result;
          }
          else if ( a2[1] == a2[2] )
          {
            result = 7LL;
          }
          else
          {
            result = 8LL;
          }
          a2[1] = v5;
          a2[4] = v6;
          return result;
        }
        if ( !(_DWORD)result && v5 == a2[1] && v6 == a2[4] )
        {
          v98 = *(unsigned __int8 *)(a1 + 44);
          *(_BYTE *)(a1 + 44) = 1;
          result = (unsigned int)(8 * v98);
        }
        else
        {
          *(_BYTE *)(a1 + 44) = 0;
        }
        return result;
      case 7:
        goto LABEL_110;
      case 8:
        goto LABEL_122;
      case 9:
        v84 = *(_QWORD *)(a1 + 176);
        goto LABEL_125;
      default:
        continue;
    }
  }
}

//----- (0000000000016154) ----------------------------------------------------
char *__fastcall sub_16154(int a1, unsigned int a2)
{
  char *v4; // x19
  __int64 v5; // x0

  v4 = (char *)__wrap_malloc(1216LL);
  if ( !v4 )
    return v4;
  *((_DWORD *)v4 + 10) = a1;
  v5 = sub_16988(a1, a2);
  *((_QWORD *)v4 + 151) = v5;
  if ( v5 )
  {
    v4[44] = 0;
    *(_QWORD *)v4 = 0LL;
    *((_DWORD *)v4 + 8) = 0;
    *(_OWORD *)(v4 + 72) = 0u;
    *(_OWORD *)(v4 + 88) = 0u;
    *(_OWORD *)(v4 + 104) = 0u;
    *(_OWORD *)(v4 + 120) = 0u;
    *(_OWORD *)(v4 + 136) = 0u;
    *(_OWORD *)(v4 + 152) = 0u;
    *((_QWORD *)v4 + 21) = 0LL;
    *((_QWORD *)v4 + 22) = 12LL;
    return v4;
  }
  free(v4);
  return 0LL;
}
// 18890: using guessed type __int64 __fastcall __wrap_malloc(_QWORD);

//----- (00000000000161E8) ----------------------------------------------------
void __fastcall sub_161E8(void **a1)
{
  if ( a1 )
  {
    sub_16AD4(a1[151]);
    free(a1);
  }
}

//----- (000000000001620C) ----------------------------------------------------
__int64 __fastcall sub_1620C(__int64 a1, _QWORD *a2)
{
  __int64 v4; // x25
  __int128 v5; // q1
  __int64 v6; // x28
  void *v7; // x21
  unsigned __int64 v8; // x8
  unsigned __int64 v9; // x10
  int v10; // w9
  __int64 v11; // x9
  unsigned int v12; // w8
  unsigned int v13; // w29
  __int64 v14; // x12
  unsigned __int64 v15; // x8
  __int64 v16; // x8
  __int64 v17; // x8
  __int64 v18; // x27
  unsigned __int64 v19; // x9
  unsigned __int64 v20; // x10
  unsigned __int64 v21; // x22
  unsigned int v22; // w8
  unsigned __int64 v23; // x9
  unsigned __int64 v24; // x8
  __int64 v25; // x8
  unsigned __int64 v26; // x9
  unsigned __int64 v27; // x10
  __int64 v28; // x9
  __int64 v29; // x8
  __int64 v30; // x9
  __int64 v31; // x22
  int v32; // w8
  __int64 v33; // x9
  __int64 v34; // x9
  __int64 v35; // x9
  __int64 v36; // x9
  int v37; // w8
  __int64 v38; // x9
  unsigned int v39; // w8
  char v40; // w10
  char v41; // w9
  unsigned int v42; // w9
  unsigned __int64 v43; // x11
  unsigned __int64 v44; // x12
  bool v45; // cf
  unsigned __int64 v46; // x11
  unsigned __int64 v47; // x8
  __int64 v48; // x12
  unsigned __int64 v49; // x22
  unsigned __int64 v50; // x9
  unsigned __int64 v51; // x8
  int v52; // w9
  unsigned __int8 v53; // w8
  unsigned int v54; // w9
  unsigned int v55; // w9
  __int64 v56; // x8
  __int64 v57; // x9
  unsigned int v58; // w8
  __int64 v59; // x8
  __int64 v60; // x10
  int v61; // w9
  int v62; // w11
  __int64 v63; // x8
  __int64 v64; // x9
  _OWORD *v66; // [xsp+8h] [xbp-78h]

  v66 = (_OWORD *)(a1 + 48);
  v4 = a1 + 124;
  *(_QWORD *)&v5 = 0x400040004000400LL;
  *((_QWORD *)&v5 + 1) = 0x400040004000400LL;
  v6 = a1 + 28416;
  v7 = (void *)(a1 + 28432);
  while ( 2 )
  {
    while ( 1 )
    {
      v8 = a2[1];
      v9 = a2[2];
      v10 = *(_DWORD *)(a1 + 104);
      if ( v8 < v9 )
        break;
      if ( v10 != 7 )
        return 0LL;
LABEL_12:
      v13 = *(_DWORD *)(a1 + 116);
LABEL_13:
      v14 = *(_QWORD *)(a1 + 56);
      v15 = a2[5] - a2[4];
      if ( v15 >= *(unsigned int *)(a1 + 112) )
        v15 = *(unsigned int *)(a1 + 112);
      if ( *(_QWORD *)(a1 + 80) - v14 <= v15 )
        v16 = *(_QWORD *)(a1 + 80);
      else
        v16 = v15 + v14;
      *(_QWORD *)(a1 + 72) = v16;
      v17 = a2[1];
      v18 = *(unsigned int *)(v6 + 12);
      v19 = a2[2] - v17;
      if ( (_DWORD)v18 || !v13 )
      {
        LODWORD(v20) = 42 - v18;
        if ( 42 - (int)v18 <= v13 - (unsigned int)v18 )
          v20 = (unsigned int)v20;
        else
          v20 = v13 - (unsigned int)v18;
        if ( v19 >= v20 )
          v21 = (unsigned int)v20;
        else
          v21 = (unsigned int)v19;
        memcpy((void *)(a1 + v18 + 28432), (const void *)(*a2 + v17), v21);
        v22 = v21 + v18;
        if ( (_DWORD)v21 + (_DWORD)v18 == v13 )
        {
          memset((void *)(a1 + v18 + 28432 + v21), 0, 63 - (v18 + v21));
        }
        else
        {
          if ( v22 <= 0x14 )
          {
            *(_DWORD *)(v6 + 12) = v22;
LABEL_48:
            a2[1] += v21;
            goto LABEL_49;
          }
          v13 = v22 - 21;
        }
        *(_QWORD *)(a1 + 24) = 0LL;
        *(_QWORD *)(a1 + 32) = v13;
        *(_QWORD *)(a1 + 16) = v7;
        if ( (sub_16AF8(a1) & 1) == 0 )
          return 7LL;
        v23 = *(unsigned int *)(v6 + 12);
        v24 = *(_QWORD *)(a1 + 24);
        if ( v24 > (unsigned int)(v23 + v21) )
          return 7LL;
        *(_DWORD *)(a1 + 116) -= v24;
        if ( v24 < v23 )
        {
          *(_DWORD *)(v6 + 12) = v23 - v24;
          memmove(v7, (const void *)(a1 + v24 + 28432), v23 - v24);
          goto LABEL_49;
        }
        a2[1] += v24 - v23;
        *(_DWORD *)(v6 + 12) = 0;
        v17 = a2[1];
        v19 = a2[2] - v17;
        if ( v19 < 0x15 )
          goto LABEL_44;
      }
      else if ( v19 < 0x15 )
      {
        goto LABEL_44;
      }
      v25 = *(unsigned int *)(a1 + 116);
      *(_QWORD *)(a1 + 16) = *a2;
      *(_QWORD *)(a1 + 24) = a2[1];
      if ( v19 >= (unsigned int)(v25 + 21) )
      {
        *(_QWORD *)(a1 + 32) = a2[1] + v25;
        if ( (sub_16AF8(a1) & 1) == 0 )
          return 7LL;
      }
      else
      {
        *(_QWORD *)(a1 + 32) = a2[2] - 21LL;
        if ( (sub_16AF8(a1) & 1) == 0 )
          return 7LL;
      }
      v17 = *(_QWORD *)(a1 + 24);
      v26 = *(unsigned int *)(a1 + 116);
      v27 = v17 - a2[1];
      if ( v27 > v26 )
        return 7LL;
      *(_DWORD *)(a1 + 116) = v26 - v27;
      v28 = a2[2];
      a2[1] = v17;
      v19 = v28 - v17;
      if ( v19 <= 0x14 )
      {
LABEL_44:
        if ( v19 <= *(unsigned int *)(a1 + 116) )
          v21 = v19;
        else
          v21 = *(unsigned int *)(a1 + 116);
        memcpy(v7, (const void *)(*a2 + v17), v21);
        *(_DWORD *)(v6 + 12) = v21;
        goto LABEL_48;
      }
LABEL_49:
      v29 = *(_QWORD *)(a1 + 48);
      v30 = *(_QWORD *)(a1 + 56);
      v31 = v30 - v29;
      if ( *(_DWORD *)(a1 + 100) )
      {
        if ( v30 == *(_QWORD *)(a1 + 80) )
          *(_QWORD *)(a1 + 56) = 0LL;
        memcpy((void *)(a2[3] + a2[4]), (const void *)(*(_QWORD *)(a1 + 40) + v29), v31);
        v30 = *(_QWORD *)(a1 + 56);
      }
      *(_QWORD *)(a1 + 48) = v30;
      *(_QWORD *)&v5 = 0x400040004000400LL;
      *((_QWORD *)&v5 + 1) = 0x400040004000400LL;
      a2[4] += v31;
      v32 = *(_DWORD *)(a1 + 112) - v31;
      *(_DWORD *)(a1 + 112) = v32;
      if ( v32 )
      {
        if ( a2[4] == a2[5] || a2[1] == a2[2] && *(_DWORD *)(v6 + 12) < *(_DWORD *)(a1 + 116) )
          return 0LL;
      }
      else
      {
        if ( *(_DWORD *)(a1 + 116) || *(_DWORD *)(a1 + 144) || *(_DWORD *)(a1 + 4) )
          return 7LL;
        *(_QWORD *)a1 = 0xFFFFFFFFLL;
        *(_DWORD *)(a1 + 8) = 5;
        *(_DWORD *)(a1 + 104) = 0;
      }
    }
    switch ( v10 )
    {
      case 0:
        v11 = *a2;
        a2[1] = v8 + 1;
        v12 = *(unsigned __int8 *)(v11 + v8);
        if ( v12 )
        {
          if ( v12 > 0xDF || v12 == 1 )
          {
            v52 = *(_DWORD *)(a1 + 100);
            *(_WORD *)(a1 + 120) = 256;
            if ( !v52 )
            {
              *(_QWORD *)(a1 + 40) = a2[3] + a2[4];
              *(_QWORD *)(a1 + 80) = a2[5] - a2[4];
            }
            *v66 = 0u;
            v66[1] = 0u;
            if ( ((char)v12 & 0x80000000) == 0 )
              goto LABEL_9;
LABEL_93:
            *(_DWORD *)(a1 + 112) = (v12 & 0x1F) << 16;
            *(_DWORD *)(a1 + 104) = 1;
            if ( v12 < 0xC0 )
            {
              if ( *(_BYTE *)(a1 + 121) )
                return 7LL;
              *(_DWORD *)(a1 + 108) = 6;
              if ( v12 >= 0xA0 )
              {
                v63 = -28256LL;
                *(_QWORD *)v4 = 0LL;
                *(_QWORD *)(v4 + 8) = 0LL;
                *(_DWORD *)(v4 + 16) = 0;
                do
                {
                  v64 = a1 + v63;
                  v63 += 32LL;
                  *(_OWORD *)(v64 + 28416) = v5;
                  *(_OWORD *)(v64 + 28432) = v5;
                }
                while ( v63 );
                *(_QWORD *)v6 = 0x400040004000400LL;
                *(_DWORD *)(v6 + 8) = 67109888;
                *(_QWORD *)a1 = 0xFFFFFFFFLL;
                *(_DWORD *)(a1 + 8) = 5;
              }
            }
            else
            {
              *(_BYTE *)(a1 + 121) = 0;
              *(_DWORD *)(a1 + 108) = 5;
            }
          }
          else
          {
            if ( *(_BYTE *)(a1 + 120) )
              return 7LL;
            if ( ((char)v12 & 0x80000000) != 0 )
              goto LABEL_93;
LABEL_9:
            if ( v12 > 2 )
              return 7LL;
            *(_QWORD *)(a1 + 104) = 0x800000003LL;
          }
          continue;
        }
        return 1LL;
      case 1:
        v33 = *a2;
        a2[1] = v8 + 1;
        *(_DWORD *)(a1 + 112) += *(unsigned __int8 *)(v33 + v8) << 8;
        *(_DWORD *)(a1 + 104) = 2;
        continue;
      case 2:
        v34 = *a2;
        a2[1] = v8 + 1;
        *(_DWORD *)(a1 + 112) += *(unsigned __int8 *)(v34 + v8) + 1;
        *(_DWORD *)(a1 + 104) = 3;
        continue;
      case 3:
        v35 = *a2;
        a2[1] = v8 + 1;
        *(_DWORD *)(a1 + 116) = *(unsigned __int8 *)(v35 + v8) << 8;
        *(_DWORD *)(a1 + 104) = 4;
        continue;
      case 4:
        v36 = *a2;
        a2[1] = v8 + 1;
        v37 = *(unsigned __int8 *)(v36 + v8);
        LODWORD(v36) = *(_DWORD *)(a1 + 108);
        *(_DWORD *)(a1 + 116) += v37 + 1;
        *(_DWORD *)(a1 + 104) = v36;
        continue;
      case 5:
        v38 = *a2;
        a2[1] = v8 + 1;
        v39 = *(unsigned __int8 *)(v38 + v8);
        if ( v39 > 0xE0 )
          return 7LL;
        if ( v39 < 0x2D )
        {
          v41 = 0;
        }
        else
        {
          v40 = (unsigned __int8)(v39 - 45) / 0x2Du;
          LOBYTE(v39) = (unsigned __int8)(v39 - 45) % 0x2Du;
          v41 = v40 + 1;
        }
        *(_DWORD *)(a1 + 156) = ~(-1 << v41);
        if ( (unsigned __int8)v39 < 9u )
        {
          v55 = 0;
        }
        else
        {
          v53 = v39 - 9;
          v54 = v53 / 9u;
          LOBYTE(v39) = v53 % 9u;
          v55 = v54 + 1;
        }
        *(_DWORD *)(a1 + 148) = (unsigned __int8)v39;
        *(_DWORD *)(a1 + 152) = v55;
        if ( v55 + (unsigned __int8)v39 > 4 )
          return 7LL;
        *(_DWORD *)(a1 + 152) = ~(-1 << v55);
        v56 = -28256LL;
        *(_QWORD *)v4 = 0LL;
        *(_QWORD *)(v4 + 8) = 0LL;
        *(_DWORD *)(v4 + 16) = 0;
        do
        {
          v57 = a1 + v56;
          v56 += 32LL;
          *(_OWORD *)(v57 + 28416) = v5;
          *(_OWORD *)(v57 + 28432) = v5;
        }
        while ( v56 );
        *(_QWORD *)v6 = 0x400040004000400LL;
        *(_DWORD *)(v6 + 8) = 67109888;
        *(_DWORD *)(a1 + 8) = 5;
        *(_QWORD *)a1 = 0xFFFFFFFFLL;
        *(_DWORD *)(a1 + 104) = 6;
        goto LABEL_103;
      case 6:
LABEL_103:
        v58 = *(_DWORD *)(a1 + 116);
        if ( v58 < 5 )
          return 7LL;
        if ( !*(_DWORD *)(a1 + 8) )
          goto LABEL_108;
        do
        {
          v59 = a2[1];
          if ( v59 == a2[2] )
            return 0LL;
          v60 = *a2;
          v61 = *(_DWORD *)(a1 + 4);
          a2[1] = v59 + 1;
          v62 = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v60 + v59) | (v61 << 8);
          *(_DWORD *)(a1 + 8) = v62 - 1;
        }
        while ( v62 != 1 );
        v58 = *(_DWORD *)(a1 + 116);
LABEL_108:
        v13 = v58 - 5;
        *(_DWORD *)(a1 + 116) = v58 - 5;
        *(_DWORD *)(a1 + 104) = 7;
        goto LABEL_13;
      case 7:
        goto LABEL_12;
      case 8:
        v42 = *(_DWORD *)(a1 + 116);
        if ( !v42 )
          goto LABEL_89;
        if ( v9 <= v8 )
          return 0LL;
        while ( 2 )
        {
          v43 = a2[4];
          v44 = a2[5];
          v45 = v44 >= v43;
          v46 = v44 - v43;
          if ( v46 == 0 || !v45 )
            return 0LL;
          v47 = v9 - v8;
          v48 = *(_QWORD *)(a1 + 56);
          if ( v47 >= v46 )
            v47 = v46;
          if ( v47 > *(_QWORD *)(a1 + 80) - v48 )
            v47 = *(_QWORD *)(a1 + 80) - v48;
          if ( v47 <= v42 )
            v49 = v47;
          else
            v49 = v42;
          *(_DWORD *)(a1 + 116) = v42 - v49;
          memcpy((void *)(*(_QWORD *)(a1 + 40) + v48), (const void *)(*a2 + a2[1]), v49);
          v50 = *(_QWORD *)(a1 + 64);
          v51 = *(_QWORD *)(a1 + 56) + v49;
          *(_QWORD *)(a1 + 56) = v51;
          if ( v50 < v51 )
            *(_QWORD *)(a1 + 64) = v51;
          *(_QWORD *)&v5 = 0x400040004000400LL;
          *((_QWORD *)&v5 + 1) = 0x400040004000400LL;
          if ( *(_DWORD *)(a1 + 100) )
          {
            if ( v51 == *(_QWORD *)(a1 + 80) )
              *(_QWORD *)(a1 + 56) = 0LL;
            memcpy((void *)(a2[3] + a2[4]), (const void *)(*a2 + a2[1]), v49);
            v51 = *(_QWORD *)(a1 + 56);
            *(_QWORD *)&v5 = 0x400040004000400LL;
            *((_QWORD *)&v5 + 1) = 0x400040004000400LL;
          }
          *(_QWORD *)(a1 + 48) = v51;
          v8 = a2[1] + v49;
          a2[4] += v49;
          a2[1] = v8;
          v42 = *(_DWORD *)(a1 + 116);
          if ( v42 )
          {
            v9 = a2[2];
            if ( v9 <= v8 )
              return 0LL;
            continue;
          }
          break;
        }
LABEL_89:
        *(_DWORD *)(a1 + 104) = 0;
        continue;
      default:
        continue;
    }
  }
}

//----- (0000000000016988) ----------------------------------------------------
__int64 __fastcall sub_16988(int a1, unsigned int a2)
{
  __int64 result; // x0
  _QWORD *v5; // x19
  __int64 v6; // x0

  result = __wrap_malloc(28496LL);
  v5 = (_QWORD *)result;
  if ( !result )
    return (__int64)v5;
  *(_DWORD *)(result + 100) = a1;
  *(_DWORD *)(result + 92) = a2;
  if ( a1 == 2 )
  {
    *(_QWORD *)(result + 40) = 0LL;
    *(_DWORD *)(result + 96) = 0;
  }
  else
  {
    if ( a1 != 1 )
      return (__int64)v5;
    v6 = __wrap_malloc(a2);
    v5[5] = v6;
    if ( v6 )
      return (__int64)v5;
    free(v5);
    result = 0LL;
  }
  return result;
}
// 18890: using guessed type __int64 __fastcall __wrap_malloc(_QWORD);

//----- (0000000000016A14) ----------------------------------------------------
__int64 __fastcall sub_16A14(__int64 a1, unsigned __int8 a2)
{
  __int64 result; // x0
  int v3; // w9
  unsigned int v5; // w8
  __int64 v6; // x0

  if ( a2 > 0x27u )
    return 6LL;
  v3 = *(_DWORD *)(a1 + 100);
  v5 = (a2 & 1 | 2) << ((a2 >> 1) + 11);
  *(_DWORD *)(a1 + 88) = v5;
  if ( !v3 )
    goto LABEL_9;
  if ( v5 > *(_DWORD *)(a1 + 92) )
    return 4LL;
  *(_QWORD *)(a1 + 80) = v5;
  if ( v3 == 2
    && *(_DWORD *)(a1 + 96) < v5
    && (free(*(void **)(a1 + 40)), v6 = __wrap_malloc(*(unsigned int *)(a1 + 88)), (*(_QWORD *)(a1 + 40) = v6) == 0LL) )
  {
    *(_DWORD *)(a1 + 96) = 0;
    result = 3LL;
  }
  else
  {
LABEL_9:
    result = 0LL;
    *(_DWORD *)(a1 + 144) = 0;
    *(_DWORD *)(a1 + 104) = 0;
    *(_BYTE *)(a1 + 120) = 1;
    *(_DWORD *)(a1 + 28428) = 0;
  }
  return result;
}
// 18890: using guessed type __int64 __fastcall __wrap_malloc(_QWORD);

//----- (0000000000016AD4) ----------------------------------------------------
void __fastcall sub_16AD4(void *ptr)
{
  if ( *((_DWORD *)ptr + 25) )
    free(*((void **)ptr + 5));
  free(ptr);
}

//----- (0000000000016AF8) ----------------------------------------------------
__int64 __fastcall sub_16AF8(__int64 a1)
{
  unsigned __int64 v1; // x8
  unsigned __int64 v2; // x9
  unsigned __int64 v4; // x10
  unsigned __int64 v5; // x9
  unsigned __int64 v6; // x11
  unsigned __int64 v7; // x9
  __int64 v8; // x11
  int v9; // w10
  char v10; // w12
  __int64 v11; // x12
  __int64 v12; // x13
  char v13; // w8
  unsigned __int64 v14; // x9
  __int64 v15; // x10
  unsigned int v16; // w15
  __int64 v17; // x2
  _WORD *v18; // x13
  __int64 v19; // x11
  unsigned int v20; // w11
  int v21; // w16
  unsigned int v22; // w12
  unsigned int v23; // w14
  unsigned __int64 v24; // x13
  unsigned __int64 v25; // x16
  unsigned int v26; // w12
  _WORD *v27; // x11
  __int64 v28; // x8
  int v29; // w13
  unsigned int v30; // w15
  unsigned int v31; // w8
  __int64 v32; // x9
  int v33; // w10
  unsigned int v34; // w8
  unsigned int v35; // w10
  unsigned int v36; // w11
  __int64 v37; // x9
  unsigned int v38; // w12
  _WORD *v39; // x12
  __int64 v40; // x8
  __int64 v41; // x13
  int v42; // w14
  unsigned int v43; // w8
  unsigned int v44; // w13
  unsigned int v45; // w14
  unsigned int v46; // w13
  _WORD *v47; // x11
  __int64 v48; // x12
  int v49; // w15
  unsigned int v50; // w12
  unsigned int v51; // w14
  _WORD *v52; // x11
  __int64 v53; // x13
  int v54; // w9
  unsigned int v55; // w13
  bool v56; // cf
  unsigned int v57; // w8
  int v58; // w8
  int v59; // w9
  unsigned int v60; // w13
  bool v61; // cc
  __int64 v62; // x10
  unsigned int i; // w13
  _WORD *v64; // x14
  __int64 v65; // x15
  unsigned int v66; // w15
  unsigned int v67; // w16
  __int64 v68; // x14
  unsigned __int64 v69; // x13
  unsigned int v70; // w9
  unsigned int v71; // w11
  int v72; // w9
  unsigned int v73; // w11
  unsigned int v74; // w9
  __int64 v75; // x13
  unsigned int v76; // w9
  int v77; // w8
  __int64 v78; // x11
  __int64 v79; // x12
  unsigned int v80; // w13
  __int64 v81; // x13
  __int64 v82; // x14
  int v83; // w15
  unsigned int v84; // w14
  unsigned int v85; // w13
  unsigned int v86; // w12
  _WORD *v87; // x8
  __int64 v88; // x11
  int v89; // w11
  unsigned int v90; // w15
  unsigned int v91; // w13
  int v92; // w8
  unsigned int v93; // w11
  __int64 v94; // x13
  __int64 v95; // x14
  unsigned int v96; // w12
  int v97; // w8
  unsigned int v98; // w11
  _WORD *v99; // x8
  __int64 v100; // x12
  int v101; // w9
  unsigned int v102; // w12
  unsigned int v103; // w13
  int v104; // w9
  __int64 v105; // x11
  __int64 v106; // x12
  int v107; // w13
  unsigned int v108; // w11
  unsigned int v109; // w12
  int v110; // w13
  _WORD *v111; // x14
  unsigned __int64 v112; // x15
  unsigned __int64 v113; // x15
  __int64 v114; // x17
  unsigned __int64 v115; // x17
  int v116; // w15
  int v117; // w16
  char v118; // w1
  unsigned int v119; // w2
  int v120; // w17
  _WORD *v121; // x0
  __int64 v122; // x1
  unsigned int v123; // w2
  unsigned int v124; // w3
  int v125; // w9
  int v126; // w8
  unsigned __int64 v127; // x8
  unsigned __int64 v128; // x9
  unsigned __int64 v129; // x11
  unsigned __int64 v130; // x10
  unsigned __int64 v131; // x8
  __int64 v132; // x11
  int v133; // w10
  char v134; // w12
  __int64 v135; // x12
  __int64 v136; // x13
  char v137; // w9
  __int64 v138; // x10
  __int64 v139; // x12
  unsigned int v140; // w12
  unsigned int v141; // w10
  unsigned int v142; // w15
  __int16 v143; // w11
  unsigned int v144; // w12
  _WORD *v145; // x13
  __int64 v146; // x11
  __int64 v147; // x14
  unsigned int v148; // w15
  unsigned int v149; // w11
  unsigned int v150; // w14
  _WORD *v151; // x10
  __int64 v152; // x12
  __int64 v153; // x13
  unsigned int v154; // w12
  unsigned int v155; // w13
  unsigned int v156; // w8
  __int64 v157; // x9
  __int64 v158; // x10
  int v159; // w11

  v1 = *(_QWORD *)(a1 + 56);
  v2 = *(_QWORD *)(a1 + 72);
  v4 = v2 - v1;
  if ( v2 > v1 )
  {
    v5 = *(unsigned int *)(a1 + 144);
    if ( (_DWORD)v5 )
    {
      v6 = *(unsigned int *)(a1 + 124);
      if ( *(_QWORD *)(a1 + 64) > v6 && *(_DWORD *)(a1 + 88) > (unsigned int)v6 )
      {
        if ( v4 >= v5 )
          LODWORD(v4) = *(_DWORD *)(a1 + 144);
        *(_DWORD *)(a1 + 144) = v5 - v4;
        v7 = v1 + ~v6;
        if ( v1 <= v6 )
          v7 += *(_QWORD *)(a1 + 80);
        v8 = *(_QWORD *)(a1 + 40);
        v9 = v4 - 1;
        v10 = *(_BYTE *)(v8 + v7);
        *(_QWORD *)(a1 + 56) = v1 + 1;
        for ( *(_BYTE *)(v8 + v1) = v10; v9; *(_BYTE *)(v11 + v12) = v13 )
        {
          v11 = *(_QWORD *)(a1 + 40);
          v12 = *(_QWORD *)(a1 + 56);
          if ( v7 + 1 == *(_QWORD *)(a1 + 80) )
            v7 = 0LL;
          else
            ++v7;
          v13 = *(_BYTE *)(v11 + v7);
          --v9;
          *(_QWORD *)(a1 + 56) = v12 + 1;
        }
        v1 = *(_QWORD *)(a1 + 56);
        if ( *(_QWORD *)(a1 + 64) < v1 )
          *(_QWORD *)(a1 + 64) = v1;
      }
    }
  }
  while ( v1 < *(_QWORD *)(a1 + 72) )
  {
    v14 = *(_QWORD *)(a1 + 24);
    if ( v14 > *(_QWORD *)(a1 + 32) )
      break;
    v15 = *(unsigned int *)(a1 + 140);
    v16 = *(_DWORD *)a1;
    v17 = *(_DWORD *)(a1 + 156) & (unsigned int)v1;
    v18 = (_WORD *)(a1 + 32 * v15 + 2LL * (unsigned int)v17 + 160);
    if ( HIBYTE(*(_DWORD *)a1) )
    {
      v20 = *(_DWORD *)(a1 + 4);
    }
    else
    {
      v19 = *(_QWORD *)(a1 + 16);
      v16 <<= 8;
      *(_DWORD *)a1 = v16;
      *(_QWORD *)(a1 + 24) = v14 + 1;
      LOBYTE(v19) = *(_BYTE *)(v19 + v14++);
      v20 = (unsigned __int8)v19 | (*(_DWORD *)(a1 + 4) << 8);
      *(_DWORD *)(a1 + 4) = v20;
    }
    v21 = (unsigned __int16)*v18;
    v22 = (v16 >> 11) * v21;
    v23 = v20 - v22;
    if ( v20 < v22 )
    {
      *(_DWORD *)a1 = v22;
      *v18 = v21 + ((unsigned int)(2048 - v21) >> 5);
      v24 = v1 - 1;
      if ( v1 )
      {
        v25 = *(_QWORD *)(a1 + 64);
        if ( !v25 )
        {
LABEL_58:
          v60 = 0;
          goto LABEL_59;
        }
      }
      else
      {
        v24 += *(_QWORD *)(a1 + 80);
        v25 = *(_QWORD *)(a1 + 64);
        if ( !v25 )
          goto LABEL_58;
      }
      if ( v24 >= *(_QWORD *)(a1 + 80) )
        goto LABEL_58;
      v60 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 40) + v24);
LABEL_59:
      v61 = (unsigned int)v15 > 6;
      v62 = (v60 >> (8 - *(_DWORD *)(a1 + 148)))
          + (unsigned int)((unsigned __int64)((unsigned int)v1 & *(_DWORD *)(a1 + 152)) << *(_DWORD *)(a1 + 148));
      if ( !v61 )
      {
        for ( i = 1; i < 0x100; i = (2 * i) | 1 )
        {
          while ( 1 )
          {
            v64 = (_WORD *)(a1 + 1536 * v62 + 2LL * i + 3852);
            if ( !HIBYTE(v22) )
            {
              v65 = *(_QWORD *)(a1 + 16);
              v22 <<= 8;
              *(_DWORD *)a1 = v22;
              *(_QWORD *)(a1 + 24) = v14 + 1;
              LOBYTE(v65) = *(_BYTE *)(v65 + v14++);
              v20 = (unsigned __int8)v65 | (v20 << 8);
              *(_DWORD *)(a1 + 4) = v20;
            }
            v66 = (unsigned __int16)*v64;
            v67 = (v22 >> 11) * v66;
            if ( v20 >= v67 )
              break;
            *(_DWORD *)a1 = v67;
            *v64 = v66 + ((2048 - v66) >> 5);
            i *= 2;
            v22 = (v22 >> 11) * v66;
            if ( i >= 0x100 )
              goto LABEL_66;
          }
          v22 -= v67;
          *(_DWORD *)a1 = v22;
          *(_DWORD *)(a1 + 4) = v20 - v67;
          *v64 = v66 - (v66 >> 5);
          v20 -= v67;
        }
LABEL_66:
        v68 = *(_QWORD *)(a1 + 40);
        goto LABEL_72;
      }
      v68 = *(_QWORD *)(a1 + 40);
      if ( v68 )
      {
        LOBYTE(i) = 1;
        if ( v1 <= v25 && *(_QWORD *)(a1 + 48) <= v1 )
        {
          v69 = *(_QWORD *)(a1 + 80);
          if ( v25 > v69 )
            goto LABEL_71;
          v112 = *(unsigned int *)(a1 + 124);
          v61 = v1 > v112;
          v113 = v1 + ~v112;
          if ( v61 )
            v114 = 0LL;
          else
            v114 = *(_QWORD *)(a1 + 80);
          v115 = v113 + v114;
          v116 = 0;
          if ( v115 < v69 && v25 )
            v116 = *(unsigned __int8 *)(v68 + v115);
          i = 1;
          v117 = 256;
          do
          {
            v116 *= 2;
            v120 = v116 & v117;
            v121 = (_WORD *)(a1 + 1536 * v62 + 2LL * ((v116 & v117) + v117 + i) + 3852);
            if ( !HIBYTE(v22) )
            {
              v122 = *(_QWORD *)(a1 + 16);
              v22 <<= 8;
              *(_DWORD *)a1 = v22;
              *(_QWORD *)(a1 + 24) = v14 + 1;
              LOBYTE(v122) = *(_BYTE *)(v122 + v14++);
              v20 = (unsigned __int8)v122 | (v20 << 8);
              *(_DWORD *)(a1 + 4) = v20;
            }
            v123 = (unsigned __int16)*v121;
            v124 = (v22 >> 11) * v123;
            if ( v20 < v124 )
            {
              v118 = 0;
              v119 = v123 + ((2048 - v123) >> 5);
              v22 = v124;
              *(_DWORD *)a1 = v124;
            }
            else
            {
              v22 -= v124;
              v117 = 0;
              v119 = v123 - (v123 >> 5);
              *(_DWORD *)a1 = v22;
              *(_DWORD *)(a1 + 4) = v20 - v124;
              v118 = 1;
              v20 -= v124;
            }
            v117 ^= v120;
            i = v118 & 1 | (2 * i);
            *v121 = v119;
          }
          while ( i < 0x100 );
        }
      }
      else
      {
LABEL_71:
        LOBYTE(i) = 1;
      }
LABEL_72:
      *(_QWORD *)(a1 + 56) = v1 + 1;
      *(_BYTE *)(v68 + v1) = i;
      v1 = *(_QWORD *)(a1 + 56);
      if ( *(_QWORD *)(a1 + 64) < v1 )
        *(_QWORD *)(a1 + 64) = v1;
      v70 = *(_DWORD *)(a1 + 140);
      if ( v70 <= 3 )
      {
        *(_DWORD *)(a1 + 140) = 0;
      }
      else if ( v70 > 9 )
      {
        *(_DWORD *)(a1 + 140) = v70 - 6;
      }
      else
      {
        *(_DWORD *)(a1 + 140) = v70 - 3;
      }
      continue;
    }
    v26 = v16 - v22;
    *(_DWORD *)a1 = v26;
    *(_DWORD *)(a1 + 4) = v23;
    v27 = (_WORD *)(a1 + 2 * v15 + 544);
    *v18 -= *v18 >> 5;
    if ( !HIBYTE(v26) )
    {
      v28 = *(_QWORD *)(a1 + 16);
      v26 <<= 8;
      *(_DWORD *)a1 = v26;
      *(_QWORD *)(a1 + 24) = v14 + 1;
      LOBYTE(v28) = *(_BYTE *)(v28 + v14++);
      v23 = (unsigned __int8)v28 | (v23 << 8);
      *(_DWORD *)(a1 + 4) = v23;
    }
    v29 = (unsigned __int16)*v27;
    v30 = (v26 >> 11) * v29;
    v31 = v23 - v30;
    if ( v23 >= v30 )
    {
      v46 = v26 - v30;
      *(_DWORD *)a1 = v26 - v30;
      *(_DWORD *)(a1 + 4) = v31;
      *v27 -= *v27 >> 5;
      v47 = (_WORD *)(a1 + 2 * v15 + 568);
      if ( !((v26 - v30) >> 24) )
      {
        v48 = *(_QWORD *)(a1 + 16);
        v46 <<= 8;
        *(_DWORD *)a1 = v46;
        *(_QWORD *)(a1 + 24) = v14 + 1;
        LOBYTE(v48) = *(_BYTE *)(v48 + v14++);
        v31 = (unsigned __int8)v48 | (v31 << 8);
        *(_DWORD *)(a1 + 4) = v31;
      }
      v49 = (unsigned __int16)*v47;
      v50 = (v46 >> 11) * v49;
      v51 = v31 - v50;
      if ( v31 >= v50 )
      {
        v86 = v46 - v50;
        *(_DWORD *)a1 = v86;
        *(_DWORD *)(a1 + 4) = v51;
        *v47 -= *v47 >> 5;
        v87 = (_WORD *)(a1 + 2 * v15 + 592);
        if ( !HIBYTE(v86) )
        {
          v88 = *(_QWORD *)(a1 + 16);
          v86 <<= 8;
          *(_DWORD *)a1 = v86;
          *(_QWORD *)(a1 + 24) = v14 + 1;
          LOBYTE(v88) = *(_BYTE *)(v88 + v14++);
          v51 = (unsigned __int8)v88 | (v51 << 8);
          *(_DWORD *)(a1 + 4) = v51;
        }
        v89 = (unsigned __int16)*v87;
        v90 = (v86 >> 11) * v89;
        v91 = v51 - v90;
        if ( v51 >= v90 )
        {
          v98 = v86 - v90;
          *(_DWORD *)a1 = v86 - v90;
          *(_DWORD *)(a1 + 4) = v91;
          *v87 -= *v87 >> 5;
          v99 = (_WORD *)(a1 + 2 * v15 + 616);
          if ( !((v86 - v90) >> 24) )
          {
            v100 = *(_QWORD *)(a1 + 16);
            v98 <<= 8;
            *(_DWORD *)a1 = v98;
            *(_QWORD *)(a1 + 24) = v14 + 1;
            v91 = *(unsigned __int8 *)(v100 + v14) | (v91 << 8);
            *(_DWORD *)(a1 + 4) = v91;
          }
          v101 = (unsigned __int16)*v99;
          v102 = (v98 >> 11) * v101;
          v56 = v91 >= v102;
          v103 = v91 - v102;
          if ( v56 )
          {
            *(_DWORD *)a1 = v98 - v102;
            *(_DWORD *)(a1 + 4) = v103;
            *v99 -= *v99 >> 5;
            v92 = *(_DWORD *)(a1 + 136);
            *(_DWORD *)(a1 + 136) = *(_DWORD *)(a1 + 132);
          }
          else
          {
            *(_DWORD *)a1 = v102;
            *v99 = v101 + ((unsigned int)(2048 - v101) >> 5);
            v92 = *(_DWORD *)(a1 + 132);
          }
          *(_DWORD *)(a1 + 132) = *(_DWORD *)(a1 + 128);
        }
        else
        {
          *(_DWORD *)a1 = v90;
          *v87 = v89 + ((unsigned int)(2048 - v89) >> 5);
          v92 = *(_DWORD *)(a1 + 128);
        }
        v125 = *(_DWORD *)(a1 + 124);
        *(_DWORD *)(a1 + 124) = v92;
        *(_DWORD *)(a1 + 128) = v125;
        goto LABEL_125;
      }
      *(_DWORD *)a1 = v50;
      *v47 = v49 + ((unsigned int)(2048 - v49) >> 5);
      v52 = (_WORD *)(a1 + 32 * v15 + 2 * v17 + 640);
      if ( !HIBYTE(v50) )
      {
        v53 = *(_QWORD *)(a1 + 16);
        v50 <<= 8;
        *(_DWORD *)a1 = v50;
        *(_QWORD *)(a1 + 24) = v14 + 1;
        v31 = *(unsigned __int8 *)(v53 + v14) | (v31 << 8);
        *(_DWORD *)(a1 + 4) = v31;
      }
      v54 = (unsigned __int16)*v52;
      v55 = (v50 >> 11) * v54;
      v56 = v31 >= v55;
      v57 = v31 - v55;
      if ( v56 )
      {
        *(_DWORD *)a1 = v50 - v55;
        *(_DWORD *)(a1 + 4) = v57;
        *v52 -= *v52 >> 5;
LABEL_125:
        if ( (unsigned int)v15 >= 7 )
          v126 = 11;
        else
          v126 = 8;
        *(_DWORD *)(a1 + 140) = v126;
        sub_17728((unsigned int *)a1, (unsigned __int16 *)(a1 + 2824), v17);
        goto LABEL_129;
      }
      v58 = v54 + ((unsigned int)(2048 - v54) >> 5);
      if ( (unsigned int)v15 >= 7 )
        v59 = 11;
      else
        v59 = 9;
      *(_DWORD *)a1 = v55;
      *v52 = v58;
      *(_DWORD *)(a1 + 140) = v59;
      *(_DWORD *)(a1 + 144) = 1;
    }
    else
    {
      *(_DWORD *)a1 = v30;
      *v27 = v29 + ((unsigned int)(2048 - v29) >> 5);
      v32 = *(_QWORD *)(a1 + 124);
      if ( (unsigned int)v15 >= 7 )
        v33 = 10;
      else
        v33 = 7;
      *(_DWORD *)(a1 + 136) = *(_DWORD *)(a1 + 132);
      *(_DWORD *)(a1 + 140) = v33;
      *(_QWORD *)(a1 + 128) = v32;
      sub_17728((unsigned int *)a1, (unsigned __int16 *)(a1 + 1796), v17);
      v34 = *(_DWORD *)(a1 + 144);
      v35 = *(_DWORD *)a1;
      v36 = 1;
      LODWORD(v37) = v34 - 2;
      if ( v34 >= 6 )
        v37 = 3LL;
      else
        v37 = (unsigned int)v37;
      do
      {
        while ( 1 )
        {
          v39 = (_WORD *)(a1 + (v37 << 7) + 2LL * v36 + 1024);
          if ( HIBYTE(v35) )
          {
            v43 = *(_DWORD *)(a1 + 4);
          }
          else
          {
            v40 = *(_QWORD *)(a1 + 16);
            v41 = *(_QWORD *)(a1 + 24);
            v35 <<= 8;
            *(_DWORD *)a1 = v35;
            v42 = *(_DWORD *)(a1 + 4);
            *(_QWORD *)(a1 + 24) = v41 + 1;
            v43 = *(unsigned __int8 *)(v40 + v41) | (v42 << 8);
            *(_DWORD *)(a1 + 4) = v43;
          }
          v44 = (unsigned __int16)*v39;
          v45 = (v35 >> 11) * v44;
          if ( v43 >= v45 )
            break;
          *(_DWORD *)a1 = v45;
          *v39 = v44 + ((2048 - v44) >> 5);
          v36 *= 2;
          v35 = (v35 >> 11) * v44;
          v38 = v36 - 64;
          if ( v36 >= 0x40 )
            goto LABEL_43;
        }
        v35 -= v45;
        *(_DWORD *)a1 = v35;
        *(_DWORD *)(a1 + 4) = v43 - v45;
        *v39 = v44 - (v44 >> 5);
        v43 -= v45;
        v36 = (2 * v36) | 1;
        v38 = v36 - 64;
      }
      while ( v36 < 0x40 );
LABEL_43:
      if ( v38 > 3 )
      {
        v71 = v38 >> 1;
        v72 = v38 & 1 | 2;
        *(_DWORD *)(a1 + 124) = v72;
        if ( v38 <= 0xD )
        {
          v73 = v71 - 1;
          v74 = v72 << v73;
          *(_DWORD *)(a1 + 124) = v74;
          if ( v73 <= 1 )
            v73 = 1;
          v75 = a1 + 124 + 2LL * v74;
          v76 = v73 - 1;
          v77 = 0;
          v78 = v75 - 2LL * v38 + 1410;
          v79 = 1LL;
          if ( !HIBYTE(v35) )
          {
            do
            {
              v81 = *(_QWORD *)(a1 + 16);
              v82 = *(_QWORD *)(a1 + 24);
              v35 <<= 8;
              *(_DWORD *)a1 = v35;
              v83 = *(_DWORD *)(a1 + 4);
              *(_QWORD *)(a1 + 24) = v82 + 1;
              v80 = *(unsigned __int8 *)(v81 + v82) | (v83 << 8);
              *(_DWORD *)(a1 + 4) = v80;
LABEL_83:
              v84 = (v35 >> 11) * *(unsigned __int16 *)(v78 + 2 * v79);
              if ( v80 >= v84 )
              {
                *(_DWORD *)a1 = v35 - v84;
                *(_DWORD *)(a1 + 4) = v80 - v84;
                *(_WORD *)(v78 + 2 * v79) -= *(_WORD *)(v78 + 2 * v79) >> 5;
                v85 = (2 * v79) | 1;
                *(_DWORD *)(a1 + 124) += 1 << v77;
                if ( v76 == v77 )
                  goto LABEL_129;
              }
              else
              {
                *(_DWORD *)a1 = v84;
                *(_WORD *)(v78 + 2 * v79) += (2048 - (unsigned int)*(unsigned __int16 *)(v78 + 2 * v79)) >> 5;
                v85 = 2 * v79;
                if ( v76 == v77 )
                  goto LABEL_129;
              }
              v35 = *(_DWORD *)a1;
              ++v77;
              v79 = v85;
            }
            while ( !HIBYTE(*(_DWORD *)a1) );
          }
          v80 = *(_DWORD *)(a1 + 4);
          goto LABEL_83;
        }
        v93 = v71 - 5;
        do
        {
          if ( HIBYTE(v35) )
          {
            v96 = v35;
          }
          else
          {
            v95 = *(_QWORD *)(a1 + 16);
            v94 = *(_QWORD *)(a1 + 24);
            v96 = v35 << 8;
            *(_DWORD *)a1 = v35 << 8;
            *(_QWORD *)(a1 + 24) = v94 + 1;
            v43 = *(unsigned __int8 *)(v95 + v94) | (v43 << 8);
            *(_DWORD *)(a1 + 4) = v43;
          }
          v35 = v96 >> 1;
          v97 = v43 - (v96 >> 1);
          --v93;
          v72 = ((2 * v72) | 1) + (v97 >> 31);
          v43 = ((v97 >> 31) & (v96 >> 1)) + v97;
          *(_DWORD *)a1 = v96 >> 1;
          *(_DWORD *)(a1 + 4) = v43;
          *(_DWORD *)(a1 + 124) = v72;
        }
        while ( v93 );
        v104 = 16 * v72;
        *(_DWORD *)(a1 + 124) = v104;
        if ( !(v96 >> 25) )
        {
          v106 = *(_QWORD *)(a1 + 16);
          v105 = *(_QWORD *)(a1 + 24);
          v35 <<= 8;
          *(_DWORD *)a1 = v35;
          *(_QWORD *)(a1 + 24) = v105 + 1;
          v43 = *(unsigned __int8 *)(v106 + v105) | (v43 << 8);
          *(_DWORD *)(a1 + 4) = v43;
        }
        v107 = *(unsigned __int16 *)(a1 + 1766);
        v108 = (v35 >> 11) * v107;
        v109 = v43 - v108;
        if ( v43 >= v108 )
        {
          v108 = v35 - v108;
          v104 |= 1u;
          *(_WORD *)(a1 + 1766) -= *(_WORD *)(a1 + 1766) >> 5;
          v110 = 3;
          v43 = v109;
          *(_DWORD *)a1 = v108;
          *(_DWORD *)(a1 + 4) = v109;
          *(_DWORD *)(a1 + 124) = v104;
          v111 = (_WORD *)(a1 + 1770);
          if ( HIBYTE(v108) )
            goto LABEL_144;
        }
        else
        {
          *(_DWORD *)a1 = v108;
          *(_WORD *)(a1 + 1766) = v107 + ((unsigned int)(2048 - v107) >> 5);
          v110 = 2;
          v111 = (_WORD *)(a1 + 1768);
          if ( HIBYTE(v108) )
          {
LABEL_144:
            v140 = (unsigned __int16)*v111;
            v141 = (v108 >> 11) * v140;
            v142 = v43 - v141;
            if ( v43 >= v141 )
            {
              v141 = v108 - v141;
              v104 += 2;
              *(_DWORD *)a1 = v141;
              *(_DWORD *)(a1 + 4) = v142;
              *v111 = v140 - (v140 >> 5);
              v144 = (2 * (v110 & 3)) | 1;
              *(_DWORD *)(a1 + 124) = v104;
              v43 = v142;
              v145 = (_WORD *)(a1 + 2LL * v144 + 1764);
              if ( HIBYTE(v141) )
                goto LABEL_149;
            }
            else
            {
              v143 = v140 + ((2048 - v140) >> 5);
              v144 = 2 * v110;
              *(_DWORD *)a1 = v141;
              *v111 = v143;
              v145 = (_WORD *)(a1 + 2LL * (unsigned int)(2 * v110) + 1764);
              if ( HIBYTE(v141) )
              {
LABEL_149:
                v148 = (unsigned __int16)*v145;
                v149 = (v141 >> 11) * v148;
                v150 = v43 - v149;
                if ( v43 >= v149 )
                {
                  v149 = v141 - v149;
                  v104 += 4;
                  *(_DWORD *)a1 = v149;
                  *(_DWORD *)(a1 + 4) = v150;
                  *v145 = v148 - (v148 >> 5);
                  *(_DWORD *)(a1 + 124) = v104;
                  v43 = v150;
                  v151 = (_WORD *)(a1 + 2LL * ((2 * (v144 & 7)) | 1) + 1764);
                  if ( HIBYTE(v149) )
                    goto LABEL_154;
                }
                else
                {
                  *(_DWORD *)a1 = v149;
                  *v145 = v148 + ((2048 - v148) >> 5);
                  v151 = (_WORD *)(a1 + 4LL * v144 + 1764);
                  if ( HIBYTE(v149) )
                  {
LABEL_154:
                    v154 = (unsigned __int16)*v151;
                    v155 = (v149 >> 11) * v154;
                    v56 = v43 >= v155;
                    v156 = v43 - v155;
                    if ( v56 )
                    {
                      *(_DWORD *)a1 = v149 - v155;
                      *(_DWORD *)(a1 + 4) = v156;
                      *v151 = v154 - (v154 >> 5);
                      *(_DWORD *)(a1 + 124) = v104 + 8;
                    }
                    else
                    {
                      *(_DWORD *)a1 = v155;
                      *v151 = v154 + ((2048 - v154) >> 5);
                    }
                    goto LABEL_129;
                  }
                }
                v153 = *(_QWORD *)(a1 + 16);
                v152 = *(_QWORD *)(a1 + 24);
                v149 <<= 8;
                *(_DWORD *)a1 = v149;
                *(_QWORD *)(a1 + 24) = v152 + 1;
                v43 = *(unsigned __int8 *)(v153 + v152) | (v43 << 8);
                *(_DWORD *)(a1 + 4) = v43;
                goto LABEL_154;
              }
            }
            v147 = *(_QWORD *)(a1 + 16);
            v146 = *(_QWORD *)(a1 + 24);
            v141 <<= 8;
            *(_DWORD *)a1 = v141;
            *(_QWORD *)(a1 + 24) = v146 + 1;
            v43 = *(unsigned __int8 *)(v147 + v146) | (v43 << 8);
            *(_DWORD *)(a1 + 4) = v43;
            goto LABEL_149;
          }
        }
        v139 = *(_QWORD *)(a1 + 16);
        v138 = *(_QWORD *)(a1 + 24);
        v108 <<= 8;
        *(_DWORD *)a1 = v108;
        *(_QWORD *)(a1 + 24) = v138 + 1;
        v43 = *(unsigned __int8 *)(v139 + v138) | (v43 << 8);
        *(_DWORD *)(a1 + 4) = v43;
        goto LABEL_144;
      }
      *(_DWORD *)(a1 + 124) = v38;
    }
LABEL_129:
    v127 = *(unsigned int *)(a1 + 124);
    if ( *(_QWORD *)(a1 + 64) <= v127 || *(_DWORD *)(a1 + 88) <= (unsigned int)v127 )
      return 0LL;
    v128 = *(_QWORD *)(a1 + 56);
    v129 = *(unsigned int *)(a1 + 144);
    v130 = *(_QWORD *)(a1 + 72) - v128;
    if ( v130 >= v129 )
      LODWORD(v130) = *(_DWORD *)(a1 + 144);
    v61 = v128 > v127;
    *(_DWORD *)(a1 + 144) = v129 - v130;
    v131 = v128 + ~v127;
    if ( !v61 )
      v131 += *(_QWORD *)(a1 + 80);
    v132 = *(_QWORD *)(a1 + 40);
    v133 = v130 - 1;
    v134 = *(_BYTE *)(v132 + v131);
    *(_QWORD *)(a1 + 56) = v128 + 1;
    for ( *(_BYTE *)(v132 + v128) = v134; v133; *(_BYTE *)(v135 + v136) = v137 )
    {
      v135 = *(_QWORD *)(a1 + 40);
      v136 = *(_QWORD *)(a1 + 56);
      if ( v131 + 1 == *(_QWORD *)(a1 + 80) )
        v131 = 0LL;
      else
        ++v131;
      v137 = *(_BYTE *)(v135 + v131);
      --v133;
      *(_QWORD *)(a1 + 56) = v136 + 1;
    }
    v1 = *(_QWORD *)(a1 + 56);
    if ( *(_QWORD *)(a1 + 64) < v1 )
      *(_QWORD *)(a1 + 64) = v1;
  }
  if ( !HIBYTE(*(_DWORD *)a1) )
  {
    v157 = *(_QWORD *)(a1 + 16);
    v158 = *(_QWORD *)(a1 + 24);
    *(_DWORD *)a1 <<= 8;
    v159 = *(_DWORD *)(a1 + 4);
    *(_QWORD *)(a1 + 24) = v158 + 1;
    *(_DWORD *)(a1 + 4) = *(unsigned __int8 *)(v157 + v158) | (v159 << 8);
  }
  return 1LL;
}

//----- (0000000000017728) ----------------------------------------------------
unsigned int *__fastcall sub_17728(unsigned int *result, unsigned __int16 *a2, int a3)
{
  unsigned int v3; // w8
  __int64 v4; // x9
  __int64 v5; // x10
  unsigned int v6; // w11
  unsigned int v7; // w9
  unsigned int v8; // w10
  bool v9; // cf
  unsigned int v10; // w9
  unsigned int v11; // w9
  __int64 v12; // x8
  int v13; // w10
  unsigned int v14; // w8
  __int64 v15; // x9
  __int64 v16; // x10
  unsigned int v17; // w11
  unsigned int v18; // w9
  unsigned int v19; // w10
  unsigned int v20; // w9
  unsigned int i; // w13
  unsigned int v22; // w11
  unsigned int v23; // w12
  __int64 v24; // x11
  __int64 v25; // x13
  __int64 v26; // x14
  unsigned int v27; // w15
  unsigned int v28; // w13
  unsigned int v29; // w14
  unsigned int v30; // w13

  v3 = *result;
  if ( HIBYTE(*result) )
  {
    v7 = result[1];
  }
  else
  {
    v4 = *((_QWORD *)result + 2);
    v5 = *((_QWORD *)result + 3);
    v3 <<= 8;
    *result = v3;
    v6 = result[1];
    *((_QWORD *)result + 3) = v5 + 1;
    v7 = *(unsigned __int8 *)(v4 + v5) | (v6 << 8);
    result[1] = v7;
  }
  v8 = (v3 >> 11) * *a2;
  v9 = v7 >= v8;
  v10 = v7 - v8;
  if ( v9 )
  {
    *result = v3 - v8;
    result[1] = v10;
    *a2 -= *a2 >> 5;
    v14 = *result;
    if ( HIBYTE(*result) )
    {
      v18 = result[1];
    }
    else
    {
      v15 = *((_QWORD *)result + 2);
      v16 = *((_QWORD *)result + 3);
      v14 <<= 8;
      *result = v14;
      v17 = result[1];
      *((_QWORD *)result + 3) = v16 + 1;
      v18 = *(unsigned __int8 *)(v15 + v16) | (v17 << 8);
      result[1] = v18;
    }
    v19 = (v14 >> 11) * a2[1];
    v9 = v18 >= v19;
    v20 = v18 - v19;
    if ( v9 )
    {
      *result = v14 - v19;
      result[1] = v20;
      v12 = (__int64)(a2 + 258);
      v11 = 256;
      a2[1] -= a2[1] >> 5;
      v13 = 18;
    }
    else
    {
      *result = v19;
      v11 = 8;
      v12 = (__int64)&a2[8 * a3 + 130];
      a2[1] += (2048 - (unsigned int)a2[1]) >> 5;
      v13 = 10;
    }
  }
  else
  {
    *result = v8;
    v11 = 8;
    v12 = (__int64)&a2[8 * a3 + 2];
    *a2 += (2048 - (unsigned int)*a2) >> 5;
    v13 = 2;
  }
  result[36] = v13;
  for ( i = 1; i < v11; v22 = i - v11 )
  {
    while ( 1 )
    {
      v23 = *result;
      v24 = i;
      if ( HIBYTE(*result) )
      {
        v28 = result[1];
      }
      else
      {
        v25 = *((_QWORD *)result + 2);
        v26 = *((_QWORD *)result + 3);
        v23 <<= 8;
        *result = v23;
        v27 = result[1];
        *((_QWORD *)result + 3) = v26 + 1;
        v28 = *(unsigned __int8 *)(v25 + v26) | (v27 << 8);
        result[1] = v28;
      }
      v29 = (v23 >> 11) * *(unsigned __int16 *)(v12 + 2 * v24);
      v9 = v28 >= v29;
      v30 = v28 - v29;
      if ( v9 )
        break;
      *result = v29;
      *(_WORD *)(v12 + 2 * v24) += (2048 - (unsigned int)*(unsigned __int16 *)(v12 + 2 * v24)) >> 5;
      i = 2 * v24;
      v22 = 2 * v24 - v11;
      if ( i >= v11 )
        goto LABEL_20;
    }
    *result = v23 - v29;
    result[1] = v30;
    i = (2 * v24) | 1;
    *(_WORD *)(v12 + 2 * v24) -= *(_WORD *)(v12 + 2 * v24) >> 5;
  }
LABEL_20:
  result[36] += v22;
  return result;
}

//----- (0000000000017908) ----------------------------------------------------
_QWORD *__fastcall sub_17908(__int64 a1, __int64 a2)
{
  _QWORD *v4; // x19
  char *v5; // x0
  void **v6; // x22
  __int64 v7; // x0

  v4 = sub_180F4(1u, 0x50u);
  if ( v4 )
  {
    v5 = sub_16154(2, 0xFFFFFFFF);
    if ( !v5 )
    {
LABEL_5:
      free(v4);
      return 0LL;
    }
    v6 = (void **)v5;
    *v4 = a1;
    v4[1] = v5;
    v4[9] = a2;
    v7 = sub_1810C(a2);
    v4[2] = v7;
    if ( !v7 )
    {
      sub_161E8(v6);
      goto LABEL_5;
    }
  }
  return v4;
}

//----- (0000000000017984) ----------------------------------------------------
unsigned __int64 __fastcall sub_17984(__int64 a1, __int64 a2, int a3)
{
  unsigned __int64 result; // x0
  unsigned __int64 v5; // x0
  unsigned __int64 v6; // x8
  unsigned __int64 v7; // x21
  int v8; // w0

  if ( *(_DWORD *)(a1 + 68) )
    return 0LL;
  *(_QWORD *)(a1 + 40) = a2;
  if ( !a2 )
    return 0xFFFFFFFFLL;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 56) = a3;
  do
  {
    if ( *(_QWORD *)(a1 + 24) == *(_QWORD *)(a1 + 32) )
    {
      v5 = fread(*(void **)(a1 + 16), 1u, *(_QWORD *)(a1 + 72), *(FILE **)a1);
      v6 = *(_QWORD *)(a1 + 72);
      v7 = v5;
      if ( v5 < v6 )
      {
        if ( !feof(*(FILE **)a1) )
          return 0xFFFFFFFFLL;
        v6 = *(_QWORD *)(a1 + 72);
      }
      if ( v6 >= v7 )
        v6 = v7;
      *(_QWORD *)(a1 + 24) = 0LL;
      *(_QWORD *)(a1 + 32) = v6;
    }
    v8 = sub_158F0(*(_QWORD *)(a1 + 8), (__int64 *)(a1 + 16));
    if ( v8 )
      break;
    result = *(_QWORD *)(a1 + 48);
  }
  while ( result < *(_QWORD *)(a1 + 56) );
  if ( v8 != 1 )
    return 0xFFFFFFFFLL;
  result = *(_QWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 68) = 1;
  return result;
}

//----- (0000000000017A58) ----------------------------------------------------
__int64 sub_17A58()
{
  return 0xFFFFFFFFLL;
}

//----- (0000000000017A60) ----------------------------------------------------
__int64 __fastcall sub_17A60(__int64 a1)
{
  sub_161E8(*(void ***)(a1 + 8));
  j__free(*(void **)(a1 + 16));
  j__free((void *)a1);
  return 0LL;
}

//----- (0000000000017A8C) ----------------------------------------------------
__int64 __fastcall sub_17A8C(__int64 *a1)
{
  __int64 v1; // x0
  void **v2; // x20
  __int64 result; // x0

  if ( (unsigned int)sub_180E8(a1) == 2 )
  {
    v1 = sub_180D0();
    if ( v1 )
    {
      v2 = (void **)v1;
      *(_DWORD *)(v1 + 48) = 1;
      result = funopen(v1, 0LL, sub_17D8C, 0LL, sub_17DFC);
      if ( result )
        return result;
      sub_180BC(0LL, (__int64)"java/lang/RuntimeException", aCouldNotCreate_0);
      sub_17E3C(v2);
    }
    else
    {
      sub_180BC(0LL, (__int64)"java/lang/RuntimeException", "could not create buffered stream");
    }
  }
  return 0LL;
}
// 18990: using guessed type __int64 __fastcall funopen(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000017B18) ----------------------------------------------------
__int64 __fastcall sub_17B18(__int64 *a1)
{
  __int64 v2; // x0
  __int64 v3; // x0
  const char *v4; // x2
  int v5; // w8

  v2 = pthread_mutex_lock(&stru_1C93C);
  if ( (_DWORD)v2 )
    abort();
  if ( dword_1C938 != 2 )
  {
    if ( dword_1C938 == 1 )
    {
      sub_180BC(v2, (__int64)"java/lang/RuntimeException", "re-initializing stream adapters after failed attempt");
      goto LABEL_10;
    }
    v3 = sub_180DC(*a1);
    if ( v3 && (v3 = sub_180B4(*a1), !(_BYTE)v3) )
    {
      v3 = sub_180C4(*(__int64 (__fastcall **)(__int64, __int64))(*a1 + 264));
      qword_1C968 = v3;
      if ( v3 && (v3 = sub_180B4(*a1), !(_BYTE)v3) )
      {
        v3 = sub_180DC(*a1);
        if ( v3 && (v3 = sub_180B4(*a1), !(_BYTE)v3) )
        {
          v3 = sub_180C4(*(__int64 (__fastcall **)(__int64, __int64))(*a1 + 264));
          qword_1C970 = v3;
          if ( v3 )
          {
            v3 = sub_180B4(*a1);
            if ( !(_BYTE)v3 )
            {
              v5 = 2;
              goto LABEL_9;
            }
          }
          v4 = (const char *)&unk_1F35;
        }
        else
        {
          v4 = (const char *)&unk_1DB7;
        }
      }
      else
      {
        v4 = (const char *)&unk_2070;
      }
    }
    else
    {
      v4 = (const char *)&unk_1DDB;
    }
    sub_180BC(v3, (__int64)"java/lang/RuntimeException", v4);
    v5 = 1;
LABEL_9:
    dword_1C938 = v5;
  }
LABEL_10:
  if ( pthread_mutex_unlock(&stru_1C93C) )
    abort();
  return (unsigned int)dword_1C938;
}
// 1C938: using guessed type int dword_1C938;
// 1C968: using guessed type __int64 qword_1C968;
// 1C970: using guessed type __int64 qword_1C970;

//----- (0000000000017CBC) ----------------------------------------------------
__int64 __fastcall sub_17CBC(__int64 *a1, __int64 a2)
{
  void *v4; // x19
  __int64 v5; // x0
  __int64 v6; // x23
  __int64 v7; // x22
  __int64 v9; // x0

  v4 = (void *)__wrap_malloc(0x4000LL);
  if ( v4
    && (v5 = (*(__int64 (__fastcall **)(__int64 *, __int64))(*a1 + 1408))(a1, 0x4000LL)) != 0
    && (v6 = v5, !(unsigned __int8)sub_180B4(*a1)) )
  {
    v9 = __wrap_malloc(56LL);
    v7 = v9;
    if ( v9 )
    {
      *(_QWORD *)(v9 + 16) = v6;
      *(_QWORD *)(v9 + 24) = v4;
      v4 = 0LL;
      *(_QWORD *)v9 = a1;
      *(_QWORD *)(v9 + 8) = a2;
      *(_QWORD *)(v9 + 32) = 0LL;
      *(_QWORD *)(v9 + 40) = 0LL;
      *(_DWORD *)(v9 + 48) = 0;
    }
    else
    {
      sub_1872C((__int64)a1, (__int64)"java/lang/RuntimeException", "could not allocate buffered_java_stream");
    }
  }
  else
  {
    sub_1872C((__int64)a1, (__int64)"java/lang/RuntimeException", "could not allocate buffer");
    v7 = 0LL;
  }
  free(v4);
  return v7;
}
// 18890: using guessed type __int64 __fastcall __wrap_malloc(_QWORD);

//----- (0000000000017D8C) ----------------------------------------------------
__int64 __fastcall sub_17D8C(_QWORD *a1, const void *a2, int a3)
{
  __int64 v3; // x8
  int v4; // w21
  int v5; // w22
  size_t v6; // w19

  v3 = a1[5];
  v4 = a3;
  v5 = 0x4000 - v3;
  if ( 0x4000 - (int)v3 <= a3 )
    v6 = 0x4000 - v3;
  else
    v6 = a3;
  memcpy((void *)(a1[3] + v3), a2, v6);
  a1[5] += (int)v6;
  if ( v5 <= v4 && (unsigned int)sub_17FEC(a1) )
    v6 = -1;
  return v6;
}

//----- (0000000000017DFC) ----------------------------------------------------
__int64 __fastcall sub_17DFC(__int64 a1)
{
  unsigned int v2; // w20

  if ( *(_DWORD *)(a1 + 48) )
    v2 = sub_17FEC((_QWORD *)a1);
  else
    v2 = 0;
  sub_17E3C((void **)a1);
  return v2;
}

//----- (0000000000017E3C) ----------------------------------------------------
void __fastcall sub_17E3C(void **a1)
{
  free(a1[3]);
  free(a1);
}

//----- (0000000000017E58) ----------------------------------------------------
__int64 __fastcall sub_17E58(__int64 *a1)
{
  __int64 v1; // x0
  void **v2; // x20
  __int64 result; // x0

  if ( (unsigned int)sub_180E8(a1) == 2 )
  {
    v1 = sub_180D0();
    if ( v1 )
    {
      v2 = (void **)v1;
      result = funopen(v1, sub_17EDC, 0LL, 0LL, sub_17DFC);
      if ( result )
        return result;
      sub_180BC(0LL, (__int64)"java/lang/RuntimeException", aCouldNotCreate_0);
      sub_17E3C(v2);
    }
    else
    {
      sub_180BC(0LL, (__int64)"java/lang/RuntimeException", "could not create buffered stream");
    }
  }
  return 0LL;
}
// 18990: using guessed type __int64 __fastcall funopen(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000017EDC) ----------------------------------------------------
__int64 __fastcall sub_17EDC(_QWORD *a1, void *dest, signed int a3)
{
  __int64 v3; // x8
  __int64 v4; // x9
  unsigned int v8; // w22
  signed int v9; // w9

  v3 = a1[4];
  v4 = a1[5];
  if ( v4 == v3 )
  {
    if ( (unsigned __int8)sub_180B4(*(_QWORD *)*a1) )
      return (unsigned int)-1;
    v8 = (*(__int64 (__fastcall **)(_QWORD, _QWORD, __int64, _QWORD))(*(_QWORD *)*a1 + 392LL))(
           *a1,
           a1[1],
           qword_1C968,
           a1[2]);
    if ( (*(unsigned __int8 (__fastcall **)(_QWORD))(*(_QWORD *)*a1 + 1824LL))(*a1) )
      return (unsigned int)-1;
    if ( v8 == -1 )
      v8 = 0;
    if ( v8 )
    {
      (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)*a1 + 1600LL))(
        *a1,
        a1[2],
        0LL,
        v8,
        a1[3]);
      if ( (unsigned __int8)sub_180B4(*(_QWORD *)*a1) )
        return (unsigned int)-1;
    }
    v3 = 0LL;
    LODWORD(v4) = v8;
    a1[4] = 0LL;
    a1[5] = (int)v8;
  }
  v9 = v4 - v3;
  if ( v9 )
  {
    if ( v9 < a3 )
      a3 = v9;
    memcpy(dest, (const void *)(a1[3] + v3), a3);
    a1[4] += a3;
  }
  else
  {
    a3 = 0;
  }
  return (unsigned int)a3;
}
// 1C968: using guessed type __int64 qword_1C968;

//----- (0000000000017FEC) ----------------------------------------------------
__int64 __fastcall sub_17FEC(_QWORD *a1)
{
  __int64 v1; // x8
  _QWORD *v2; // x21
  __int64 v3; // x9
  __int64 v4; // x20
  __int64 result; // x0

  v2 = a1 + 4;
  v1 = a1[4];
  v3 = a1[5];
  v4 = v3 - v1;
  if ( v3 == v1 )
    return 0LL;
  if ( (unsigned __int8)sub_180B4(*(_QWORD *)*a1) )
    return 0xFFFFFFFFLL;
  (*(void (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)*a1 + 1664LL))(
    *a1,
    a1[2],
    0LL,
    (unsigned int)v4,
    a1[3] + a1[4]);
  if ( (unsigned __int8)sub_180B4(*(_QWORD *)*a1) )
    return 0xFFFFFFFFLL;
  (*(void (__fastcall **)(_QWORD, _QWORD, __int64, _QWORD, _QWORD, __int64))(*(_QWORD *)*a1 + 488LL))(
    *a1,
    a1[1],
    qword_1C970,
    a1[2],
    0LL,
    v4);
  if ( (unsigned __int8)sub_180B4(*(_QWORD *)*a1) )
    return 0xFFFFFFFFLL;
  result = 0LL;
  *v2 = 0LL;
  v2[1] = 0LL;
  return result;
}
// 1C970: using guessed type __int64 qword_1C970;

//----- (00000000000180B4) ----------------------------------------------------
__int64 __usercall sub_180B4@<X0>(__int64 a1@<X8>)
{
  return (*(__int64 (**)(void))(a1 + 1824))();
}

//----- (00000000000180BC) ----------------------------------------------------
__int64 __fastcall sub_180BC(__int64 a1, __int64 a2, const char *a3)
{
  __int64 v3; // x19

  return sub_1872C(v3, a2, a3);
}
// 180C0: variable 'v3' is possibly undefined

//----- (00000000000180C4) ----------------------------------------------------
__int64 __usercall sub_180C4@<X0>(__int64 (__fastcall *a1)(__int64, __int64)@<X8>)
{
  __int64 v1; // x19
  __int64 v2; // x20

  return a1(v1, v2);
}
// 180CC: variable 'v1' is possibly undefined
// 180CC: variable 'v2' is possibly undefined

//----- (00000000000180D0) ----------------------------------------------------
__int64 sub_180D0()
{
  __int64 *v0; // x19
  __int64 v1; // x20

  return sub_17CBC(v0, v1);
}
// 180D8: variable 'v0' is possibly undefined
// 180D8: variable 'v1' is possibly undefined

//----- (00000000000180DC) ----------------------------------------------------
__int64 __usercall sub_180DC@<X0>(__int64 a1@<X8>)
{
  __int64 v1; // x19

  return (*(__int64 (__fastcall **)(__int64))(a1 + 48))(v1);
}
// 180E4: variable 'v1' is possibly undefined

//----- (00000000000180E8) ----------------------------------------------------
__int64 __fastcall sub_180E8(__int64 *a1)
{
  return sub_17B18(a1);
}

//----- (00000000000180F4) ----------------------------------------------------
void *__fastcall sub_180F4(size_t a1, size_t a2)
{
  void *result; // x0

  result = calloc(a1, a2);
  if ( !result )
    abort();
  return result;
}

//----- (000000000001810C) ----------------------------------------------------
__int64 __fastcall sub_1810C(__int64 a1)
{
  __int64 result; // x0

  result = __wrap_malloc(a1);
  if ( !result )
    abort();
  return result;
}
// 18890: using guessed type __int64 __fastcall __wrap_malloc(_QWORD);

//----- (0000000000018124) ----------------------------------------------------
void *__fastcall sub_18124(void *a1, size_t a2)
{
  void *result; // x0

  result = realloc(a1, a2);
  if ( !result )
    abort();
  return result;
}

//----- (0000000000018140) ----------------------------------------------------
char *__fastcall sub_18140(const char *a1)
{
  char *result; // x0

  result = strdup(a1);
  if ( !result )
    abort();
  return result;
}

//----- (0000000000018158) ----------------------------------------------------
void __fastcall sub_18158(__int64 a1)
{
  void *v2; // x0

  v2 = *(void **)a1;
  if ( v2 )
    free(v2);
  *(_QWORD *)a1 = 0LL;
  *(_QWORD *)(a1 + 8) = 0LL;
}

//----- (0000000000018178) ----------------------------------------------------
_QWORD *__fastcall sub_18178(_QWORD *result, const void *a2, __int64 a3)
{
  _QWORD *v3; // x21
  __int64 v4; // x23
  size_t v6; // w19
  __int64 v7; // x22
  char *v8; // x0

  if ( a3 )
  {
    v3 = result;
    v4 = result[1];
    v6 = a3;
    v7 = v4 + a3;
    v8 = (char *)realloc((void *)*result, (int)v4 + (int)a3);
    if ( !v8 )
      abort();
    *v3 = v8;
    v3[1] = v7;
    result = memcpy(&v8[(unsigned int)v4], a2, v6);
  }
  return result;
}

//----- (00000000000181E0) ----------------------------------------------------
char *__fastcall sub_181E0(unsigned int a1)
{
  if ( a1 >= 0x14 )
    abort();
  return (&off_19DB0)[a1];
}
// 19DB0: using guessed type char *off_19DB0;

//----- (0000000000018204) ----------------------------------------------------
void __fastcall sub_18204(__int64 a1)
{
  j__free(*(void **)(a1 + 16));
}

//----- (000000000001820C) ----------------------------------------------------
void __fastcall sub_1820C(void **a1)
{
  (*(void (__fastcall **)(void **))*a1)(a1);
  j__free(a1[1]);
  j__free(a1);
}

//----- (0000000000018234) ----------------------------------------------------
_QWORD *__fastcall sub_18234(const char *a1, __int64 a2)
{
  void *v4; // x0
  void *v5; // x19
  char *v6; // x0
  char *v7; // x21
  _QWORD *result; // x0

  v4 = (void *)sub_1810C(a2);
  if ( v4 )
  {
    v5 = v4;
    memset(v4, 0, a2);
    v6 = sub_18140(a1);
    if ( v6 )
    {
      v7 = v6;
      result = (_QWORD *)sub_1810C(32LL);
      if ( result )
      {
        result[2] = v5;
        result[3] = a2;
        *result = &off_1C8E8;
        result[1] = v7;
        return result;
      }
      j__free(v7);
    }
    j__free(v5);
  }
  return (_QWORD *)&byte_5;
}
// 5: using guessed type char byte_5;
// 1C8E8: using guessed type __int64 (__fastcall *off_1C8E8)();

//----- (00000000000182B8) ----------------------------------------------------
__int64 __fastcall sub_182B8(const char *a1, FILE *a2)
{
  __int64 v4; // x20
  __int128 v5; // q0
  void *ptr; // [xsp+0h] [xbp-40h] BYREF
  __int64 v8; // [xsp+8h] [xbp-38h]
  __int128 v9; // [xsp+10h] [xbp-30h] BYREF

  v9 = 0uLL;
  ptr = sub_18124(0LL, 0x10000u);
  v8 = 0x10000LL;
  while ( !feof(a2) )
  {
    if ( ferror(a2) )
      break;
    v8 = fread(ptr, 1u, 0x10000u, a2);
    sub_18178(&v9, ptr, v8);
  }
  if ( ferror(a2) )
  {
    v4 = 6LL;
  }
  else
  {
    v4 = sub_1810C(32LL);
    *(_QWORD *)(v4 + 8) = sub_18140(a1);
    v5 = v9;
    *(_QWORD *)v4 = &off_1C8E8;
    *(_OWORD *)(v4 + 16) = v5;
    v9 = 0uLL;
  }
  sub_18158((__int64)&v9);
  sub_18158((__int64)&ptr);
  return v4;
}
// 1C8E8: using guessed type __int64 (__fastcall *off_1C8E8)();

//----- (0000000000018398) ----------------------------------------------------
__int64 __fastcall sub_18398(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (00000000000183A0) ----------------------------------------------------
__int64 __fastcall sub_183A0(__int64 a1)
{
  return *(_QWORD *)(a1 + 24);
}

//----- (00000000000183A8) ----------------------------------------------------
__int64 __fastcall sub_183A8(__int64 a1)
{
  return *(_QWORD *)(a1 + 16);
}

//----- (00000000000183B0) ----------------------------------------------------
__int64 __fastcall sub_183B0(unsigned __int8 *a1)
{
  __int64 result; // x0
  unsigned __int8 *v3; // x8
  int v4; // t1

  result = *a1;
  if ( (_DWORD)result )
  {
    v3 = a1 + 1;
    do
    {
      v4 = *v3++;
      result = (unsigned int)(31 * result + v4);
    }
    while ( v4 );
  }
  return result;
}

//----- (00000000000183D8) ----------------------------------------------------
bool __fastcall sub_183D8(const char *a1, const char *a2)
{
  return strcmp(a1, a2) == 0;
}

//----- (00000000000183F0) ----------------------------------------------------
_QWORD *__fastcall sub_183F0(__int64 a1)
{
  _QWORD *v2; // x20

  v2 = sub_180F4(1u, 0x20u);
  *v2 = a1;
  v2[2] = 64LL;
  v2[3] = sub_180F4(0x40u, 0x10u);
  return v2;
}

//----- (0000000000018438) ----------------------------------------------------
void __fastcall sub_18438(void *a1)
{
  unsigned __int64 v1; // x8
  unsigned __int64 i; // x21
  _QWORD *v4; // x20
  _QWORD *v5; // x23
  void (__fastcall *v6)(_QWORD); // x8
  void (*v7)(void); // x8

  v1 = *((_QWORD *)a1 + 2);
  if ( v1 )
  {
    for ( i = 0LL; i < v1; ++i )
    {
      v4 = *(_QWORD **)(*((_QWORD *)a1 + 3) + 16 * i);
      if ( v4 )
      {
        do
        {
          v6 = *(void (__fastcall **)(_QWORD))(*(_QWORD *)a1 + 16LL);
          if ( v6 )
            v6(v4[1]);
          if ( v4[2] )
          {
            v7 = *(void (**)(void))(*(_QWORD *)a1 + 24LL);
            if ( v7 )
              v7();
          }
          v5 = (_QWORD *)*v4;
          *v4 = 0x100000LL;
          j__free(v4);
          v4 = v5;
        }
        while ( v5 );
        v1 = *((_QWORD *)a1 + 2);
      }
    }
  }
  j__free(*((void **)a1 + 3));
  j__free(a1);
}

//----- (00000000000184E4) ----------------------------------------------------
_QWORD *__fastcall sub_184E4(_QWORD *a1, __int64 a2)
{
  unsigned int v4; // w0
  _QWORD *v5; // x21

  v4 = (*(__int64 (__fastcall **)(__int64))*a1)(a2);
  v5 = *(_QWORD **)(a1[3] + 16 * (v4 - (unsigned __int64)v4 / a1[2] * a1[2]));
  if ( !v5 )
    return 0LL;
  while ( !(*(unsigned int (__fastcall **)(__int64, _QWORD))(*a1 + 8LL))(a2, v5[1]) )
  {
    v5 = (_QWORD *)*v5;
    if ( !v5 )
      return 0LL;
  }
  return v5 + 2;
}

//----- (0000000000018560) ----------------------------------------------------
_QWORD *__fastcall sub_18560(__int64 a1, __int64 a2, char *a3)
{
  unsigned int v6; // w0
  __int64 v7; // x23
  unsigned __int64 v8; // x24
  _QWORD *v9; // x25
  _QWORD *v10; // x8
  char v11; // w8
  _QWORD *v12; // x20
  _QWORD *v13; // x0
  unsigned __int64 v14; // x8
  unsigned __int64 v15; // x21
  char *v16; // x0
  unsigned __int64 v17; // x8
  char *v18; // x22
  unsigned __int64 i; // x23
  _QWORD **v20; // x25
  _QWORD *v21; // x26
  _QWORD *v22; // x8
  unsigned int v23; // w0
  char *v24; // x8
  __int64 v25; // x10
  void (__fastcall *v26)(__int64); // x8

  v6 = (**(__int64 (__fastcall ***)(__int64))a1)(a2);
  v7 = *(_QWORD *)(a1 + 24);
  v8 = v6 - (unsigned __int64)v6 / *(_QWORD *)(a1 + 16) * *(_QWORD *)(a1 + 16);
  v9 = (_QWORD *)(v7 + 16 * v8);
  v10 = (_QWORD *)*v9;
  if ( *v9 )
  {
    while ( 1 )
    {
      v9 = v10;
      if ( (*(unsigned int (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 8LL))(a2, v10[1]) )
        break;
      v10 = (_QWORD *)*v9;
      if ( !*v9 )
      {
        v11 = 1;
        goto LABEL_8;
      }
    }
    v11 = 0;
LABEL_8:
    v12 = v9;
    if ( a3 )
      goto LABEL_9;
  }
  else
  {
    v12 = 0LL;
    v11 = 1;
    if ( a3 )
    {
LABEL_9:
      *a3 = v11;
      goto LABEL_10;
    }
  }
LABEL_10:
  if ( (v11 & 1) != 0 )
  {
    v13 = sub_180F4(1u, 0x18u);
    v13[1] = a2;
    *v9 = v13;
    v12 = v13;
    ++*(_QWORD *)(a1 + 8);
    ++*(_QWORD *)(v7 + 16 * v8 + 8);
    v14 = *(_QWORD *)(a1 + 16);
    if ( v14 <= 2LL * *(_QWORD *)(a1 + 8) )
    {
      v15 = 2 * v14;
      v16 = (char *)sub_180F4(2 * (int)v14, 0x10u);
      v17 = *(_QWORD *)(a1 + 16);
      v18 = v16;
      if ( v17 )
      {
        for ( i = 0LL; i < v17; ++i )
        {
          v20 = (_QWORD **)(*(_QWORD *)(a1 + 24) + 16 * i);
          v21 = *v20;
          if ( *v20 )
          {
            do
            {
              v22 = (_QWORD *)*v21;
              *v21 = 0x100000LL;
              *v20 = v22;
              v23 = (**(__int64 (__fastcall ***)(_QWORD))a1)(v21[1]);
              v24 = &v18[16 * (v23 - v23 / v15 * v15)];
              v25 = *(_QWORD *)v24;
              ++*((_QWORD *)v24 + 1);
              *v21 = v25;
              *(_QWORD *)v24 = v21;
              v21 = *v20;
            }
            while ( *v20 );
            v17 = *(_QWORD *)(a1 + 16);
          }
        }
      }
      j__free(*(void **)(a1 + 24));
      *(_QWORD *)(a1 + 16) = v15;
      *(_QWORD *)(a1 + 24) = v18;
    }
  }
  else
  {
    v26 = *(void (__fastcall **)(__int64))(*(_QWORD *)a1 + 16LL);
    if ( v26 )
      v26(a2);
  }
  return v12 + 2;
}

//----- (0000000000018710) ----------------------------------------------------
char *__fastcall sub_18710(const char *a1)
{
  char *v1; // x0
  char *result; // x0

  v1 = strrchr(a1, 46);
  if ( v1 )
    result = v1 + 1;
  else
    result = 0LL;
  return result;
}

//----- (000000000001872C) ----------------------------------------------------
__int64 sub_1872C(__int64 a1, __int64 a2, const char *a3, ...)
{
  __int64 result; // x0
  __int64 v7; // x21
  __int64 v8; // [xsp+88h] [xbp-1A8h]
  __int64 v9; // [xsp+90h] [xbp-1A0h]
  __int64 v10; // [xsp+98h] [xbp-198h]
  __int64 v11; // [xsp+A0h] [xbp-190h]
  gcc_va_list arg; // [xsp+B0h] [xbp-180h] BYREF
  gcc_va_list va; // [xsp+D8h] [xbp-158h] BYREF
  char s[256]; // [xsp+F8h] [xbp-138h] BYREF
  __int64 v15; // [xsp+1F8h] [xbp-38h]

  va_start(va, a3);
  v8 = va_arg(va, _QWORD);
  v9 = va_arg(va, _QWORD);
  v10 = va_arg(va, _QWORD);
  v11 = va_arg(va, _QWORD);
  va_end(va);
  v15 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)a1 + 1824LL))(a1) )
    return 0LL;
  result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 48LL))(a1, a2);
  if ( result )
  {
    va_start(va, a3);
    v7 = result;
    va_copy(arg, va);
    vsnprintf(s, 0x100u, a3, arg);
    result = (*(unsigned int (__fastcall **)(__int64, __int64, char *))(*(_QWORD *)a1 + 112LL))(a1, v7, s) == 0;
  }
  return result;
}

// nfuncs=288 queued=201 decompiled=201 lumina nreq=0 worse=0 better=0
// ALL OK, 201 function(s) have been successfully decompiled
